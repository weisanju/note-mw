<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">我的笔记库</a></li><li class="chapter-item expanded affix "><li class="part-title">容器</li><li class="chapter-item expanded "><a href="1.容器_docker/index.html"><strong aria-hidden="true">1.</strong> docker</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1.容器_docker/DockerFile简介.html"><strong aria-hidden="true">1.1.</strong> DockerFile简介</a></li><li class="chapter-item expanded "><a href="1.容器_docker/dockcer-swarm.html"><strong aria-hidden="true">1.2.</strong> dockcer-swarm</a></li><li class="chapter-item expanded "><a href="1.容器_docker/docker-compose.html"><strong aria-hidden="true">1.3.</strong> docker-compose</a></li><li class="chapter-item expanded "><a href="1.容器_docker/docker-swarm集群搭建实例.html"><strong aria-hidden="true">1.4.</strong> docker-swarm集群搭建实例</a></li><li class="chapter-item expanded "><a href="1.容器_docker/docker-volume管理.html"><strong aria-hidden="true">1.5.</strong> docker-volume管理</a></li><li class="chapter-item expanded "><a href="1.容器_docker/docker容器连接.html"><strong aria-hidden="true">1.6.</strong> docker容器连接</a></li><li class="chapter-item expanded "><a href="1.容器_docker/docker搭建registry仓库.html"><strong aria-hidden="true">1.7.</strong> docker搭建registry仓库</a></li><li class="chapter-item expanded "><a href="1.容器_docker/docker搭建私有镜像库.html"><strong aria-hidden="true">1.8.</strong> docker搭建私有镜像库</a></li><li class="chapter-item expanded "><a href="1.容器_docker/docker离线安装.html"><strong aria-hidden="true">1.9.</strong> docker离线安装</a></li><li class="chapter-item expanded "><a href="1.容器_docker/docker网络管理.html"><strong aria-hidden="true">1.10.</strong> docker网络管理</a></li><li class="chapter-item expanded "><a href="1.容器_docker/docker远程连接配置.html"><strong aria-hidden="true">1.11.</strong> docker远程连接配置</a></li><li class="chapter-item expanded "><a href="1.容器_docker/redis主从与哨兵.html"><strong aria-hidden="true">1.12.</strong> redis主从与哨兵</a></li><li class="chapter-item expanded "><a href="1.容器_docker/使用实例.html"><strong aria-hidden="true">1.13.</strong> 使用实例</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> k8s</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="2.容器_k8s/k8s/index.html"><strong aria-hidden="true">2.1.</strong> k8s</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">运维与部署</li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> ansible</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.运维与部署_ansible/ansible/index.html"><strong aria-hidden="true">3.1.</strong> ansible</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.运维与部署_ansible/ansible/1.入门.html"><strong aria-hidden="true">3.1.1.</strong> 入门</a></li><li class="chapter-item expanded "><a href="3.运维与部署_ansible/ansible/Ansible.html"><strong aria-hidden="true">3.1.2.</strong> Ansible</a></li><li class="chapter-item expanded "><a href="3.运维与部署_ansible/ansible/Loops.html"><strong aria-hidden="true">3.1.3.</strong> Loops</a></li><li class="chapter-item expanded "><a href="3.运维与部署_ansible/ansible/ansible中的变量.html"><strong aria-hidden="true">3.1.4.</strong> ansible中的变量</a></li><li class="chapter-item expanded "><a href="3.运维与部署_ansible/ansible/ansible示例.html"><strong aria-hidden="true">3.1.5.</strong> ansible示例</a></li><li class="chapter-item expanded "><a href="3.运维与部署_ansible/ansible/inventor文件.html"><strong aria-hidden="true">3.1.6.</strong> inventor文件</a></li><li class="chapter-item expanded "><a href="3.运维与部署_ansible/ansible/playbooks.html"><strong aria-hidden="true">3.1.7.</strong> playbooks</a></li><li class="chapter-item expanded "><a href="3.运维与部署_ansible/ansible/临时命令行模式.html"><strong aria-hidden="true">3.1.8.</strong> 临时命令行模式</a></li><li class="chapter-item expanded "><a href="3.运维与部署_ansible/ansible/2.AnsibleConcepts/index.html"><strong aria-hidden="true">3.1.9.</strong> 2.AnsibleConcepts</a></li><li class="chapter-item expanded "><a href="3.运维与部署_ansible/ansible/3.内置模块/index.html"><strong aria-hidden="true">3.1.10.</strong> 3.内置模块</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.运维与部署_ansible/ansible/3.内置模块/1.Command.html"><strong aria-hidden="true">3.1.10.1.</strong> Command</a></li><li class="chapter-item expanded "><a href="3.运维与部署_ansible/ansible/3.内置模块/2.Shell.html"><strong aria-hidden="true">3.1.10.2.</strong> Shell</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">持续集成</li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> jenkins</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="4.持续集成_jenkins/Jenkins.html"><strong aria-hidden="true">4.1.</strong> Jenkins</a></li><li class="chapter-item expanded "><a href="4.持续集成_jenkins/jenkins_pipeline.html"><strong aria-hidden="true">4.2.</strong> jenkins_pipeline</a></li></ol></li><li class="chapter-item expanded "><li class="part-title"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 日志收集</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="5.日志收集/filebeat/index.html"><strong aria-hidden="true">5.1.</strong> filebeat</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5.日志收集/filebeat/1.HowFilebeatWorks.html"><strong aria-hidden="true">5.1.1.</strong> HowFilebeatWorks</a></li><li class="chapter-item expanded "><a href="5.日志收集/filebeat/ConfigureFilebeat/index.html"><strong aria-hidden="true">5.1.2.</strong> ConfigureFilebeat</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5.日志收集/filebeat/ConfigureFilebeat/1.Input.html"><strong aria-hidden="true">5.1.2.1.</strong> Input</a></li><li class="chapter-item expanded "><a href="5.日志收集/filebeat/ConfigureFilebeat/2.InputFileStream.html"><strong aria-hidden="true">5.1.2.2.</strong> InputFileStream</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">消息队列</li><li class="chapter-item expanded "><a href="6.消息队列_RocketMQ/index.html"><strong aria-hidden="true">6.</strong> RocketMQ</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="6.消息队列_RocketMQ/MQ消息的投递机制.html"><strong aria-hidden="true">6.1.</strong> MQ消息的投递机制</a></li><li class="chapter-item expanded "><a href="6.消息队列_RocketMQ/MQ的一致性算法实现原理.html"><strong aria-hidden="true">6.2.</strong> MQ的一致性算法实现原理</a></li><li class="chapter-item expanded "><a href="6.消息队列_RocketMQ/架构和设计.html"><strong aria-hidden="true">6.3.</strong> 架构和设计</a></li><li class="chapter-item expanded "><a href="6.消息队列_RocketMQ/案例.html"><strong aria-hidden="true">6.4.</strong> 案例</a></li><li class="chapter-item expanded "><a href="6.消息队列_RocketMQ/概念和特性.html"><strong aria-hidden="true">6.5.</strong> 概念和特性</a></li></ol></li><li class="chapter-item expanded "><a href="7.消息队列_KafaKa/index.html"><strong aria-hidden="true">7.</strong> KafaKa</a></li><li class="chapter-item expanded affix "><li class="part-title">缓存中间件</li><li class="chapter-item expanded "><a href="8.缓存中间件_Redis/index.html"><strong aria-hidden="true">8.</strong> Redis</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="8.缓存中间件_Redis/Redis应用-位图.html"><strong aria-hidden="true">8.1.</strong> Redis应用-位图</a></li><li class="chapter-item expanded "><a href="8.缓存中间件_Redis/Redis应用-分布式锁.html"><strong aria-hidden="true">8.2.</strong> Redis应用-分布式锁</a></li><li class="chapter-item expanded "><a href="8.缓存中间件_Redis/redis-keys与scan.html"><strong aria-hidden="true">8.3.</strong> redis-keys与scan</a></li><li class="chapter-item expanded "><a href="8.缓存中间件_Redis/redis-serverAndRedis-cli.html"><strong aria-hidden="true">8.4.</strong> redis-serverAndRedis-cli</a></li><li class="chapter-item expanded "><a href="8.缓存中间件_Redis/redis主从与哨兵.html"><strong aria-hidden="true">8.5.</strong> redis主从与哨兵</a></li><li class="chapter-item expanded "><a href="8.缓存中间件_Redis/redis发布与订阅.html"><strong aria-hidden="true">8.6.</strong> redis发布与订阅</a></li><li class="chapter-item expanded "><a href="8.缓存中间件_Redis/redis集群.html"><strong aria-hidden="true">8.7.</strong> redis集群</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.8.</strong> redis数据结构</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="8.缓存中间件_Redis/redis数据结构/Redis有序集合(sortedSet).html"><strong aria-hidden="true">8.8.1.</strong> Redis有序集合(sortedSet)</a></li><li class="chapter-item expanded "><a href="8.缓存中间件_Redis/redis数据结构/基本数据结构.html"><strong aria-hidden="true">8.8.2.</strong> 基本数据结构</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">源码管理</li><li class="chapter-item expanded "><a href="9.源码管理_GIT/index.html"><strong aria-hidden="true">9.</strong> GIT</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="9.源码管理_GIT/Git库管理.html"><strong aria-hidden="true">9.1.</strong> Git库管理</a></li><li class="chapter-item expanded "><a href="9.源码管理_GIT/gitDiff原理.html"><strong aria-hidden="true">9.2.</strong> gitDiff原理</a></li><li class="chapter-item expanded "><a href="9.源码管理_GIT/gitLog命令.html"><strong aria-hidden="true">9.3.</strong> gitLog命令</a></li><li class="chapter-item expanded "><a href="9.源码管理_GIT/gitflow.html"><strong aria-hidden="true">9.4.</strong> gitflow</a></li><li class="chapter-item expanded "><a href="9.源码管理_GIT/gitmerge.html"><strong aria-hidden="true">9.5.</strong> gitmerge</a></li><li class="chapter-item expanded "><a href="9.源码管理_GIT/gitrebase.html"><strong aria-hidden="true">9.6.</strong> gitrebase</a></li><li class="chapter-item expanded "><a href="9.源码管理_GIT/git使用案例.html"><strong aria-hidden="true">9.7.</strong> git使用案例</a></li><li class="chapter-item expanded "><a href="9.源码管理_GIT/git分支.html"><strong aria-hidden="true">9.8.</strong> git分支</a></li><li class="chapter-item expanded "><a href="9.源码管理_GIT/git命令杂项.html"><strong aria-hidden="true">9.9.</strong> git命令杂项</a></li><li class="chapter-item expanded "><a href="9.源码管理_GIT/git基础.html"><strong aria-hidden="true">9.10.</strong> git基础</a></li><li class="chapter-item expanded "><a href="9.源码管理_GIT/git错误提交后场景.html"><strong aria-hidden="true">9.11.</strong> git错误提交后场景</a></li><li class="chapter-item expanded "><a href="9.源码管理_GIT/tag管理.html"><strong aria-hidden="true">9.12.</strong> tag管理</a></li><li class="chapter-item expanded "><a href="9.源码管理_GIT/使用远程分支强制覆盖本地工作区暂存区版本库.html"><strong aria-hidden="true">9.13.</strong> 使用远程分支强制覆盖本地工作区暂存区版本库</a></li><li class="chapter-item expanded "><a href="9.源码管理_GIT/克隆.html"><strong aria-hidden="true">9.14.</strong> 克隆</a></li><li class="chapter-item expanded "><a href="9.源码管理_GIT/历史提交.html"><strong aria-hidden="true">9.15.</strong> 历史提交</a></li><li class="chapter-item expanded "><a href="9.源码管理_GIT/回退合并提交.html"><strong aria-hidden="true">9.16.</strong> 回退合并提交</a></li><li class="chapter-item expanded "><a href="9.源码管理_GIT/基本操作.html"><strong aria-hidden="true">9.17.</strong> 基本操作</a></li><li class="chapter-item expanded "><a href="9.源码管理_GIT/杂项.html"><strong aria-hidden="true">9.18.</strong> 杂项</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.19.</strong> GIT协作</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="9.源码管理_GIT/GIT协作/Git支持的协议.html"><strong aria-hidden="true">9.19.1.</strong> Git支持的协议</a></li><li class="chapter-item expanded "><a href="9.源码管理_GIT/GIT协作/冲突解决.html"><strong aria-hidden="true">9.19.2.</strong> 冲突解决</a></li><li class="chapter-item expanded "><a href="9.源码管理_GIT/GIT协作/补丁文件交互.html"><strong aria-hidden="true">9.19.3.</strong> 补丁文件交互</a></li><li class="chapter-item expanded "><a href="9.源码管理_GIT/GIT协作/远程版本库.html"><strong aria-hidden="true">9.19.4.</strong> 远程版本库</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="我的笔记库"><a class="header" href="#我的笔记库">我的笔记库</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>{% raw %}</p>
<h1 id="简介"><a class="header" href="#简介">简介</a></h1>
<p><a href="http://c.biancheng.net/docker/">Docker</a> 是一种运行于 Linux 和 Windows 上的软件，用于创建、管理和编排容器。</p>
<p>Docker 是在 GitHub 上开发的 Moby 开源项目的一部分。</p>
<p>“Docker”一词来自英国口语，意为码头工人（Dock Worker），即从船上装卸货物的人。</p>
<h2 id="docker-运行时与编排引擎"><a class="header" href="#docker-运行时与编排引擎">Docker 运行时与编排引擎</a></h2>
<p>多数技术人员在谈到 Docker 时，主要是指 <strong>Docker 引擎</strong>。</p>
<p>Docker 引擎是用于运行和编排容器的基础设施工具。有 VMware 管理经验的读者可以将其类比为 ESXi。</p>
<p>ESXi 是运行虚拟机的核心管理程序，而 Docker 引擎是运行容器的核心容器运行时。</p>
<p>其他 Docker 公司或第三方的产品都是围绕 Docker 引擎进行开发和集成的。</p>
<p>如下图所示，Docker 引擎位于中心，其他产品基于 Docker 引擎的核心功能进行集成。</p>
<p>Docker 引擎可以从 Docker 网站下载，也可以基于 GitHub 上的源码进行构建。无论是开源版本还是商业版本，都有 Linux 和 Windows 版本。</p>
<p>Docker 引擎主要有两个版本：企业版（EE）和社区版（CE）。</p>
<p>每个季度，企业版和社区版都会发布一个稳定版本。社区版本会提供 4 个月的支持，而企业版本会提供 12 个月的支持。</p>
<p>社区版还会通过 Edge 方式发布月度版。</p>
<p>从 2017 年第一季度开始，Docker 版本号遵循 YY.MM-xx 格式，类似于 Ubuntu 等项目。例如，2018 年 6 月第一次发布的社区版本为 18.06.0-ce。</p>
<h2 id="docker开源项目moby"><a class="header" href="#docker开源项目moby">Docker开源项目（Moby）</a></h2>
<p>Docker”一词也会用于指代开源 Docker 项目。其中包含一系列可以从 Docker 官网下载和安装的工具，比如 Docker 服务端和 Docker 客户端。</p>
<p>不过，该项目在 2017 年于 Austin 举办的 DockerCon 上正式命名为 Moby 项目。</p>
<p>由于这次改名，GitHub 上的 docker/docker 库也被转移到了 moby/moby，并且拥有了项目自己的 Logo，如下图所示。</p>
<p>Moby 项目的目标是基于开源的方式，发展成为 Docker 上游，并将 Docker 拆分为更多的模块化组件。</p>
<p>Moby 项目托管于 GitHub 的 Moby 代码库，包括子项目和工具列表。核心的 Docker 引擎项目位于 GitHub 的 moby/moby，但是引擎中的代码正持续被拆分和模块化。</p>
<p>作为一个开源项目，其源码是公开可得的，在遵循 Apache 协议 2.0 的情况下，任何人都可以自由地下载、贡献、调整和使用。</p>
<p>如果查看项目的提交历史，可以发现其中包含来自如下公司的基础技术：红帽、微软、IBM、思科，以及 HPE。此外，还可以看到一些并非来自大公司的贡献者。</p>
<p>多数项目及其工具都是基于 Golang 编写的，这是谷歌推出的一种新的系统级编程语言，又叫 Go 语言。使用 Go 语言的读者，将更容易为该项目贡献代码。</p>
<p>Mody/Docker 作为开源项目的好处在于其所有的设计和开发都是开放的，并摒弃了私有代码闭源开发模式下的陈旧方法。</p>
<p>因此发布过程也是公开进行的，不会再出现某个秘密的版本提前几个月就宣布要召开发布会和庆功会的荒唐情况。</p>
<p>Moby/Docker 不是这样运作的，项目中多数内容都是开放并欢迎任何人查看和作出贡献的。</p>
<p>Moby 项目以及更广泛的 Docker 运动一时间掀起了一波热潮。GitHub 上已经有数以千计的提交请求（pull request），以及数以万计的基于容器化技术的项目了，更不用说 Docker Hub 上数十亿的镜像下载。</p>
<p>Moby 项目已经给软件产业带来了翻天覆地的变化。</p>
<p>这并非妄想，Docker 已经得到了广泛的应用！</p>
<h2 id="容器生态"><a class="header" href="#容器生态">容器生态</a></h2>
<p>Docker 公司的一个核心哲学通常被称为“含电池，但可拆卸”（Batteries included but removable）。</p>
<p>意思是许多 Docker 内置的组件都可以替换为第三方的组件，网络技术栈就是一个很好的例子。</p>
<p>Docker 核心产品内置有网络解决方案。但是网络技术栈是可插拔的，这意味着 Docker 内置的网络方案可以被替换为第三方的方案。许多人都会这样使用。</p>
<p>早期的时候，经常出现第三方插件比 Docker 提供的内置组件更好的情况。然而这会对 Docker 公司的商业模式造成冲击。毕竟，Docker 公司需要依靠盈利来维持基业长青。</p>
<p>因此，“内置的电池”变得越来越好用了。这也导致了生态内部的紧张关系和竞争的加剧。</p>
<p>简单来说，Docker 内置的“电池”仍然是可插拔的，然而越来越不需要将它们移除了。</p>
<p>尽管如此，容器生态在一种良性的合作与竞争的平衡中还是得以繁荣发展。</p>
<p>在谈及容器生态时，人们经常使用到诸如“co-opetition”（意即合作与竞争，英文中 co-operation 与 competition 合并的词）与“frenemy”（英文中朋友 friend 与敌人 enemy 合并的词）这样的字眼。这是一个好现象！因为良性的竞争是创新之母。</p>
<h2 id="开放容器计划"><a class="header" href="#开放容器计划">开放容器计划</a></h2>
<p>如果不谈及开放容器计划（The Open Container Initiative, OCI）的话，对 Docker 和容器生态的探讨总是不完整的。</p>
<h1 id="docker安装"><a class="header" href="#docker安装">Docker安装</a></h1>
<pre><code class="language-shell">$ curl https://get.docker.com/ | sh
$ systemctl start docker
$ useradd docker -g docker
$ docker --version
$ docker system info
$ systemctl enable docker
$ systemctl is-enabled docker
$ systemctl is-active docker
</code></pre>
<h1 id="镜像"><a class="header" href="#镜像">镜像</a></h1>
<h2 id="介绍"><a class="header" href="#介绍">介绍</a></h2>
<p>首先需要先从镜像仓库服务中拉取镜像。常见的镜像仓库服务是 Docker Hub，但是也存在其他镜像仓库服务。</p>
<p>拉取操作会将镜像下载到本地 Docker 主机，可以使用该镜像启动一个或者多个容器。</p>
<p>镜像由多个层组成，每层叠加之后，从外部看来就如一个独立的对象。<strong>镜像内部是一个精简的操作系统（OS），同时还包含应用运行所必须的文件和依赖包。</strong></p>
<p>通常使用docker container run和docker service create命令从某个镜像启动一个或多个容器。</p>
<p>一旦容器从镜像启动后，二者之间就变成了互相依赖的关系，并且在镜像上启动的容器全部停止之前，镜像是无法被删除的。尝试删除镜像而不停止或销毁使用它的容器，会导致出错。</p>
<h2 id="镜像通常比较小"><a class="header" href="#镜像通常比较小">镜像通常比较小</a></h2>
<p>容器目的就是运行应用或者服务，这意味着容器的镜像中必须包含应用/服务运行所必需的操作系统和应用文件。</p>
<p>但是，容器又追求快速和小巧，这意味着构建镜像的时候通常需要裁剪掉不必要的部分，保持较小的体积。</p>
<p>例如，Docker 镜像通常不会包含 6 个不同的 Shell 让读者选择——通常 Docker 镜像中只有一个精简的Shell，甚至没有 Shell。</p>
<p>镜像中还不包含内核——容器都是共享所在 Docker 主机的内核。所以有时会说容器仅包含必要的操作系统（通常只有操作系统文件和文件系统对象）。</p>
<p>Docker 官方镜像 Alpine Linux 大约只有 4MB，可以说是 Docker 镜像小巧这一特点的比较典型的例子。</p>
<h2 id="拉取镜像"><a class="header" href="#拉取镜像">拉取镜像</a></h2>
<p><strong>拉取</strong></p>
<pre><code class="language-shell">docker image pull
docker pull ubuntu
</code></pre>
<p>默认情况下，镜像会从 Docker Hub 的仓库中拉取。</p>
<pre><code class="language-shell">docker image pull alpine:latest 
</code></pre>
<p>命令会从 Docker Hub 的 alpine 仓库中拉取标签为 latest 的镜像。</p>
<p><strong>位置</strong></p>
<p>Linux Docker 主机本地镜像仓库通常位于<code> /var/lib/docker/&lt;storage-driver&gt;，</code>Windows Docker 主机则是 C:\ProgramData\docker\windowsfilter。</p>
<p><strong>查看镜像</strong></p>
<p>可以使用以下命令检查 Docker 主机的本地仓库中是否包含镜像。</p>
<pre><code>docker image ls
</code></pre>
<h2 id="镜像仓库服务"><a class="header" href="#镜像仓库服务">镜像仓库服务</a></h2>
<h3 id="镜像仓库服务-1"><a class="header" href="#镜像仓库服务-1">镜像仓库服务</a></h3>
<p>Docker 镜像存储在镜像仓库服务（Image Registry）当中。</p>
<p>Docker 客户端的镜像仓库服务是可配置的，默认使用 Docker Hub。</p>
<p>镜像仓库服务包含多个镜像仓库（Image Repository）。同样，一个镜像仓库中可以包含多个镜像。</p>
<p><img src="1.%E5%AE%B9%E5%99%A8_docker//images/docker-image-reposerver.gif" alt="" /></p>
<h4 id="官方和非官方镜像仓库"><a class="header" href="#官方和非官方镜像仓库">官方和非官方镜像仓库</a></h4>
<p>Docker Hub 也分为官方仓库（Official Repository）和非官方仓库（Unofficial Repository）。</p>
<p>官方仓库中的镜像是由 Docker 公司审查的。这意味着其中的镜像会及时更新，由高质量的代码构成，这些代码是安全的，有完善的文档和最佳实践。</p>
<p>非官方仓库更像江湖侠客，其中的镜像不一定具备官方仓库的优点，但这并不意味着所有非官方仓库都是不好的！非官方仓库中也有一些很优秀的镜像。</p>
<h2 id="镜像命名和标签"><a class="header" href="#镜像命名和标签">镜像命名和标签</a></h2>
<p>只需要给出镜像的名字和标签，就能在官方仓库中定位一个镜像（采用“:”分隔）。从官方仓库拉取镜像时，docker image pull 命令的格式如下。</p>
<pre><code class="language-sh">docker image pull &lt;repository&gt;:&lt;tag&gt;
</code></pre>
<pre><code class="language-sh">$ docker image pull alpine:latest
$ docker image pull ubuntu:latest
</code></pre>
<p>这两条命令从 alpine 和 ubuntu 仓库拉取了标有“latest”标签的镜像。</p>
<p>如果没有在仓库名称后指定具体的镜像标签，则 Docker 会假设用户希望拉取标签为 latest 的镜像。</p>
<p>标签为 latest 的镜像没有什么特殊魔力！标有 latest 标签的镜像不保证这是仓库中最新的镜像！例如，Alpine 仓库中最新的镜像通常标签是 <em>edge</em>。通常来讲，使用 <em>latest</em> 标签时需要谨慎！</p>
<p>从非官方仓库拉取镜像也是类似的，读者只需要在仓库名称面前加上 Docker Hub 的用户名或者组织名称。</p>
<pre><code class="language-sh">$ docker image pull nigelpoulton/tu-demo:v2
</code></pre>
<h2 id="为镜像打多个标签"><a class="header" href="#为镜像打多个标签">为镜像打多个标签</a></h2>
<p>一个镜像可以根据用户需要设置多个标签。这是因为标签是存放在镜像元数据中的任意数字或字符串。</p>
<p>在 <code>docker image pull</code> 命令中指定 -a 参数来拉取仓库中的全部镜像。接下来可以通过运行 <code>docker image ls</code> 查看已经拉取的镜像。</p>
<h2 id="镜像查询过滤"><a class="header" href="#镜像查询过滤">镜像查询过滤</a></h2>
<p>那些没有标签的镜像被称为悬虚镜像，在列表中展示为<code>&lt;none&gt;:&lt;none&gt;</code></p>
<pre><code class="language-shell">$ docker image ls --filter dangling=true
REPOSITORY TAG IMAGE ID CREATED SIZE
&lt;none&gt; &lt;none&gt; 4fd34165afe0 7 days ago 14.5MB
</code></pre>
<p>通常出现这种情况，<strong>是因为构建了一个新镜像，然后为该镜像打了一个已经存在的标签</strong>。</p>
<p>当此情况出现，Docker 会构建新的镜像，然后发现已经有镜像包含相同的标签，接着 Docker 会移除旧镜像上面的标签，将该标签标在新的镜像之上。</p>
<p>Docker 目前支持如下的过滤器。</p>
<ul>
<li>dangling：可以指定 true 或者 false，仅返回悬虚镜像（true），或者非悬虚镜像（false）。</li>
<li>before：需要镜像名称或者 ID 作为参数，返回在之前被创建的全部镜像。</li>
<li>since：与 before 类似，不过返回的是指定镜像之后创建的全部镜像。</li>
<li>label：根据标注（label）的名称或者值，对镜像进行过滤。docker image ls命令输出中不显示标注内容。</li>
</ul>
<p>其他的过滤方式可以使用 reference。</p>
<pre><code class="language-sh">$ docker image ls --filter=reference=&quot;*:latest&quot;
REPOSITORY TAG IMAGE ID CREATED SIZE
alpine latest 3fd9065eaf02 8 days ago 4.15MB
test latest 8426e7efb777 3 days ago 122MB
</code></pre>
<p>可以使用 --format 参数来通过 Go 模板对输出内容进行格式化。</p>
<pre><code class="language-sh">$ docker image ls --format &quot;{{.Size}}&quot;
99.3MB
111MB
82.6MB
88.8MB
4.15MB
108MB
</code></pre>
<p>使用下面命令返回全部镜像，但是只显示仓库、标签和大小信息。</p>
<pre><code class="language-shell">$ docker image ls --format &quot;{{.Repository}}: {{.Tag}}: {{.Size}}&quot;
dodge: challenger: 99.3MB
ubuntu: latest: 111MB
python: 3.4-alpine: 82.6MB
python: 3.5-alpine: 88.8MB
alpine: latest: 4.15MB
nginx: latest: 108MB
</code></pre>
<h2 id="通过-cli-方式搜索-docker-hub"><a class="header" href="#通过-cli-方式搜索-docker-hub">通过 CLI 方式搜索 Docker Hub</a></h2>
<p><code>docker search</code> 命令允许通过 CLI 的方式搜索 Docker Hub。可以通过“NAME”字段的内容进行匹配，并且基于返回内容中任意列的值进行过滤。</p>
<p>简单模式下，该命令会搜索所有“NAME”字段中包含特定字符串的仓库。例如，下面的命令会查找所有“NAME”包含“nigelpoulton”的仓库。</p>
<pre><code class="language-shell">$ docker search nigelpoulton
</code></pre>
<p>需要注意，上面返回的镜像中既有官方的也有非官方的。读者可以使用 --filter &quot;is-official=true&quot;，使命令返回内容只显示官方镜像。</p>
<pre><code class="language-sh">$ docker search alpine --filter &quot;is-official=true&quot;
NAME DESCRIPTION STARS OFFICIAL AUTOMATED
alpine A minimal Docker.. 2988 [OK]
</code></pre>
<p>重复前面的操作，但这次只显示自动创建的仓库。</p>
<pre><code class="language-sh">$ docker search alpine --filter &quot;is-automated=true&quot;
NAME DESCRIPTION OFFICIAL AUTOMATED
anapsix/alpine-java Oracle Java 8 (and 7).. [OK]
frolvlad/alpine-glibc Alpine Docker image.. [OK]
kiasaki/alpine-postgres PostgreSQL docker.. [OK]
zzrot/alpine-caddy Caddy Server Docker.. [OK]
&lt;Snip&gt;
</code></pre>
<p>关于 <code>docker search</code> 需要注意的最后一点是，默认情况下，Docker 只返回 25 行结果。但是，可以通过指定 --limit 参数来增加返回内容行数，最多为 100 行。</p>
<h2 id="镜像和分层"><a class="header" href="#镜像和分层">镜像和分层</a></h2>
<p>Docker 镜像由一些松耦合的只读镜像层组成。如下图所示。</p>
<p><img src="1.%E5%AE%B9%E5%99%A8_docker//images/docker-image-layer.gif" alt="" /></p>
<p>Docker 负责堆叠这些镜像层，并且将它们表示为单个统一的对象。</p>
<p>查看镜像分层的方式可以通过 docker image inspect 命令。下面同样以 ubuntu:latest 镜像为例。</p>
<pre><code class="language-shell">$ docker image inspect ubuntu:latest
[
{
&quot;Id&quot;: &quot;sha256:bd3d4369ae.......fa2645f5699037d7d8c6b415a10&quot;,
&quot;RepoTags&quot;: [
&quot;ubuntu:latest&quot;

&lt;Snip&gt;

&quot;RootFS&quot;: {
  &quot;Type&quot;: &quot;layers&quot;,
  &quot;Layers&quot;: [
   &quot;sha256:c8a75145fc...894129005e461a43875a094b93412&quot;,
   &quot;sha256:c6f2b330b6...7214ed6aac305dd03f70b95cdc610&quot;,
   &quot;sha256:055757a193...3a9565d78962c7f368d5ac5984998&quot;,
   &quot;sha256:4837348061...12695f548406ea77feb5074e195e3&quot;,
   &quot;sha256:0cad5e07ba...4bae4cfc66b376265e16c32a0aae9&quot;
  ]
  }
}
]
</code></pre>
<p>缩减之后的输出也显示该镜像包含 5 个镜像层。只不过这次的输出内容中使用了镜像的 SHA256 散列值来标识镜像层。不过，两中命令都显示了镜像包含 5 个镜像层。</p>
<p><code>docker history</code> 命令显示了镜像的构建历史记录，但其并不是严格意义上的镜像分层。例如，有些 Dockerfile 中的指令并不会创建新的镜像层。比如 ENV、EXPOSE、CMD 以及 ENTRY- POINT。不过，这些命令会在镜像中添加元数据。</p>
<p>所有的 Docker 镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。</p>
<p>举一个简单的例子，假如基于 Ubuntu Linux 16.04 创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 <a href="http://c.biancheng.net/python/">Python</a> 包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。</p>
<p><img src="1.%E5%AE%B9%E5%99%A8_docker//images/docker-image-layer-three-layer.gif" alt="" /></p>
<p>在外部看来整个镜像只有 6 个文件，这是因为最上层中的文件 7 是文件 5 的一个更新版本。</p>
<p>这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。</p>
<p>Docker 通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。</p>
<h2 id="共享镜像层"><a class="header" href="#共享镜像层">共享镜像层</a></h2>
<p>多个镜像之间可以并且确实会共享镜像层。这样可以有效节省空间并提升性能。</p>
<pre><code class="language-shell">$ docker image pull -a nigelpoulton/tu-demo

latest: Pulling from nigelpoulton/tu-demo
237d5fcd25cf: Pull complete
a3ed95caeb02: Pull complete
&lt;Snip&gt;
Digest: sha256:42e34e546cee61adb100...a0c5b53f324a9e1c1aae451e9

v1: Pulling from nigelpoulton/tu-demo
237d5fcd25cf: Already exists
a3ed95caeb02: Already exists
&lt;Snip&gt;
Digest: sha256:9ccc0c67e5c5eaae4beb...24c1d5c80f2c9623cbcc9b59a

v2: Pulling from nigelpoulton/tu-demo
237d5fcd25cf: Already exists
a3ed95caeb02: Already exists
&lt;Snip&gt;
eab5aaac65de: Pull complete
Digest: sha256:d3c0d8c9d5719d31b79c...fef58a7e038cf0ef2ba5eb74c

Status: Downloaded newer image for nigelpoulton/tu-demo

$ docker image ls
REPOSITORY TAG IMAGE ID CREATED SIZE
nigelpoulton/tu-demo v2 6ac...ead 4 months ago 211.6 MB
nigelpoulton/tu-demo latest 9b9...e29 4 months ago 211.6 MB
nigelpoulton/tu-demo v1 9b9...e29 4 months ago 211.6 MB
</code></pre>
<p>注意那些以 Already exists 结尾的行。</p>
<p>由这几行可见，Docker 很聪明，可以识别出要拉取的镜像中，哪几层已经在本地存在。</p>
<p>在本例中，Docker 首先尝试拉取标签为 latest 的镜像。然后，当拉取标签为 v1 和 v2 的镜像时，Docker 注意到组成这两个镜像的镜像层，有一部分已经存在了。出现这种情况的原因是前面 3 个镜像相似度很高，所以共享了很多镜像层。</p>
<p>如前所述，Docker 在 Linux 上支持很多存储引擎（Snapshotter）。每个存储引擎都有自己的镜像分层、镜像层共享以及写时复制（CoW）技术的具体实现。</p>
<p>但是，其最终效果和用户体验是完全一致的。尽管 Windows 只支持一种存储引擎，还是可以提供与 Linux 相同的功能体验。</p>
<h2 id="根据摘要拉取镜像"><a class="header" href="#根据摘要拉取镜像">根据摘要拉取镜像</a></h2>
<p>咱们前面介绍了通过标签来拉取镜像，这也是常见的方式。但问题是，标签是可变的！这意味着可能偶尔出现给镜像打错标签的情况，有时甚至会给新镜像打一个已经存在的标签。这些都可能导致问题！</p>
<p>假设镜像 golftrack:1.5 存在一个已知的 Bug。因此可以拉取该镜像后修复它，并使用相同的标签将更新的镜像重新推送回仓库。</p>
<p>一起来思考下刚才发生了什么。镜像 golftrack:1.5 存在 Bug，这个镜像已经应用于生产环境。如果创建一个新版本的镜像，并修复了这个 Bug。</p>
<p>那么问题来了，构建新镜像并将其推送回仓库时使用了与问题镜像相同的标签！原镜像被覆盖，但在生产环境中遗留了大量运行中的容器，没有什么好办法区分正在使用的镜像版本是修复前还是修复后的，因为两个镜像的标签是相同的！</p>
<p>Docker 1.10 中引入了新的内容寻址存储模型。作为模型的一部分，每一个镜像现在都有一个基于其内容的密码散列值。</p>
<p>为了讨论方便，用摘要代指这个散列值。因为摘要是镜像内容的一个散列值，所以镜像内容的变更一定会导致散列值的改变。这意味着摘要是不可变的。这种方式可以解决前面讨论的问题。</p>
<p>每次拉取镜像，摘要都会作为 <code>docker image pull</code> 命令返回代码的一部分。只需要在 <code>docker image ls</code> 命令之后添加 --digests 参数即可在本地查看镜像摘要。</p>
<pre><code class="language-sh">$ docker image pull alpine
Using default tag: latest
latest: Pulling from library/alpine
e110a4a17941: Pull complete
Digest: sha256:3dcdb92d7432d56604d...6d99b889d0626de158f73a
Status: Downloaded newer image for alpine:latest

$ docker image ls --digests alpine
REPOSITORY TAG DIGEST IMAGE ID CREATED SIZE
alpine latest sha256:3dcd...f73a 4e38e38c8ce0 10 weeks ago 4.8 MB
</code></pre>
<h2 id="镜像散列值摘要"><a class="header" href="#镜像散列值摘要">镜像散列值（摘要）</a></h2>
<p>从 Docker 1.10 版本开始，镜像就是一系列松耦合的独立层的集合。</p>
<p>镜像本身就是一个配置对象，其中包含了镜像层的列表以及一些元数据信息。</p>
<p>镜像层才是实际数据存储的地方（比如文件等，镜像层之间是完全独立的，并没有从属于某个镜像集合的概念）。</p>
<p>镜像的唯一标识是一个加密 ID，即配置对象本身的散列值。每个镜像层也由一个加密 ID 区分，其值为镜像层本身内容的散列值。</p>
<p>这意味着修改镜像的内容或其中任意的镜像层，都会导致加密散列值的变化。所以，镜像和其镜像层都是不可变的，任何改动都能很轻松地被辨别。</p>
<p>这就是所谓的内容散列（Content Hash）。</p>
<p>到目前为止，事情都很简单。但是接下来的内容就有点儿复杂了。</p>
<p>在推送和拉取镜像的时候，都会对镜像层进行压缩来节省网络带宽以及仓库二进制存储空间。</p>
<p>但是压缩会改变镜像内容，这意味着镜像的内容散列值在推送或者拉取操作之后，会与镜像内容不相符！这显然是个问题。</p>
<p>例如，在推送镜像层到 Docker Hub 的时候，Docker Hub 会尝试确认接收到的镜像没有在传输过程中被篡改。</p>
<p>为了完成校验，Docker Hub 会根据镜像层重新计算散列值，并与原散列值进行比较。</p>
<p>因为镜像在传输过程中被压缩（发生了改变），所以散列值的校验也会失败。</p>
<p>为避免该问题，每个镜像层同时会包含一个分发散列值（Distribution Hash）。这是一个压缩版镜像的散列值，当从镜像仓库服务拉取或者推送镜像的时候，其中就包含了分发散列值，该散列值会用于校验拉取的镜像是否被篡改过。</p>
<p>这个内容寻址存储模型极大地提升了镜像的安全性，因为在拉取和推送操作后提供了一种方式来确保镜像和镜像层数据是一致的。</p>
<p>该模型也解决了随机生成镜像和镜像层 ID 这种方式可能导致的 ID 冲突问题。</p>
<h2 id="多层架构的镜像"><a class="header" href="#多层架构的镜像">多层架构的镜像</a></h2>
<p>Docker 最值得称赞的一点就是使用方便。例如，运行一个应用就像拉取镜像并运行容器这么简单。无须担心安装、依赖或者配置的问题。开箱即用。</p>
<p>但是，随着 Docker 的发展，事情开始变得复杂——尤其是在添加了新平台和架构之后，例如 Windows、ARM 以及 s390x。</p>
<p>这是会突然发现，在拉取镜像并运行之前，需要考虑镜像是否与当前运行环境的架构匹配，这破坏了 Docker 的流畅体验。</p>
<p>多架构镜像（Multi-architecture Image）的出现解决了这个问题！</p>
<p>Docker（镜像和镜像仓库服务）规范目前支持多架构镜像。这意味着某个镜像仓库标签（repository:tag）下的镜像可以同时支持 64 位 Linux、PowerPC Linux、64 位 Windows 和 ARM 等多种架构。</p>
<p>简单地说，就是一个镜像标签之下可以支持多个平台和架构。下面通过实操演示该特性。</p>
<p>为了实现这个特性，镜像仓库服务 API 支持两种重要的结构：Manifest 列表（新）和 Manifest。</p>
<p>Manifest 列表是指某个镜像标签支持的架构列表。其支持的每种架构，都有自己的 Mainfest 定义，其中列举了该镜像的构成。</p>
<p>下图使用 Golang 官方镜像作为示例。图左侧是 Manifest 列表，其中包含了该镜像支持的每种架构。</p>
<p>Manifest 列表的每一项都有一个箭头，指向具体的 Manifest，其中包含了镜像配置和镜像层数据。</p>
<p><img src="1.%E5%AE%B9%E5%99%A8_docker//images/docker-image-golang-multiarchitecture.gif" alt="" /></p>
<p>在具体操作之前，先来了解一下原理。</p>
<p>假设要在 Raspberry Pi（基于 ARM 架构的 Linux）上运行 Docker。</p>
<p>在拉取镜像的时候，Docker 客户端会调用 Docker Hub 镜像仓库服务相应的 API 完成拉取。</p>
<p>如果该镜像有 Mainfest 列表，并且存在 Linux on ARM 这一项，则 Docker Client 就会找到 ARM 架构对应的 Mainfest 并解析出组成该镜像的镜像层加密 ID。</p>
<p>然后从 Docker Hub 二进制存储中拉取每个镜像层。</p>
<p>下面的示例就展示了多架构镜像是如何在拉取官方 Golang 镜像（支持多架构）时工作的，并且通过一个简单的命令展示了 Go 的版本和所在主机的 CPU 架构。</p>
<p>需要注意的是，两个例子都使用相同的命令 docker container run。不需要告知 Docker 具体的镜像版本是 64 位 Linux 还是 64 位 Windows。</p>
<p>示例中只运行了普通的命令，选择当前平台和架构所需的正确镜像版本是有由 Docker 完成的。</p>
<h2 id="删除镜像"><a class="header" href="#删除镜像">删除镜像</a></h2>
<p>当读者不再需要某个镜像的时候，可以通过 <code>docker image rm</code> 命令从 Docker 主机删除该镜像。其中，rm 是 remove 的缩写。</p>
<pre><code>docker image rm 02674b9cb179
</code></pre>
<h2 id="镜像常用命令总结"><a class="header" href="#镜像常用命令总结">镜像常用命令总结</a></h2>
<pre><code>docker image pull
docker image pull alpine:latest
docker image ls
docker image inspect
docker image rm
</code></pre>
<h1 id="容器"><a class="header" href="#容器">容器</a></h1>
<h2 id="简介-1"><a class="header" href="#简介-1">简介</a></h2>
<pre><code class="language-sh">docker container run &lt;image&gt; &lt;app&gt;

# 会启动某个 Ubuntu Linux 容器，并运行 Bash Shell 作为其应用。
docker container run -it ubuntu /bin/bash
# 启动 PowerShell 并运行一个应用，则可以使用命令
docker container run -it microsoft- /powershell:nanoserver pwsh.exe
# 运行ubuntu 休眠10s
docker container run  ubuntu sleep 10
# 停止容器
docker container stop
# 开启容器
docker container start
</code></pre>
<p>-it 参数可以将当前终端连接到容器的 Shell 终端之上。</p>
<p>容器随着其中运行应用的退出而终止。其中 Linux 容器会在 Bash Shell 退出后终止，而 Windows 容器会在 PowerShell 进程终止后退出。</p>
<p>一个简单的验证方法就是启动新的容器，并运行 sleep 命令休眠 10s。容器会启动，然后运行休眠命令，在 10s 后退出。</p>
<h2 id="容器和虚拟机"><a class="header" href="#容器和虚拟机">容器和虚拟机</a></h2>
<p>容器和虚拟机都依赖于宿主机才能运行。宿主机可以是笔记本，是数据中心的物理服务器，也可以是公有云的某个实例。</p>
<p>在下面的示例中，假设宿主机是一台需要运行 4 个业务应用的物理服务器。</p>
<p>在虚拟机模型中，首先要开启物理机并启动 Hypervisor 引导程序。一旦 Hypervisor 启动，就会占有机器上的全部物理资源，如 CPU、RAM、存储和 NIC。</p>
<p>Hypervisor 接下来就会将这些物理资源划分为虚拟资源，并且看起来与真实物理资源完全一致。</p>
<p>然后 Hypervisor 会将这些资源打包进一个叫作虚拟机（VM）的软件结构当中。这样用户就可以使用这些虚拟机，并在其中安装操作系统和应用。</p>
<p>前面提到需要在物理机上运行 4 个应用，所以在 Hypervisor 之上需要创建 4 个虚拟机并安装 4 个操作系统，然后安装 4 个应用。当操作完成后，结构如下图所示。</p>
<p><img src="1.%E5%AE%B9%E5%99%A8_docker//images/vm_structure.gif" alt="" /></p>
<p>而容器模型则略有不同。</p>
<p>服务器启动之后，所选择的操作系统会启动。在 Docker 世界中可以选择 Linux，或者内核支持内核中的容器原语的新版本 Windows。</p>
<p>与虚拟机模型相同，OS 也占用了全部硬件资源。在 OS 层之上，需要安装容器引擎（如 Docker）。</p>
<p>容器引擎可以获取系统资源，比如进程树、文件系统以及网络栈，接着将资源分割为安全的互相隔离的资源结构，称之为容器。</p>
<p>每个容器看起来就像一个真实的操作系统，在其内部可以运行应用。按照前面的假设，需要在物理机上运行 4 个应用。</p>
<p><img src="1.%E5%AE%B9%E5%99%A8_docker//images/docker-structure.gif" alt="" /></p>
<p>从更高层面上来讲，Hypervisor 是硬件虚拟化（Hardware Virtualization）——Hypervisor 将硬件物理资源划分为虚拟资源。</p>
<p>容器是操作系统虚拟化（OS Virtualization）——容器将系统资源划分为虚拟资源。</p>
<h2 id="虚拟机的额外开销"><a class="header" href="#虚拟机的额外开销">虚拟机的额外开销</a></h2>
<p>基于前文所述内容，接下来会着重探讨 Hypervisor 模型的一个主要问题。</p>
<p>首先我们的目标是在一台物理机上运行 4 个业务相关应用。每种模型示例中都安装了一个操作系统或者 Hypervisor（一种针对虚拟机高度优化后的操作系统）。</p>
<p>虚拟机模型将底层硬件资源划分到虚拟机当中。每个虚拟机都是包含了虚拟 CPU、虚拟 RAM、虚拟磁盘等资源的一种软件结构。</p>
<p>因此，每个虚拟机都需要有自己的操作系统来声明、初始化并管理这些虚拟资源。</p>
<p>但是，操作系统本身是有其额外开销的。例如，每个操作系统都消耗一点 CPU、一点 RAM、一点存储空间等。</p>
<p>每个操作系统都需要独立的许可证，并且都需要打补丁升级，每个操作系统也都面临被攻击的风险。</p>
<p>通常将这种现象称作 OS Tax 或者 VM Tax，每个操作系统都占用一定的资源。</p>
<p>容器模型具有在宿主机操作系统中运行的单个内核。在一台主机上运行数十个甚至数百个容器都是可能的——容器共享一个操作系统/内核。</p>
<p>这意味着只有一个操作系统消耗 CPU、RAM 和存储资源，只有一个操作系统需要授权，只有一个操作系统需要升级和打补丁。同时，只有一个操作系统面临被攻击的风险。简言之，就是只有一份 OS 损耗。</p>
<p>在上述单台机器上只需要运行 4 个业务应用的场景中，也许问题尚不明显。但当需要运行成百上千应用的时候，就会引起质的变化。</p>
<p>另一个值得考虑的事情是启动时间。因为容器并不是完整的操作系统，所以其启动要远比虚拟机快。</p>
<p>切记，在容器内部并不需要内核，也就没有定位、解压以及初始化的过程——更不用提在内核启动过程中对硬件的遍历和初始化了。</p>
<p>这些在容器启动的过程中统统都不需要！唯一需要的是位于下层操作系统的共享内核是启动了的！最终结果就是，容器可以在 1s 内启动。唯一对容器启动时间有影响的就是容器内应用启动所花费的时间。</p>
<p>这就是容器模型要比虚拟机模型简洁并且高效的原因了。使用容器可以在更少的资源上运行更多的应用，启动更快，并且支付更少的授权和管理费用，同时面对未知攻击的风险也更小。</p>
<h2 id="检查-docker-daemon"><a class="header" href="#检查-docker-daemon">检查 Docker daemon</a></h2>
<pre><code class="language-sh">$ docker version
Client:
Version: API 17.05.0-ce
version: Go 1.29
version: Git go1.7.5
commit: 89658be
Built: Thu May 4 22:10:54 2017
OS/Arch: linux/amd64

Server:
Version: 17.05.0-ce
API version: 1.29 (minimum version 1.12)
Go version: go1.7.5
Git commit: 89658be
Built: Thu May 4 22:10:54 2017
OS/Arch: linux/amd64
Experimental: false
</code></pre>
<p>当命令输出中包含 Client 和 Server 的内容时，可以继续下面的操作。如果在 Server 部分中包含了错误码，这表示 Docker daemon 很可能没有运行，或者当前用户没有权限访问。</p>
<p>如果在 Linux 中遇到无权限访问的问题，需要确认当前用户是否属于本地 Docker UNIX 组。如果不是，可以通过<code>usermod -aG docker &lt;user&gt;</code>来添加，然后退出并重新登录 Shell，改动即可生效。</p>
<p>如果当前用户已经属于本地 docker 用户组，那么问题可能是 Docker daemon 没有运行导致。</p>
<pre><code class="language-sh">//使用 Systemd 在 Linux 系统中执行该命令
$ service docker status
docker start/running, process 29393

//使用Systemd在Linux系统中执行该命令
$ systemctl is-active docker
active

//在Windows Server 2016的PowerShell窗口中运行该命令
&gt; Get-Service docker

Status Name DisplayName
------ ---- -----------
Running Docker docker
</code></pre>
<h2 id="启动一个简单容器"><a class="header" href="#启动一个简单容器">启动一个简单容器</a></h2>
<pre><code class="language-sh">#Windows 示例。

$ docker container run -it microsoft/powershell:nanoserver pwsh.exe

#命令的基础格式为：
# 示例中使用 docker container run 来启动容器，这也是启动新容器的标准命令。

$ docker container run &lt;options&gt; &lt;im- age&gt;:&lt;tag&gt; &lt;app&gt;
</code></pre>
<h2 id="容器生命周期"><a class="header" href="#容器生命周期">容器生命周期</a></h2>
<pre><code class="language-sh"># 新建容器 名称为 precy
$ docker container run --name percy -it ubuntu:latest /bin/bash
#暂停容器
$ docker container stop &lt;container-id or container-name&gt;
# 写输入到容器
$ root@9cb2d2fd1d65:/tmp# echo &quot;DevOps FTW&quot; &gt; newfile
# 退出容器
ctrl +QP
# 暂停容器
$ docker container stop percy
# 查看运行中的容器
$ docker container ls
# 所有容器
$ docker container ls -a
# 启动容器
$ docker container start percy
# 连接容器
$ docker container exec -it percy bash
$ docker container stop percy
# 删除容器
$ docker container rm percy

</code></pre>
<h2 id="优雅地停止容器"><a class="header" href="#优雅地停止容器">优雅地停止容器</a></h2>
<pre><code># 向容器内的 PID 1 进程发送了 SIGTERM 这样的信号。
$ docker container stop
</code></pre>
<p>就像前文提到的一样，会为进程预留一个清理并优雅停止的机会。如果 10s 内进程没有终止，那么就会收到 SIGKILL 信号。这是致命一击。但是，进程起码有 10s 的时间来“解决”自己。</p>
<p><code>docker container rm &lt;container&gt; -f</code> 命令不会先友好地发送 SIGTERM，这条命令会直接发出 SIGKILL。就像刚刚所打的比方一样，该命令悄悄接近并对容器发起致命一击。</p>
<h2 id="利用重启策略进行容器的自我修复"><a class="header" href="#利用重启策略进行容器的自我修复">利用重启策略进行容器的自我修复</a></h2>
<p>通常建议在运行容器时配置好重启策略。这是容器的一种自我修复能力，可以在指定事件或者错误后重启来完成自我修复。</p>
<p>重启策略应用于每个容器，可以作为参数被强制传入 <code>docker-container run</code> 命令中，或者在 Compose 文件中声明（在使用 Docker Compose 以及 Docker Stacks 的情况下）。</p>
<p>容器支持的重启策略包括 </p>
<ul>
<li>always</li>
<li>unless-stopped </li>
<li>on-failed</li>
</ul>
<p>always 策略是一种简单的方式。除非容器被明确停止，比如通过 <code>docker container stop</code> 命令，否则该策略会一直尝试重启处于停止状态的容器。</p>
<h2 id="容器常用命令"><a class="header" href="#容器常用命令">容器常用命令</a></h2>
<pre><code class="language-sh"># 启动新容器的命令。该命令的最简形式接收镜像和命令作为参数。镜像用于创建容器，而命令则是希望容器运行的应用。
# Ctrl-PQ 会断开 Shell 和容器终端之间的链接，并在退出后保持容器在后台处于运行（UP）状态。
$ docker container run
# 此命令会停止运行中的容器，并将状态置为 Exited(0)。
$ docker container ls
# 用于在运行状态的容器中，启动一个新进程。该命令在将 Docker 主机 Shell 连接到一个运行中容器终端时非常有用。
$ docker container exec
#此命令会停止运行中的容器，并将状态置为 Exited(0)。
#该命令通过发送 SIGTERM 信号给容器内 PID 为 1 的进程达到目的。
#如果进程没有在 10s 之内得到清理并停止运行，那么会接着发送 SIGKILL 信号来强制停止该容器。
$ docker container stop
# 重启处于停止（Exited）状态的容器。可以在 docker container start 命令中指定容器的名称或者 ID。
$ docker container start
# 删除停止运行的容器
$ docker container rm
# 该命令接收容器名称和容器 ID 作为主要参数。
$ docker container inspect
</code></pre>
<h1 id="应用容器化"><a class="header" href="#应用容器化">应用容器化</a></h1>
<h2 id="概述"><a class="header" href="#概述">概述</a></h2>
<p><em>Docker</em> 的核心思想就是如何将应用整合到容器中，并且能在容器中实际运行。</p>
<p>将应用整合到容器中并且运行起来的这个过程，称为“容器化”（Containerizing），有时也叫作“Docker化”（Dockerizing）。</p>
<p>容器是为应用而生的，具体来说，容器能够简化应用的构建、部署和运行过程。</p>
<p>完整的应用容器化过程主要分为以下几个步骤。</p>
<ul>
<li>编写应用代码。</li>
<li>创建一个 Dockerfile，其中包括当前应用的描述、依赖以及该如何运行这个应用。</li>
<li>对该 Dockerfile 执行 <code>docker image build</code> 命令。</li>
<li>等待 Docker 将应用程序构建到 Docker 镜像中。</li>
</ul>
<p>一旦应用容器化完成（即应用被打包为一个 Docker 镜像），就能以镜像的形式交付并以容器的方式运行了。</p>
<h2 id="单体应用容器化"><a class="header" href="#单体应用容器化">单体应用容器化</a></h2>
<p>应用容器化的过程大致分为如下几个步骤：</p>
<ul>
<li>获取应用代码。</li>
<li>分析 Dockerfile。</li>
<li>构建应用镜像。</li>
<li>运行该应用。</li>
<li>测试应用。</li>
<li>容器应用化细节。</li>
<li>生产环境中的多阶段构建。</li>
<li>最佳实践。</li>
</ul>
<pre><code>FROM alpine # 以 alpine 镜像作为当前镜像基础
LABEL maintainer=&quot;nigelpoulton@hotmail.com&quot; #指定维护者（maintainer）为“nigelpoultion@hotmail.com”
RUN apk add --update nodejs nodejs-npm # 安装 Node.js 和 NPM
COPY . /src #将应用的代码复制到镜像当中
WORKDIR /src #设置新的工作目录
RUN npm install #安装依赖包
EXPOSE 8080 #记录应用的网络端口，
ENTRYPOINT [&quot;node&quot;, &quot;./app.js&quot;] #最后将 app.js 设置为默认运行的应用。
</code></pre>
<p>Dockerfile 主要包括两个用途：</p>
<ul>
<li>对当前应用的描述。</li>
<li>指导 Docker 完成应用的容器化（创建一个包含当前应用的镜像）。</li>
</ul>
<p>不要因 Dockerfile 就是一个描述文件而对其有所轻视！Dockerfile 能实现开发和部署两个过程的无缝切换。</p>
<p>同时 Dockerfile 还能帮助新手快速熟悉这个项目。Dockerfile 对当前的应用及其依赖有一个清晰准确的描述，并且非常容易阅读和理解。</p>
<p><strong>每个 Dockerfile 文件第一行都是 FROM 指令。</strong></p>
<p>FROM 指令指定的镜像，会作为当前镜像的一个基础镜像层，当前应用的剩余内容会作为新增镜像层添加到基础镜像层之上。</p>
<p><strong>Example解读</strong></p>
<p>本例中的应用基于 Linux 操作系统，所以在 FROM 指令当中所引用的也是一个 Linux 基础镜像；如果要容器化的应用是一个基于 Windows 操作系统的应用，就需要指定一个像 microsoft/aspnetcore-build 这样的 Windows 基础镜像了。</p>
<p>截至目前，基础镜像的结构如下图所示。</p>
<p><img src="1.%E5%AE%B9%E5%99%A8_docker//images/docker-layer-basic-1.gif" alt="" /></p>
<p>接下来，Dockerfile 中通过标签（LABLE）方式指定了当前镜像的维护者为“nigelpoulton@hotmail. com”。</p>
<p>每个标签其实是一个键值对（Key-Value），在一个镜像当中可以通过增加标签的方式来为镜像添加自定义元数据。</p>
<p><code>RUN apk add --update nodejs nodejs-npm</code> 指令使用 alpine 的 apk 包管理器将 nodejs 和 nodejs-npm 安装到当前镜像之中。</p>
<p>RUN 指令会在 FROM 指定的 alpine 基础镜像之上，新建一个镜像层来存储这些安装内容。当前镜像的结构如下图所示。</p>
<p>COPY. / src 指令将应用相关文件从构建上下文复制到了当前镜像中，并且新建一个镜像层来存储。COPY 执行结束之后，当前镜像共包含 3 层，如下图所示。</p>
<p><img src="1.%E5%AE%B9%E5%99%A8_docker//images/docker-layer-2.gif" alt="" /></p>
<p>下一步，Dockerfile 通过 WORKDIR 指令，为 Dockerfile 中尚未执行的指令设置工作目录。</p>
<p>该目录与镜像相关，并且会作为元数据记录到镜像配置中，但不会创建新的镜像层。</p>
<p>然后，<code>RUN npm install</code> 指令会根据 package.json 中的配置信息，使用 npm 来安装当前应用的相关依赖包。</p>
<p>目前镜像一共包含 4 层，如下图所示。</p>
<p><img src="1.%E5%AE%B9%E5%99%A8_docker//images/docker-layer-3.gif" alt="" /></p>
<p>因为当前应用需要通过 TCP 端口 8080 对外提供一个 Web 服务，所以在 Dockerfile 中通过 EXPOSE 8080 指令来完成相应端口的设置。</p>
<p>这个配置信息会作为镜像的元数据被保存下来，并不会产生新的镜像层。</p>
<p>最终，通过 ENTRYPOINT 指令来指定当前镜像的入口程序。</p>
<p>ENTRYPOINT 指定的配置信息也是通过镜像元数据的形式保存下来，而不是新增镜像层。</p>
<p><strong>启动容器</strong></p>
<pre><code class="language-sh">#-d 参数的作用是让应用程序以守护线程的方式在后台运行。
# -p 80:8080 参数的作用是将主机的80端口与容器内的8080端口进行映射。
$ docker container run -d --name c1 -p 80:8080  web:latest 
</code></pre>
<p><code>docker image history</code></p>
<p>每行内容都对应了 Dockerfile 中的一条指令（顺序是自下而上）。CREATE BY 这一列中还展示了当前行具体对应 Dockerfile 中的哪条指令。</p>
<p>其次，从这个输出内容中，可以观察到只有 4 条指令会新建镜像层（就是那些 SIZE 列对应的数值不为零的指令），分别对应 Dockerfile 中的 FROM、RUN 以及 COPY 指令。</p>
<p>虽然其他指令看上去跟这些新建镜像层的指令并无区别，但实际上它们只在镜像中新增了元数据信息。这些指令之所以看起来没有区别，是因为 Docker 对之前构建镜像层方式的兼容。</p>
<p>使用 FROM 指令引用官方基础镜像是一个很好的习惯，这是因为官方的镜像通常会遵循一些最佳实践，并且能帮助使用者规避一些已知的问题。</p>
<p>通过 <code>docker image build</code> 命令具体的输出内容，可以了解镜像构建的过程。</p>
<p>在下面的片段中，可以看到基本的构建过程是，运行临时容器 -&gt; 在该容器中运行 Dockerfile 中的指令 -&gt; 将指令运行结果保存为一个新的镜像层 -&gt; 删除临时容器。</p>
<pre><code>Step 3/8 : RUN apk add --update nodejs nodejs-npm
---&gt; Running in e690ddca785f &lt;&lt; Run inside of temp container
fetch http://dl-cdn...APKINDEX.tar.gz
fetch http://dl-cdn...APKINDEX.tar.gz
(1/10) Installing ca-certificates (20171114-r0)
&lt;Snip&gt;
OK: 61 MiB in 21 packages
---&gt; c1d31d36b81f &lt;&lt; Create new layer
Removing intermediate container &lt;&lt; Remove temp container
Step 4/8 : COPY . /src
</code></pre>
<h2 id="生产环境中的多阶段构建"><a class="header" href="#生产环境中的多阶段构建">生产环境中的多阶段构建</a></h2>
<h3 id="过大体积的问题"><a class="header" href="#过大体积的问题">过大体积的问题</a></h3>
<p>对于 Docker 镜像来说，过大的体积并不好！</p>
<p>越大则越慢，这就意味着更难使用，而且可能更加脆弱，更容易遭受攻击。</p>
<p>鉴于此，Docker 镜像应该尽量小。对于生产环境镜像来说，目标是将其缩小到仅包含运行应用所必需的内容即可。问题在于，生成较小的镜像并非易事。</p>
<p>不同的 Dockerfile 写法就会对镜像的大小产生显著影响。</p>
<p><strong>使用 &amp;&amp; 连接多个命令</strong></p>
<p>常见的例子是，每一个 RUN 指令会新增一个镜像层。因此，通过使用 &amp;&amp; 连接多个命令以及使用反斜杠（\）换行的方法，将多个命令包含在一个 RUN 指令中，通常来说是一种值得提倡的方式。</p>
<p><strong>构建工具残留</strong></p>
<p>另一个问题是开发者通常不会在构建完成后进行清理。当使用 RUN 执行一个命令时，可能会拉取一些构建工具，这些工具会留在镜像中移交至生产环境。</p>
<p><strong>采用构建者模式</strong></p>
<p>有多种方式来改善这一问题——比如常见的是采用建造者模式（Builder Pattern）。但无论采用哪种方式，通常都需要额外的培训，并且会增加构建的复杂度。</p>
<p>建造者模式需要至少两个 Dockerfile，一个用于开发环境，一个用于生产环境。</p>
<p>首先需要编写 Dockerfile.dev，它基于一个大型基础镜像（Base Image），拉取所需的构建工具，并构建应用。</p>
<p>接下来，需要基于 Dockerfile.dev 构建一个镜像，并用这个镜像创建一个容器。</p>
<p>这时再编写 Dockerfile.prod，它基于一个较小的基础镜像开始构建，并从刚才创建的容器中将应用程序相关的部分复制过来。</p>
<p>整个过程需要编写额外的脚本才能串联起来。</p>
<p>这种方式是可行的，但是比较复杂。</p>
<p>多阶段构建（Multi-Stage Build）是一种更好的方式！</p>
<p>多阶段构建能够在不增加复杂性的情况下优化构建过程。</p>
<h3 id="下面介绍一下多阶段构建方式"><a class="header" href="#下面介绍一下多阶段构建方式"><strong>下面介绍一下多阶段构建方式</strong></a></h3>
<p>多阶段构建方式使用一个 Dockerfile，其中包含多个 FROM 指令。每一个 FROM 指令都是一个新的构建阶段（Build Stage），并且可以方便地复制之前阶段的构件。</p>
<pre><code>FROM node:latest AS storefront
WORKDIR /usr/src/atsea/app/react-app
COPY react-app .
RUN npm install
RUN npm run build

FROM maven:latest AS appserver
WORKDIR /usr/src/atsea
COPY pom.xml .
RUN mvn -B -f pom.xml -s /usr/share/maven/ref/settings-docker.xml dependency
\:resolve
COPY . .
RUN mvn -B -s /usr/share/maven/ref/settings-docker.xml package -DskipTests

FROM java:8-jdk-alpine AS production
RUN adduser -Dh /home/gordon gordon
WORKDIR /static
COPY --from=storefront /usr/src/atsea/app/react-app/build/ .
WORKDIR /app
COPY --from=appserver /usr/src/atsea/target/AtSea-0.0.1-SNAPSHOT.jar .
ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/app/AtSea-0.0.1-SNAPSHOT.jar&quot;]
CMD [&quot;--spring.profiles.active=postgres&quot;]
</code></pre>
<p>首先注意到，Dockerfile 中有 3 个 FROM 指令。每一个 FROM 指令构成一个单独的构建阶段。</p>
<p>各个阶段在内部从 0 开始编号。不过，示例中针对每个阶段都定义了便于理解的名字。</p>
<ul>
<li>阶段 0 叫作 storefront。</li>
<li>阶段 1 叫作 appserver。</li>
<li>阶段 2 叫作 production。</li>
</ul>
<p><strong>storefront</strong> </p>
<p>storefront 阶段拉取了大小超过 600MB 的 node:latest 镜像，然后设置了工作目录，复制一些应用代码进去，然后使用 2 个 RUN 指令来执行 npm 操作。</p>
<p>这会生成 3 个镜像层并显著增加镜像大小。指令执行结束后会得到一个比原镜像大得多的镜像，其中包含许多构建工具和少量应用程序代码。</p>
<p><strong>appserver</strong> </p>
<p>appserver 阶段拉取了大小超过 700MB 的 maven:latest 镜像。然后通过 2 个 COPY 指令和 2 个 RUN 指令生成了 4 个镜像层。</p>
<p>这个阶段同样会构建出一个非常大的包含许多构建工具和非常少量应用程序代码的镜像。</p>
<p>production 阶段拉取 java:8-jdk-alpine 镜像，这个镜像大约 150MB，明显小于前两个构建阶段用到的 node 和 maven 镜像。</p>
<p>这个阶段会创建一个用户，设置工作目录，从 storefront 阶段生成的镜像中复制一些应用代码过来。</p>
<p>之后，设置一个不同的工作目录，然后从 appserver 阶段生成的镜像中复制应用相关的代码。最后，production 设置当前应用程序为容器启动时的主程序。</p>
<p>重点在于 COPY --from 指令，它从之前的阶段构建的镜像中仅复制生产环境相关的应用代码，而不会复制生产环境不需要的构件。</p>
<p>还有一点也很重要，多阶段构建这种方式仅用到了一个 Dockerfile，并且 <code>docker image build</code> 命令不需要增加额外参数。</p>
<pre><code class="language-sh"> docker image build -t multi:stage .
# 示例中 multi:stage 标签是自行定义的，可以根据自己的需要和规范来指定标签名称。不过并不要求一定必须为多阶段构建指定标签。
</code></pre>
<p>可见它明显比之前阶段拉取和生成的镜像要小。这是因为该镜像是基于相对精简的 java:8-jdk-alpine 镜像构建的，并且仅添加了用于生产环境的应用程序文件。</p>
<p>最终，无须额外的脚本，仅对一个单独的 Dockerfile 执行 <code>docker image build</code> 命令，就创建了一个精简的生产环境镜像。</p>
<p>多阶段构建是随 Docker 17.05 版本新增的一个特性，用于构建精简的生产环境镜像。</p>
<h2 id="最佳实践"><a class="header" href="#最佳实践">最佳实践</a></h2>
<h3 id="利用构建缓存"><a class="header" href="#利用构建缓存">利用构建缓存</a></h3>
<p>Docker 的构建过程利用了缓存机制。观察缓存效果的一个方法，就是在一个干净的 Docker 主机上构建一个新的镜像，然后再重复同样的构建。</p>
<p>第一次构建会拉取基础镜像，并构建镜像层，构建过程需要花费一定时间；第二次构建几乎能够立即完成。</p>
<p>这就是因为第一次构建的内容（如镜像层）能够被缓存下来，并被后续的构建过程复用。</p>
<p><code>docker image build</code> 命令会从顶层开始解析 Dockerfile 中的指令并逐行执行。而对每一条指令，Docker 都会检查缓存中是否已经有与该指令对应的镜像层。</p>
<p>如果有，即为缓存命中（Cache Hit），并且会使用这个镜像层；如果没有，则是缓存未命中（Cache Miss），Docker 会基于该指令构建新的镜像层。</p>
<p>缓存命中能够显著加快构建过程。</p>
<pre><code>FROM alpine
RUN apk add --update nodejs nodejs-npm
COPY . /src
WORKDIR /src
RUN npm install
EXPOSE 8080
ENTRYPOINT [&quot;node&quot;, &quot;./app.js&quot;]
</code></pre>
<p><strong>缓存策略</strong></p>
<p>如果主机中已经存在这个镜像，那么构建时会直接跳到下一条指令；如果镜像不存在，则会从 Docker Hub（docker.io）拉取。</p>
<p>下一条指令（RUN apk...）对镜像执行一条命令。</p>
<p>此时，Docker 会检查构建缓存中是否存在基于同一基础镜像，并且执行了相同指令的镜像层。</p>
<p>在此例中，Docker 会检查缓存中是否存在一个基于 alpine:latest 镜像且执行了 <code>RUN apk add --update nodejs nodejs-npm</code> 指令构建得到的镜像层。</p>
<p>如果找到该镜像层，Docker 会跳过这条指令，并链接到这个已经存在的镜像层，然后继续构建；如果无法找到符合要求的镜像层，则设置缓存无效并构建该镜像层。</p>
<p><strong>一旦没命中缓存后续再不缓存</strong></p>
<p>此处“设置缓存无效”作用于本次构建的后续部分。也就是说 Dockerfile 中接下来的指令将全部执行而不会再尝试查找构建缓存。</p>
<p>假设 Docker 已经在缓存中找到了该指令对应的镜像层（缓存命中），并且假设这个镜像层的 ID 是 AAA。</p>
<p>下一条指令会复制一些代码到镜像中（COPY . /src）。因为上一条指令命中了缓存，Docker 会继续查找是否有一个缓存的镜像层也是基于 AAA 层并执行了 COPY . /src 命令。</p>
<p>如果有，Docker 会链接到这个缓存的镜像层并继续执行后续指令；如果没有，则构建镜像层，并对后续的构建操作设置缓存无效。</p>
<p>假设 Docker 已经有一个对应该指令的缓存镜像层（缓存命中），并且假设这个镜像层的 ID 是 BBB。</p>
<p>那么 Docker 将继续执行 Dockerfile 中剩余的指令。</p>
<p>理解以下几点很重要。</p>
<p>首先，<strong>一旦有指令在缓存中未命中（没有该指令对应的镜像层），则后续的整个构建过程将不再使用缓存</strong>。</p>
<p>在编写 Dockerfile 时须特别注意这一点，<strong>尽量将易于发生变化的指令置于 Dockerfile 文件的后方执行。</strong></p>
<p>这意味着缓存未命中的情况将直到构建的后期才会出现，从而构建过程能够尽量从缓存中获益。</p>
<p>通过对 <code>docker image build</code> 命令加入 --nocache=true 参数可以强制忽略对缓存的使用。</p>
<p>还有一点也很重要，那就是 COPY 和 ADD 指令会检查复制到镜像中的内容自上一次构建之后是否发生了变化。</p>
<p>例如，有可能 Dockerfile 中的 COPY . /src 指令没有发生变化，但是被复制的目录中的内容已经发生变化了。</p>
<p>为了应对这一问题，Docker 会计算每一个被复制文件的 Checksum 值，并与缓存镜像层中同一文件的 checksum 进行对比。如果不匹配，那么就认为缓存无效并构建新的镜像层。</p>
<h3 id="合并镜像"><a class="header" href="#合并镜像">合并镜像</a></h3>
<p>合并镜像并非一个最佳实践，因为这种方式利弊参半。</p>
<p>总体来说，Docker 会遵循正常的方式构建镜像，但之后会增加一个额外的步骤，将所有的内容合并到一个镜像层中。</p>
<p>当镜像中层数太多时，合并是一个不错的优化方式。例如，当创建一个新的基础镜像，以便基于它来构建其他镜像的时候，这个基础镜像就最好被合并为一层。</p>
<p>缺点是，合并的镜像将无法共享镜像层。这会导致存储空间的低效利用，而且 push 和 pull 操作的镜像体积更大。</p>
<p>执行 <code>docker image build</code>命令时，可以通过增加 --squash 参数来创建一个合并的镜像。</p>
<p><img src="1.%E5%AE%B9%E5%99%A8_docker//images/docker-image-merge.gif" alt="" /></p>
<p>两个镜像的内容是完全一样的，区别在于是否进行了合并。在使用 <code>docker image push</code> 命令发送镜像到 Docker Hub 时，合并的镜像需要发送全部字节，而不合并的镜像只需要发送不同的镜像层即可。</p>
<h3 id="使用-no-install-recommends"><a class="header" href="#使用-no-install-recommends">使用 no-install-recommends</a></h3>
<p>在构建 Linux 镜像时，若使用的是 APT 包管理器，则应该在执行 apt-get install 命令时增加 no-install-recommends 参数。</p>
<p>这能够确保 APT 仅安装核心依赖（Depends 中定义）包，而不是推荐和建议的包。这样能够显著减少不必要包的下载数量。</p>
<h3 id="不要安装-msi-包windows"><a class="header" href="#不要安装-msi-包windows">不要安装 MSI 包（Windows）</a></h3>
<p>在构建 Windows 镜像时，尽量避免使用 MSI 包管理器。因其对空间的利用率不高，会大幅增加镜像的体积。</p>
<h3 id="dockerfile简介"><a class="header" href="#dockerfile简介">Dockerfile简介</a></h3>
<p>Dockerfile 由一行行命令语句组成，并支持以 # 开头的注释行。例如：</p>
<pre><code class="language-dockerfile"># Test web-app to use with Pluralsight courses and Docker Deep Dive book
# Linux x64
FROM alpine

LABEL maintainer=&quot;nigelpoulton@hotmail.com&quot;

# Install Node and NPM
RUN apk add --update nodejs nodejs-npm

# Copy app to /src
COPY . /src

WORKDIR /src

# Install dependencies
RUN  npm install

EXPOSE 8080

ENTRYPOINT [&quot;node&quot;, &quot;./app.js&quot;]
</code></pre>
<p>使用 -t 参数为镜像打标签，使用 -f 参数指定 Dockerfile 的路径和名称，使用 -f 参数可以指定位于任意路径下的任意名称的 Dockerfile。</p>
<p>构建上下文是指应用文件存放的位置，可能是本地 Docker 主机上的一个目录或一个远程的 Git 库。</p>
<p>Dockerfile 中的 FROM 指令用于指定要构建的镜像的基础镜像。它通常是 Dockerfile 中的第一条指令。</p>
<p>Dockerfile 中的 RUN 指令用于在镜像中执行命令，这会创建新的镜像层。每个 RUN 指令创建一个新的镜像层。</p>
<p>Dockerfile 中的 COPY 指令用于将文件作为一个新的层添加到镜像中。通常使用 COPY 指令将应用代码赋值到镜像中。</p>
<p>Dockerfile 中的 EXPOSE 指令用于记录应用所使用的网络端口。</p>
<p>Dockerfile 中的 ENTRYPOINT 指令用于指定镜像以容器方式启动后默认运行的程序。</p>
<p>其他的 Dockerfile 指令还有 LABEL、ENV、ONBUILD、HEALTHCHECK、CMD 等。</p>
<p>{% endraw %}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基本结构"><a class="header" href="#基本结构">基本结构</a></h1>
<p>Dockerfile 由一行行命令语句组成，并且支持以 <code>#</code> 开头的注释行。</p>
<p>一般的，Dockerfile 分为四部分：</p>
<ul>
<li>
<p>基础镜像信息</p>
</li>
<li>
<p>维护者信息</p>
</li>
<li>
<p>镜像操作指令</p>
</li>
<li>
<p>容器启动时执行指令。</p>
</li>
</ul>
<p>例如：</p>
<pre><code class="language-dockerfile"># This dockerfile uses the ubuntu image
# VERSION 2 - EDITION 1
# Author: docker_user
# Command format: Instruction [arguments / command] ..

# Base image to use, this must be set as the first line
FROM ubuntu

# Maintainer: docker_user &lt;docker_user at email.com&gt; (@docker_user)
MAINTAINER docker_user docker_user@email.com

# Commands to update the image
RUN echo &quot;deb http://archive.ubuntu.com/ubuntu/ raring main universe&quot; &gt;&gt; /etc/apt/sources.list
RUN apt-get update &amp;&amp; apt-get install -y nginx
RUN echo &quot;\ndaemon off;&quot; &gt;&gt; /etc/nginx/nginx.conf

# Commands when creating a new container
CMD /usr/sbin/nginx
</code></pre>
<h1 id="指令"><a class="header" href="#指令">指令</a></h1>
<p>指令的一般格式为 <code>INSTRUCTION arguments</code>，指令包括 <code>FROM</code>、<code>MAINTAINER</code>、<code>RUN</code> 等。</p>
<h2 id="from"><a class="header" href="#from">FROM</a></h2>
<p><strong>语法</strong></p>
<p><code>FROM &lt;image&gt;</code>或<code>FROM &lt;image&gt;:&lt;tag&gt;</code>。</p>
<h2 id="maintainer"><a class="header" href="#maintainer">MAINTAINER</a></h2>
<p>MAINTAINER <name></p>
<h2 id="run"><a class="header" href="#run">RUN</a></h2>
<p><code>RUN &lt;command&gt;</code> 或 <code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code></p>
<p>前者将在 shell 终端中运行命令，即 <code>/bin/sh -c</code>；后者则使用 <code>exec</code> 执行。指定使用其它终端可以通过第二种方式实现，例如 <code>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</code>。</p>
<p>每条 <code>RUN</code> 指令将在当前镜像基础上执行指定命令，并提交为新的镜像。当命令较长时可以使用 <code>\</code> 来换行。</p>
<h2 id="cmd"><a class="header" href="#cmd">CMD</a></h2>
<p>支持三种格式</p>
<ul>
<li><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> 使用 <code>exec</code> 执行，推荐方式；</li>
<li><code>CMD command param1 param2</code> 在 <code>/bin/sh</code> 中执行，提供给需要交互的应用；</li>
<li><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code> 提供给 <code>ENTRYPOINT</code> 的默认参数；</li>
</ul>
<p>指定启动容器时执行的命令，每个 Dockerfile 只能有一条 <code>CMD</code> 命令。如果指定了多条命令，只有最后一条会被执行。</p>
<p>如果用户启动容器时候指定了运行的命令，则会覆盖掉 <code>CMD</code> 指定的命令。</p>
<h2 id="expose"><a class="header" href="#expose">EXPOSE</a></h2>
<p>格式为 <code>EXPOSE &lt;port&gt; [&lt;port&gt;...]</code>。</p>
<p>告诉 Docker 服务端容器暴露的端口号，供互联系统使用。在启动容器时需要通过 -P，Docker 主机会自动分配一个端口转发到指定的端口。</p>
<h2 id="env"><a class="header" href="#env">ENV</a></h2>
<p>格式为 <code>ENV &lt;key&gt; &lt;value&gt;</code>。 指定一个环境变量，会被后续 <code>RUN</code> 指令使用，并在容器运行时保持。</p>
<pre><code class="language-dockerfile">ENV PG_MAJOR 9.3
ENV PG_VERSION 9.3.4
RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …
ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH
</code></pre>
<h2 id="add"><a class="header" href="#add">ADD</a></h2>
<p>格式为 <code>ADD &lt;src&gt; &lt;dest&gt;</code>。</p>
<p>该命令将复制指定的 <code>&lt;src&gt;</code> 到容器中的 <code>&lt;dest&gt;</code>。 其中 <code>&lt;src&gt;</code> 可以是Dockerfile所在目录的一个相对路径；也可以是一个 URL；还可以是一个 tar 文件（自动解压为目录）。</p>
<h2 id="copy"><a class="header" href="#copy">COPY</a></h2>
<p>格式为 <code>COPY &lt;src&gt; &lt;dest&gt;</code>。</p>
<p>复制本地主机的 <code>&lt;src&gt;</code>（为 Dockerfile 所在目录的相对路径）到容器中的 <code>&lt;dest&gt;</code>。</p>
<p>当使用本地目录为源目录时，推荐使用 <code>COPY</code>。</p>
<h2 id="entrypoint"><a class="header" href="#entrypoint">ENTRYPOINT</a></h2>
<p>两种格式：</p>
<ul>
<li><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code></li>
<li><code>ENTRYPOINT command param1 param2</code>（shell中执行）。</li>
</ul>
<p>配置容器启动后执行的命令，并且不可被 <code>docker run</code> 提供的参数覆盖。</p>
<p>每个 Dockerfile 中只能有一个 <code>ENTRYPOINT</code>，当指定多个时，只有最后一个起效。</p>
<h2 id="volume"><a class="header" href="#volume">VOLUME</a></h2>
<p>格式为 <code>VOLUME [&quot;/data&quot;]</code>。</p>
<p>创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。</p>
<h2 id="user"><a class="header" href="#user">USER</a></h2>
<p>格式为 <code>USER daemon</code>。</p>
<p>指定运行容器时的用户名或 UID，后续的 <code>RUN</code> 也会使用指定用户。</p>
<p>当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户，例如：<code>RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</code>。要临时获取管理员权限可以使用 <code>gosu</code>，而不推荐 <code>sudo</code>。</p>
<h2 id="workdir"><a class="header" href="#workdir">WORKDIR</a></h2>
<p>格式为 <code>WORKDIR /path/to/workdir</code>。</p>
<p>为后续的 <code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code> 指令配置工作目录。</p>
<p>可以使用多个 <code>WORKDIR</code> 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如</p>
<pre><code>WORKDIR /a
WORKDIR b
WORKDIR c
RUN pwd
</code></pre>
<p>则最终路径为 <code>/a/b/c</code>。</p>
<h2 id="onbuild"><a class="header" href="#onbuild">ONBUILD</a></h2>
<p>格式为 <code>ONBUILD [INSTRUCTION]</code>。</p>
<p>配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。</p>
<p>例如，Dockerfile 使用如下的内容创建了镜像 <code>image-A</code>。</p>
<p>利用ONBUILD指令,实际上就是相当于创建一个模板镜像，后续可以根据该模板镜像创建特定的子镜像，需要在子镜像构建过程中执行的一些通用操作就可以在模板镜像对应的dockerfile文件中用ONBUILD指令指定。 从而减少dockerfile文件的重复内容编写。</p>
<pre><code>[...]
ONBUILD ADD . /app/src
ONBUILD RUN /usr/local/bin/python-build --dir /app/src
[...]
</code></pre>
<p>使用 <code>ONBUILD</code> 指令的镜像，推荐在标签中注明，例如 <code>ruby:1.9-onbuild</code>。</p>
<h2 id="命令总结"><a class="header" href="#命令总结">命令总结</a></h2>
<p><strong>对外</strong></p>
<ul>
<li>端口暴露</li>
<li>路径挂载</li>
</ul>
<p><strong>中间</strong></p>
<ul>
<li>环境变量</li>
<li>文件拷贝</li>
</ul>
<p><strong>对内</strong></p>
<ul>
<li>镜像操作</li>
<li>执行用户</li>
<li>工作目录</li>
<li>进程执行</li>
</ul>
<p>其他</p>
<ul>
<li><strong>维护者信息</strong></li>
<li><strong>模板镜像</strong></li>
</ul>
<h1 id="创建镜像"><a class="header" href="#创建镜像">创建镜像</a></h1>
<p><code>docker build [选项] 路径</code></p>
<pre><code>sudo docker build -t myrepo/myapp /tmp/test1/
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<p>Docker Swarm 是 Docker 的集群管理工具。</p>
<p>支持的工具包括但不限于以下各项：</p>
<ul>
<li>Dokku</li>
<li>Docker Compose</li>
<li>Docker Machine</li>
<li>Jenkins</li>
</ul>
<p>swarm 集群由管理节点（manager）和工作节点（work node）构成。</p>
<ul>
<li><strong>swarm mananger</strong>：负责整个集群的管理工作包括集群配置、服务管理等所有跟集群有关的工作。</li>
<li><strong>work node</strong>：即图中的 available node，主要负责运行相应的服务来执行任务（task）。</li>
</ul>
<p>Swarm 的配置和状态信息保存在一套位于所有管理节点上的分布式 etcd 数据库中。该数据库运行于内存中，并保持数据的最新状态。关于该数据库最棒的是，它几乎不需要任何配置，作为 Swarm 的一部分被安装，无须管理。</p>
<h1 id="集群搭建"><a class="header" href="#集群搭建">集群搭建</a></h1>
<pre><code class="language-sh"># 会将其切换到 Swarm 模式
docker swarm init

# docker swarm init会通知 Docker 来初始化一个新的 Swarm，并将自身设置为第一个管理节点。同时也会使该节点开启 Swarm 模式。
$ docker swarm init \
--advertise-addr 10.0.0.1:2377 \
--listen-addr 10.0.0.1:2377
</code></pre>
<p><strong>--advertise-addr</strong> 指定其他节点用来连接到当前管理节点的 IP 和端口。这一属性是可选的，当节点上有多个 IP 时，可以用于指定使用哪个IP。此外，还可以用于指定一个节点上没有的 IP，比如一个负载均衡的 IP。</p>
<p><strong>--listen-addr</strong> 指定用于承载 Swarm 流量的 IP 和端口。其设置通常与 --advertise-addr 相匹配，但是当节点上有多个 IP 的时候，可用于指定具体某个 IP。并且，如果 --advertise-addr 设置了一个远程 IP 地址（如负载均衡的IP地址），该属性也是需要设置的。建议执行命令时总是使用这两个属性来指定具体 IP 和端口。</p>
<p>Swarm 模式下的操作默认运行于 2337 端口。虽然它是可配置的，但 2377/tcp 是用于客户端与 Swarm 进行安全（HTTPS）通信的约定俗成的端口配置。</p>
<p><strong>添加工作结点</strong></p>
<pre><code class="language-sh">docker swarm join --token SWMTKN-1-1h6l8jcv1k6dxwd79tfel7tj3c9q94y9eau875odx56ghje385-4hlef30rwhix3mfruw50h9mpm 192.168.1.73:2377
</code></pre>
<p><strong>添加管理结点</strong></p>
<pre><code>docker swarm join-token manager
</code></pre>
<h1 id="swarm-管理器高可用性ha"><a class="header" href="#swarm-管理器高可用性ha">Swarm 管理器高可用性（HA）</a></h1>
<p>Swarm 的管理节点内置有对 HA 的支持。这意味着，即使一个或多个节点发生故障，剩余管理节点也会继续保证 Swarm 的运转。</p>
<p>从技术上来说，Swarm 实现了一种主从方式的多管理节点的 HA。这意味着，即使你可能有多个管理节点，也总是仅有一个节点处于活动状态。</p>
<p>通常处于活动状态的管理节点被称为“主节点”（leader），而主节点也是唯一一个会对 Swarm 发送控制命令的节点。也就是说，只有主节点才会变更配置，或发送任务到工作节点。如果一个备用（非活动）管理节点接收到了 Swarm 命令，则它会将其转发给主节点。</p>
<p>关于 HA，有以下两条最佳实践原则。</p>
<ul>
<li>部署奇数个管理节点。</li>
<li>不要部署太多管理节点（建议 3 个或 5 个）。</li>
</ul>
<h1 id="docker-swarm服务的部署及相关操作"><a class="header" href="#docker-swarm服务的部署及相关操作">Docker Swarm服务的部署及相关操作</a></h1>
<h2 id="创建集群中的服务"><a class="header" href="#创建集群中的服务">创建集群中的服务</a></h2>
<p>使用 <code>docker service create</code> 命令创建一个新的服务。</p>
<pre><code>docker service create --name web-fe \
-p 8080:8080 \
--replicas 5 \
nigelpoulton/pluralsight-docker-ci
</code></pre>
<ul>
<li>
<p><code>docker service creale</code> 命令告知 Docker 正在声明一个新服务，</p>
</li>
<li>
<p>并传递 --name 参数将其命名为 web-fe。</p>
</li>
<li>
<p>将每个节点上的 8080 端口映射到服务副本内部的 8080 端口。</p>
</li>
<li>
<p>接下来，使用 --replicas 参数告知 Docker 应该总是有 5 个此服务的副本。</p>
</li>
<li>
<p>最后，告知 Docker 哪个镜像用于副本，重要的是，要了解所有的服务副本使用相同的镜像和配置。</p>
</li>
</ul>
<p>敲击回车键之后，主管理节点会在 Swarm 中实例化 5 个副本，管理节点也会作为工作节点运行。相关各工作节点或管理节点会拉取镜像，然后启动一个运行在 8080 端口上的容器。</p>
<p><strong>轮询监控</strong></p>
<p>所有的服务都会被 Swarm 持续监控，Swarm 会在后台进行轮训检查（Reconciliation Loop），来持续比较服务的实际状态和期望状态是否一致。如果一致，则无须任何额外操作；如果不一致，Swarm 会使其一致。换句话说，Swarm 会一直确保实际状态能够满足期望状态的要求。</p>
<p>假如运行有 web-fe 副本的某个工作节点宕机了，则 web-fe 的实际状态从 5 个副本降为 4 个，从而不能满足期望状态的要求。Docker 变回启动一个新的 web-fe 副本来使实际状态与期望状态保持一致。这一特性功能强大，使得服务在面对节点宕机等问题时具有自愈能力。</p>
<h2 id="服务命令"><a class="header" href="#服务命令">服务命令</a></h2>
<p><strong>查看服务</strong></p>
<pre><code class="language-sh"># 只能在管理结点运行
docker service ls
</code></pre>
<p><strong>查看实际进程</strong></p>
<pre><code class="language-sh"># 只能在管理结点运行
docker service ps service_name
</code></pre>
<p><strong>查看详细命令</strong></p>
<pre><code class="language-sh">docker service inspect
</code></pre>
<h2 id="副本服务-vs-全局服务"><a class="header" href="#副本服务-vs-全局服务">副本服务 vs 全局服务</a></h2>
<p>服务的默认复制模式（Replication Mode）是副本模式（replicated）。</p>
<p>这种模式会部署期望数量的服务副本，并尽可能均匀地将各个副本分布在整个集群中。</p>
<p>另一种模式是全局模式（global），在这种模式下，每个节点上仅运行一个副本。可以通过给 <code>docker service create</code> 命令传递 --mode global 参数来部署一个全局服务。</p>
<h2 id="服务的扩缩容"><a class="header" href="#服务的扩缩容">服务的扩缩容</a></h2>
<pre><code class="language-sh">docker service scale web-fe=10
</code></pre>
<h2 id="删除服务"><a class="header" href="#删除服务">删除服务</a></h2>
<pre><code class="language-sh">docker service rm
</code></pre>
<h2 id="滚动升级"><a class="header" href="#滚动升级">滚动升级</a></h2>
<pre><code class="language-sh"># 同时升级 两台
--update-parallelism 2 \
# 20s 延迟
--update-delay 20s 
</code></pre>
<pre><code class="language-sh">docker service update
</code></pre>
<h1 id="docker-swarm服务日志及相关配置"><a class="header" href="#docker-swarm服务日志及相关配置">Docker Swarm服务日志及相关配置</a></h1>
<p><strong>日志驱动</strong></p>
<p><a href="http://c.biancheng.net/docker/">Docker</a> Swarm 服务的日志可以通过执行 <code>docker service logs</code> 命令来查看，然而并非所有的日志驱动（Logging Driver）都支持该命令。</p>
<p><strong>默认日志驱动</strong></p>
<p>Docker 节点默认的配置是，服务使用 json-file 日志驱动，其他的驱动还有 journald（仅用于运行有 systemd 的 Linux 主机）、syslog、splunk 和 gelf。</p>
<p>json-file 和 journald 是较容易配置的，二者都可用于 <code>docker service logs</code> 命令。</p>
<pre><code class="language-sh">docker service logs &lt;service-name&gt;
</code></pre>
<p>如下是在 daemon.json 配置文件中定义使用 syslog 作为日志驱动的示例。</p>
<pre><code>{
  &quot;log-driver&quot;: &quot;syslog&quot;
}
</code></pre>
<p>通过在执行 <code>docker service create</code> 命令时传入 --logdriver 和 --log-opts 参数可以强制某服务使用一个不同的日志驱动，这会覆盖 daemon.json 中的配置。</p>
<p>服务日志能够正常工作的前提是，容器内的应用程序运行于 PID 为 1 的进程，并且将日志发送给 STDOUT，错误信息发送给 STDERR。日志驱动会将这些日志转发到其配置指定的位置。</p>
<h1 id="swarm常用命令"><a class="header" href="#swarm常用命令">SWARM常用命令</a></h1>
<table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody>
<tr><td>docker swarm init</td><td>用于创建一个新的 Swarm。执行该命令的节点会成为第一个管理节点，并且会切换到 Swarm 模式。</td></tr>
<tr><td>docker swarm join-token</td><td>用于查询加入管理节点和工作节点到现有 Swarm 时所使用的命令和 Token。 要获取新增管理节点的命令，请执行 docker swarm join-token manager 命令； 要获取新增工作节点的命令，请执行 docker swarm join-token worker 命令。</td></tr>
<tr><td>docker node ls</td><td>用于列出 Swarm 中的所有节点及相关信息，包括哪些是管理节点、哪个是主管理节点。</td></tr>
<tr><td>docker service create</td><td>用于创建一个新服务。</td></tr>
<tr><td>docker service ls</td><td>用于列出 Swarm 中运行的服务，以及诸如服务状态、服务副本等基本信息。</td></tr>
<tr><td>docker service ps <service></td><td>该命令会给出更多关于某个服务副本的信息</td></tr>
<tr><td>docker service inspect</td><td>用于获取关于服务的详尽信息。附加 --pretty 参数可限制仅显示重要信息。</td></tr>
<tr><td>docker service scale</td><td>用于对服务副本个数进行增减。</td></tr>
<tr><td>docker service update</td><td>用于对运行中的服务的属性进行变更。</td></tr>
<tr><td>docker service logs</td><td>用于查看服务的日志。</td></tr>
<tr><td>docker service rm</td><td>用于从 Swarm 中删除某服务。该命令会在不做确认的情况下删除服务的所有副本，所以使用时应保持警惕。</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker-compose简介"><a class="header" href="#docker-compose简介">Docker-Compose简介</a></h1>
<p>Compose允许用户通过一个docker-compose.yml模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>
<p>Compose模板文件是一个定义服务、网络和卷的YAML文件</p>
<p>Compose模板文件默认路径是当前目录下的docker-compose.yml</p>
<p>Docker-Compose标准模板文件应该包含version、services、networks 三大部分，最关键的是services和networks两个部分。</p>
<p><strong>example</strong></p>
<pre><code class="language-yml">version: '2'
services:
  web:
    image: dockercloud/hello-world
    ports:
      - 8080
    networks:
      - front-tier
      - back-tier

  redis:
    image: redis
    links:
      - web
    networks:
      - back-tier

  lb:
    image: dockercloud/haproxy
    ports:
      - 80:80
    links:
      - web
    networks:
      - front-tier
      - back-tier
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock 

networks:
  front-tier:
    driver: bridge
  back-tier:
    driver: bridge
</code></pre>
<p>Compose目前有三个版本分别为Version 1，Version 2，Version 3，Compose区分Version 1和Version 2（Compose 1.6.0+，Docker Engine 1.10.0+）。Version 2支持更多的指令。Version 1将来会被弃用。</p>
<h1 id="指令-1"><a class="header" href="#指令-1">指令</a></h1>
<h2 id="image"><a class="header" href="#image">image</a></h2>
<blockquote>
<p>image是指定服务的镜像名称或镜像ID。如果镜像在本地不存在，Compose将会尝试拉取镜像。</p>
</blockquote>
<pre><code>services: 
    web: 
        image: hello-world
        
</code></pre>
<h2 id="build"><a class="header" href="#build">build</a></h2>
<p>服务除了可以基于指定的镜像，还可以基于一份Dockerfile，在使用up启动时执行构建任务，构建标签是build，可以指定Dockerfile所在文件夹的路径。Compose将会利用Dockerfile自动构建镜像，然后使用镜像启动服务容器。</p>
<pre><code>build:
  context: ../
  dockerfile: path/of/Dockerfile
</code></pre>
<h2 id="context"><a class="header" href="#context">context</a></h2>
<p>context选项可以是Dockerfile的文件路径，也可以是到链接到git仓库的url，当提供的值是相对路径时，被解析为相对于撰写文件的路径，此目录也是发送到Docker守护进程的context</p>
<h2 id="dockerfile"><a class="header" href="#dockerfile">dockerfile</a></h2>
<p>使用dockerfile文件来构建，必须指定构建路径</p>
<pre><code>build:
  context: .
  dockerfile: Dockerfile-alternate
</code></pre>
<h2 id="command"><a class="header" href="#command">command</a></h2>
<pre><code class="language-sh">#使用command可以覆盖容器启动后默认执行的命令。
command: bundle exec thin -p 3000
</code></pre>
<h2 id="container_name"><a class="header" href="#container_name">container_name</a></h2>
<p>Compose的容器名称格式是：&lt;项目名称&gt;&lt;服务名称&gt;&lt;序号&gt;
可以自定义项目名称、服务名称，但如果想完全控制容器的命名，可以使用标签指定：
<code>container_name: app</code></p>
<h2 id="depends_on"><a class="header" href="#depends_on">depends_on</a></h2>
<p>在使用Compose时，最大的好处就是少打启动命令，但一般项目容器启动的顺序是有要求的，如果直接从上到下启动容器，必然会因为容器依赖问题而启动失败。例如在没启动数据库容器的时候启动应用容器，应用容器会因为找不到数据库而退出。depends_on标签用于解决容器的依赖、启动先后的问题。</p>
<pre><code>version: '2'
services:
  web:
    build: .
    depends_on:
      - db
      - redis
  redis:
    image: redis
  db:
    image: postgres
</code></pre>
<p>上述YAML文件定义的容器会先启动redis和db两个服务，最后才启动web 服务。</p>
<h2 id="pid"><a class="header" href="#pid">pid</a></h2>
<p><code>pid: &quot;host&quot;</code>
将PID模式设置为主机PID模式，跟主机系统共享进程命名空间。容器使用pid标签将能够访问和操纵其他容器和宿主机的名称空间。</p>
<h2 id="ports"><a class="header" href="#ports">ports</a></h2>
<p>ports用于映射端口的标签。
使用HOST:CONTAINER格式或者只是指定容器的端口，宿主机会随机映射端口。</p>
<pre><code>ports:
 - &quot;3000&quot;
 - &quot;8000:8000&quot;
 - &quot;49100:22&quot;
 - &quot;127.0.0.1:8001:8001&quot;
</code></pre>
<p>当使用HOST:CONTAINER格式来映射端口时，如果使用的容器端口小于60可能会得到错误得结果，因为YAML将会解析xx:yy这种数字格式为60进制。所以建议采用字符串格式。</p>
<h2 id="extra_hosts"><a class="header" href="#extra_hosts">extra_hosts	</a></h2>
<p>添加主机名的标签，会在/etc/hosts文件中添加一些记录。</p>
<pre><code>extra_hosts:
 - &quot;somehost:162.242.195.82&quot;
 - &quot;otherhost:50.31.209.229&quot;
</code></pre>
<p>启动后查看容器内部hosts：</p>
<pre><code>162.242.195.82  somehost
50.31.209.229   otherhost
</code></pre>
<h2 id="volumes"><a class="header" href="#volumes">volumes</a></h2>
<p>挂载一个目录或者一个已存在的数据卷容器，可以直接使用 [HOST:CONTAINER]格式，或者使用[HOST:CONTAINER:ro]格式，后者对于容器来说，数据卷是只读的，可以有效保护宿主机的文件系统。
Compose的数据卷指定路径可以是相对路径，使用 . 或者 .. 来指定相对目录。
数据卷的格式可以是下面多种形式：</p>
<pre><code>volumes:
  // 只是指定一个路径，Docker 会自动在创建一个数据卷（这个路径是容器内部的）。
  - /var/lib/mysql
  // 使用绝对路径挂载数据卷
  - /opt/data:/var/lib/mysql
  // 以 Compose 配置文件为中心的相对路径作为数据卷挂载到容器。
  - ./cache:/tmp/cache
  // 使用用户的相对路径（~/ 表示的目录是 /home/&lt;用户目录&gt;/ 或者 /root/）。
  - ~/configs:/etc/configs/:ro
  // 已经存在的命名的数据卷。
  - datavolume:/var/lib/mysql
</code></pre>
<p>如果不使用宿主机的路径，可以指定一个volume_driver。
<code>volume_driver: mydriver</code></p>
<h2 id="volumes_from"><a class="header" href="#volumes_from">volumes_from</a></h2>
<p>从另一个服务或容器挂载其数据卷：</p>
<pre><code>volumes_from:
   - service_name    
     - container_name
</code></pre>
<h2 id="dns"><a class="header" href="#dns">dns</a></h2>
<p>自定义DNS服务器。可以是一个值，也可以是一个列表。</p>
<pre><code>dns：8.8.8.8
dns：
    - 8.8.8.8    
      - 9.9.9.9
</code></pre>
<h2 id="dns_search"><a class="header" href="#dns_search">dns_search</a></h2>
<p>配置DNS搜索域。可以是一个值，也可以是一个列表。</p>
<pre><code>dns_search：example.com
dns_search：
    - domain1.example.com
    - domain2.example.com
</code></pre>
<h2 id="entrypoint-1"><a class="header" href="#entrypoint-1">entrypoint</a></h2>
<p>在Dockerfile中有一个指令叫做ENTRYPOINT指令，用于指定接入点。
在docker-compose.yml中可以定义接入点，覆盖Dockerfile中的定义：
<code>entrypoint: /code/entrypoint.sh</code></p>
<h2 id="env_file"><a class="header" href="#env_file">env_file</a></h2>
<p>在docker-compose.yml中可以定义一个专门存放变量的文件。
如果通过docker-compose -f FILE指定配置文件，则env_file中路径会使用配置文件路径。
如果有变量名称与environment指令冲突，则以后者为准。格式如下：
<code>env_file: .env</code></p>
<p>或者根据docker-compose.yml设置多个：</p>
<pre><code>env_file:
  - ./common.env
  - ./apps/web.env
  - /opt/secrets.env
</code></pre>
<p>如果在配置文件中有build操作，变量并不会进入构建过程中。</p>
<h2 id="expose-1"><a class="header" href="#expose-1">expose</a></h2>
<p>暴露端口，但不映射到宿主机，只允许能被连接的服务访问。仅可以指定内部端口为参数，如下所示：</p>
<pre><code>expose:
    - &quot;3000&quot;
    - &quot;8000&quot;
</code></pre>
<h2 id="extends"><a class="header" href="#extends">extends</a></h2>
<p>例如，对于webapp服务定义了一个基础模板文件为common.yml：</p>
<pre><code># common.yml
webapp:
    build: ./webapp
    environment:
        - DEBUG=false
        - SEND_EMAILS=false
</code></pre>
<p>再编写一个新的development.yml文件，使用common.yml中的webapp服务进行扩展：</p>
<pre><code># development.yml
web:
    extends:
        file: common.yml
        service: webapp
    ports:
        - &quot;8000:8000&quot;
    links:
        - db
    environment:
        - DEBUG=true
db:
    image: mysql
</code></pre>
<p>后者会自动继承common.yml中的webapp服务及环境变量定义。
extends限制如下：
A、要避免出现循环依赖
B、extends不会继承links和volumes_from中定义的容器和数据卷资源
推荐在基础模板中只定义一些可以共享的镜像和环境变量，在扩展模板中具体指定应用变量、链接、数据卷等信息</p>
<h2 id="labels"><a class="header" href="#labels">labels</a></h2>
<p>为容器添加Docker元数据（metadata）信息。例如，可以为容器添加辅助说明信息：</p>
<pre><code>labels：
    com.startupteam.description: &quot;webapp for a strtup team&quot;
</code></pre>
<h2 id="links"><a class="header" href="#links">links</a></h2>
<p>链接到其它服务中的容器。使用服务名称（同时作为别名），或者“服务名称:服务别名”（如 SERVICE:ALIAS），例如：</p>
<pre><code>links:
    - db
    - db:database
    - redis
</code></pre>
<p>使用别名将会自动在服务容器中的/etc/hosts里创建。例如：</p>
<pre><code>172.17.2.186  db
172.17.2.186  database
172.17.2.187  redis
</code></pre>
<h2 id="log_driver"><a class="header" href="#log_driver">log_driver</a></h2>
<p>指定日志驱动类型。目前支持三种日志驱动类型：</p>
<pre><code>log_driver: &quot;json-file&quot;
log_driver: &quot;syslog&quot;
log_driver: &quot;none&quot;
</code></pre>
<h2 id="net"><a class="header" href="#net">net</a></h2>
<p>设置网络模式。</p>
<pre><code>net: &quot;bridge&quot;
net: &quot;none&quot;
net: &quot;host&quot;
</code></pre>
<h2 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h2>
<p>环境变量可以用来配置Docker-Compose的行为。
<strong>COMPOSE_PROJECT_NAME</strong>
设置通过Compose启动的每一个容器前添加的项目名称，默认是当前工作目录的名字。
<strong>COMPOSE_FILE</strong>
设置docker-compose.yml模板文件的路径。默认路径是当前工作目录。
<strong>DOCKER_HOST</strong>
设置Docker daemon的地址。默认使用unix:///var/run/docker.sock。 DOCKER_TLS_VERIFY
如果设置不为空，则与Docker daemon交互通过TLS进行。
<strong>DOCKER_CERT_PATH</strong>
配置TLS通信所需要的验证(ca.pem、cert.pem 和 key.pem)文件的路径，默认是 ~/.docker 。</p>
<h1 id="命令行"><a class="header" href="#命令行">命令行</a></h1>
<h2 id="docker-compose命令格式"><a class="header" href="#docker-compose命令格式">Docker-Compose命令格式</a></h2>
<pre><code>docker-compose [-f &lt;arg&gt;...] [options] [COMMAND] [ARGS...]
</code></pre>
<p>命令选项如下：
-f，–file FILE指定Compose模板文件，默认为docker-compose.yml，可以多次指定。
-p，–project-name NAME指定项目名称，默认将使用所在目录名称作为项目名。
-x-network-driver 使用Docker的可拔插网络后端特性（需要Docker 1.9+版本）
-x-network-driver DRIVER指定网络后端的驱动，默认为bridge（需要Docker 1.9+版本）
-verbose输出更多调试信息
-v，–version打印版本并退出</p>
<h2 id="docker-compose-up"><a class="header" href="#docker-compose-up">docker-compose up</a></h2>
<pre><code>docker-compose up [options] [--scale SERVICE=NUM...] [SERVICE...]
</code></pre>
<pre><code>选项包括：
-d 在后台运行服务容器
–no-color 不使用颜色来区分不同的服务的控制输出
–no-deps 不启动服务所链接的容器
–force-recreate 强制重新创建容器，不能与–no-recreate同时使用
–no-recreate 如果容器已经存在，则不重新创建，不能与–force-recreate同时使用
–no-build 不自动构建缺失的服务镜像
–build 在启动容器前构建服务镜像
–abort-on-container-exit 停止所有容器，如果任何一个容器被停止，不能与-d同时使用
-t, –timeout TIMEOUT 停止容器时候的超时（默认为10秒）
–remove-orphans 删除服务中没有在compose文件中定义的容器
–scale SERVICE=NUM 设置服务运行容器的个数，将覆盖在compose中通过scale指定的参数
`docker-compose up`
启动所有服务
`docker-compose up -d`
在后台所有启动服务
-f 指定使用的Compose模板文件，默认为docker-compose.yml，可以多次指定。
`docker-compose -f docker-compose.yml up -d`
</code></pre>
<h2 id="docker-compose-ps"><a class="header" href="#docker-compose-ps">docker-compose ps</a></h2>
<pre><code>`docker-compose ps [options] [SERVICE...]`
`docker-compose ps`
列出项目中目前的所有容器
</code></pre>
<h2 id="docker-compose-stop"><a class="header" href="#docker-compose-stop">docker-compose stop</a></h2>
<pre><code class="language-sh">docker-compose stop [options] [SERVICE...]
选项包括：
-t, –timeout TIMEOUT 停止容器时候的超时（默认为10秒）
docker-compose stop
停止正在运行的容器，可以通过docker-compose start 再次启动
</code></pre>
<h2 id="docker-compose--h"><a class="header" href="#docker-compose--h">docker-compose -h</a></h2>
<p><code>docker-compose -h</code>
查看帮助</p>
<h2 id="docker-compose-down"><a class="header" href="#docker-compose-down">docker-compose down</a></h2>
<p>停止和删除容器、网络、卷、镜像。
选项包括：
–rmi type，删除镜像，类型必须是：all，删除compose文件中定义的所有镜像；local，删除镜像名为空的镜像
-v, –volumes，删除已经在compose文件中定义的和匿名的附在容器上的数据卷
–remove-orphans，删除服务中没有在compose中定义的容器
<code>docker-compose down</code>
停用移除所有容器以及网络相关</p>
<h2 id="docker-compose-logs"><a class="header" href="#docker-compose-logs">docker-compose logs</a></h2>
<p><code>docker-compose logs [options] [SERVICE...]</code>
查看服务容器的输出。默认情况下，docker-compose将对不同的服务输出使用不同的颜色来区分。可以通过–no-color来关闭颜色。
<code>docker-compose logs</code>
查看服务容器的输出</p>
<h2 id="docker-compose-build"><a class="header" href="#docker-compose-build">docker-compose build</a></h2>
<p><code>docker-compose build [options] [--build-arg key=val...] [SERVICE...]</code>
构建（重新构建）项目中的服务容器。
选项包括：
–compress 通过gzip压缩构建上下环境
–force-rm 删除构建过程中的临时容器
–no-cache 构建镜像过程中不使用缓存
–pull 始终尝试通过拉取操作来获取更新版本的镜像
-m, –memory MEM为构建的容器设置内存大小
–build-arg key=val为服务设置build-time变量
服务容器一旦构建后，将会带上一个标记名。可以随时在项目目录下运行docker-compose build来重新构建服务</p>
<h2 id="docker-compose-pull"><a class="header" href="#docker-compose-pull">docker-compose pull</a></h2>
<p><code>docker-compose pull [options] [SERVICE...]</code>
拉取服务依赖的镜像。
选项包括：
–ignore-pull-failures，忽略拉取镜像过程中的错误
–parallel，多个镜像同时拉取
–quiet，拉取镜像过程中不打印进度信息
<code>docker-compose pull</code>
拉取服务依赖的镜像</p>
<h2 id="docker-compose-restart"><a class="header" href="#docker-compose-restart">docker-compose restart</a></h2>
<p><code>docker-compose restart [options] [SERVICE...]</code>
重启项目中的服务。
选项包括：
-t, –timeout TIMEOUT，指定重启前停止容器的超时（默认为10秒）
<code>docker-compose restart</code>
重启项目中的服务</p>
<h2 id="docker-compose-rm"><a class="header" href="#docker-compose-rm">docker-compose rm</a></h2>
<p><code>docker-compose rm [options] [SERVICE...]</code>
删除所有（停止状态的）服务容器。
选项包括：
–f, –force，强制直接删除，包括非停止状态的容器
-v，删除容器所挂载的数据卷
<code>docker-compose rm</code>
删除所有（停止状态的）服务容器。推荐先执行docker-compose stop命令来停止容器。</p>
<h2 id="docker-compose-start"><a class="header" href="#docker-compose-start">docker-compose start</a></h2>
<p><code>docker-compose start [SERVICE...]</code>
<code>docker-compose start</code>
启动已经存在的服务容器。</p>
<h2 id="docker-compose-run"><a class="header" href="#docker-compose-run">docker-compose run</a></h2>
<p><code>docker-compose run [options] [-v VOLUME...] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code>
在指定服务上执行一个命令。
<code>docker-compose run ubuntu ping www.baidu.com</code>
在指定容器上执行一个ping命令。</p>
<h2 id="docker-compose-scale"><a class="header" href="#docker-compose-scale">docker-compose scale</a></h2>
<p><code>docker-compose scale web=3 db=2</code>
设置指定服务运行的容器个数。通过service=num的参数来设置数量</p>
<h2 id="docker-compose-pause"><a class="header" href="#docker-compose-pause">docker-compose pause</a></h2>
<p><code>docker-compose pause [SERVICE...]</code>
暂停一个服务容器</p>
<h2 id="docker-compose-kill"><a class="header" href="#docker-compose-kill">docker-compose kill</a></h2>
<pre><code>docker-compose kill [options] [SERVICE...]`
通过发送SIGKILL信号来强制停止服务容器。 
支持通过-s参数来指定发送的信号，例如通过如下指令发送SIGINT信号：
`docker-compose kill -s SIGINT
</code></pre>
<h2 id="dokcer-compose-config"><a class="header" href="#dokcer-compose-config">dokcer-compose config</a></h2>
<p><code>docker-compose config [options]</code>
验证并查看compose文件配置。
选项包括：
–resolve-image-digests 将镜像标签标记为摘要
-q, –quiet 只验证配置，不输出。 当配置正确时，不输出任何内容，当文件配置错误，输出错误信息
–services 打印服务名，一行一个
–volumes 打印数据卷名，一行一个</p>
<h2 id="docker-compose-create"><a class="header" href="#docker-compose-create">docker-compose create</a></h2>
<p><code>docker-compose create [options] [SERVICE...]</code>
为服务创建容器。
选项包括：
–force-recreate：重新创建容器，即使配置和镜像没有改变，不兼容–no-recreate参数
–no-recreate：如果容器已经存在，不需要重新创建，不兼容–force-recreate参数
–no-build：不创建镜像，即使缺失
–build：创建容器前，生成镜像</p>
<h2 id="docker-compose-exec"><a class="header" href="#docker-compose-exec">docker-compose exec</a></h2>
<p><code>docker-compose exec [options] SERVICE COMMAND [ARGS...]</code>
选项包括：
-d 分离模式，后台运行命令。
–privileged 获取特权。
–user USER 指定运行的用户。
-T 禁用分配TTY，默认docker-compose exec分配TTY。
–index=index，当一个服务拥有多个容器时，可通过该参数登陆到该服务下的任何服务，例如：docker-compose exec –index=1 web /bin/bash ，web服务中包含多个容器</p>
<h2 id="docker-compose-port"><a class="header" href="#docker-compose-port">docker-compose port</a></h2>
<p><code>docker-compose port [options] SERVICE PRIVATE_PORT</code>
显示某个容器端口所映射的公共端口。
选项包括：
–protocol=proto，指定端口协议，TCP（默认值）或者UDP
–index=index，如果同意服务存在多个容器，指定命令对象容器的序号（默认为1）</p>
<h2 id="docker-compose-push"><a class="header" href="#docker-compose-push">docker-compose push</a></h2>
<p><code>docker-compose push [options] [SERVICE...]</code>
推送服务依的镜像。
选项包括：
–ignore-push-failures 忽略推送镜像过程中的错误</p>
<h2 id="docker-compose-show"><a class="header" href="#docker-compose-show">docker-compose show</a></h2>
<p><code>docker-compose stop [options] [SERVICE...]</code>
暂停</p>
<h2 id="docker-compose-unpause"><a class="header" href="#docker-compose-unpause">docker-compose unpause</a></h2>
<p><code>docker-compose unpause [SERVICE...]</code>
恢复处于暂停状态中的服务。</p>
<h2 id="docker-compose-version"><a class="header" href="#docker-compose-version">docker-compose version</a></h2>
<p><code>docker-compose version</code>
打印版本信息。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="端口放开"><a class="header" href="#端口放开">端口放开</a></h2>
<ul>
<li><strong>TCP port 2377</strong> for cluster management communications 用于集群管理通信</li>
<li><strong>TCP</strong> and <strong>UDP port 7946</strong> for communication among nodes  节点之间通信</li>
<li><strong>UDP port 4789</strong> for overlay network traffic  用于 overlay 网络 的流量通信</li>
<li>5000 端口 私有仓库访问端口</li>
</ul>
<pre><code>firewall-cmd --add-port=2377/tcp --permanent
firewall-cmd --add-port=7946/tcp --permanent
firewall-cmd --add-port=7946/udp --permanent
firewall-cmd --add-port=5000/tcp --permanent
firewall-cmd --add-port=443/tcp --permanent
firewall-cmd --reload
</code></pre>
<h1 id="集群管理命令"><a class="header" href="#集群管理命令">集群管理命令</a></h1>
<h2 id="初始化节点"><a class="header" href="#初始化节点">初始化节点</a></h2>
<pre><code class="language-sh"># 初始化为 管理节点	
docker swarm init
</code></pre>
<h2 id="以-工作节点加入到管理节点"><a class="header" href="#以-工作节点加入到管理节点">以 工作节点加入到管理节点</a></h2>
<pre><code class="language-sh"> docker swarm join \
    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \
    192.168.99.100:2377
</code></pre>
<h2 id="查看以工作节点加入到集群中的命令"><a class="header" href="#查看以工作节点加入到集群中的命令">查看以工作节点加入到集群中的命令</a></h2>
<pre><code class="language-sh">docker swarm join-token worker
</code></pre>
<h2 id="查看以管理节点加入到集群中的命令"><a class="header" href="#查看以管理节点加入到集群中的命令">查看以管理节点加入到集群中的命令</a></h2>
<pre><code class="language-sh">docker swarm join-token manager
</code></pre>
<h1 id="新建registry-私有仓库"><a class="header" href="#新建registry-私有仓库">新建Registry 私有仓库</a></h1>
<pre><code class="language-sh">docker service create  --constraint node.role==manager    --name registry --publish published=5000,target=5000 registry:2
</code></pre>
<h1 id="新建虚拟化服务"><a class="header" href="#新建虚拟化服务">新建虚拟化服务</a></h1>
<pre><code class="language-sh">docker pull dockersamples/visualizer:latest
docker service create \
--name=viz \
--publish=8081:8080/tcp \
--constraint=node.role==manager \
--mount=type=bind,src=/var/run/docker.sock,dst=/var/run/docker.sock \
dockersamples/visualizer:latest
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-volumes"><a class="header" href="#use-volumes">Use volumes</a></h1>
<blockquote>
<p>使用卷</p>
</blockquote>
<p>卷是持久化 Docker 容器生成和使用的数据的首选机制。
虽然绑定挂载依赖于主机的目录结构和操作系统，但卷完全由 Docker 管理。
与绑定安装相比，卷有几个优点：</p>
<ul>
<li>卷比绑定安装更容易备份或迁移。</li>
<li>您可以使用 Docker CLI 命令或 Docker API 管理卷。 </li>
<li>卷适用于 Linux 和 Windows 容器。</li>
<li>可以更安全地在多个容器之间共享卷</li>
<li>卷驱动程序允许您将卷存储在远程主机或云提供商上，以加密卷的内容或添加其他功能。</li>
<li>新卷的内容可以由容器预先填充</li>
<li>Volumes on Docker Desktop具有比来自 Mac 和 Windows 主机的绑定挂载更高的性能</li>
</ul>
<p>此外，与在容器的可写层中持久化数据相比，卷通常是更好的选择，因为卷不会增加使用它的容器的大小，并且卷的内容存在于给定容器的生命周期之外。</p>
<p><img src="1.%E5%AE%B9%E5%99%A8_docker/types-of-mounts-volume.png" alt="/images/types-of-mounts-volume.png" /></p>
<p>如果您的容器生成非持久状态数据，请考虑使用 <a href="https://docs.docker.com/storage/tmpfs/">tmpfs</a> 挂载以避免将数据永久存储在任何地方，并通过避免写入容器的可写层来提高容器的性能。
Volumes use <code>rprivate</code> bind propagation, and bind propagation is not configurable for volumes.</p>
<h1 id="choose-the--v-or---mount-flag"><a class="header" href="#choose-the--v-or---mount-flag">Choose the -v or --mount flag</a></h1>
<p>一般来说，--mount 更明确和详细。
最大的区别是 -v 语法将所有选项组合在一个字段中，而 --mount 语法将它们分开。
这是每个标志的语法比较。
如果需要指定卷驱动程序选项，则必须使用 --mount。</p>
<ul>
<li>
<p><code>v</code> or <code>--volume</code> ： 由三个字段组成，以冒号字符 (:) 分隔。字段必须按正确顺序排列，每个字段的含义并不是很明显。</p>
<ul>
<li>在命名卷的情况下，第一个字段是卷的名称，并且在给定的主机上是唯一的。对于匿名卷，第一个字段被省略。</li>
<li>第二个字段是文件或目录在容器中挂载的路径</li>
<li>第三个字段是可选的，是一个以逗号分隔的选项列表，例如 ro。</li>
</ul>
</li>
<li>
<p><code>--mount</code>：</p>
</li>
</ul>
<p>由多个键值对组成，以逗号分隔，每个键值对由一个 = 元组组成。 
--mount 语法比 -v 或 --volume 更冗长，但键的顺序并不重要，标志的值更容易理解。</p>
<ul>
<li><code>type</code> 挂载的类型， 可以是 bind、volume 或 tmpfs。This topic discusses volumes, so the type is always <code>volume</code>.</li>
<li><code>source</code> 挂载源 ：对于命名卷，这是卷的名称，对于匿名卷，此字段被省略。
可以指定为 source 或 src。</li>
<li><code>destination</code>  将文件或目录安装在容器中的路径作为其值。
可以指定为  destination、dst 或 target。</li>
<li><code>readonly</code>   if present, causes the bind mount to be <a href="https://docs.docker.com/storage/volumes/#use-a-read-only-volume">mounted into the container as read-only</a>.</li>
<li><code>volume-opt</code>  可以多次指定，它采用由选项名称及其值组成的键值对。</li>
</ul>
<p><strong>从外部 CSV 解析器转义值</strong></p>
<p>如果您的卷驱动程序接受逗号分隔列表作为选项，您必须从外部 CSV 解析器中转义该值。
要对 volume-opt 进行转义，请用双引号 (&quot;) 将其括起来，并用单引号 (') 将整个挂载参数括起来。</p>
<pre><code>$ docker service create \
--mount 
'type=volume,src=&lt;VOLUME-NAME&gt;,dst=&lt;CONTAINER-PATH&gt;,volume-driver=local,volume-opt=type=nfs,volume-opt=device=&lt;nfs-server&gt;:&lt;nfs-path&gt;,&quot;volume-opt=o=addr=&lt;nfs-address&gt;,vers=4,soft,timeo=180,bg,tcp,rw&quot;'
    --name myservice \
    &lt;IMAGE&gt;
</code></pre>
<h1 id="create-and-manage-volumes"><a class="header" href="#create-and-manage-volumes">Create and manage volumes</a></h1>
<p><strong>Create a volume</strong>:</p>
<pre><code class="language-sh"># 自动创建卷 时会指定 默认挂载位置
# ${docker_root_dir}/volumes/my-vol/_data
$ docker volume create my-vol
</code></pre>
<p><strong>List volumes</strong>:</p>
<pre><code class="language-sh">docker volume ls
</code></pre>
<p><strong>Inspect a volume</strong>:</p>
<pre><code class="language-sh">$ docker volume inspect my-vol
[
    {
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Labels&quot;: {},
        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,
        &quot;Name&quot;: &quot;my-vol&quot;,
        &quot;Options&quot;: {},
        &quot;Scope&quot;: &quot;local&quot;
    }
]
</code></pre>
<p><strong>Remove a volume</strong>:</p>
<pre><code class="language-sh">$ docker volume rm my-vol
</code></pre>
<h1 id="启动一个带卷的容器"><a class="header" href="#启动一个带卷的容器">启动一个带卷的容器</a></h1>
<h2 id="使用命令指定"><a class="header" href="#使用命令指定">使用命令指定</a></h2>
<p>如果您使用尚不存在的卷启动容器，Docker 会为您创建该卷。
以下示例将卷 myvol2 安装到容器中的 /app/ 中。</p>
<pre><code class="language-sh">$ docker run -d \
  --name devtest \
  --mount source=myvol2,target=/app \
  nginx:latest
</code></pre>
<h2 id="docker-compose指定"><a class="header" href="#docker-compose指定">docker-compose指定</a></h2>
<p><strong>在 首次 调用过程中 会自动创建</strong></p>
<pre><code>version: &quot;3.9&quot;
services:
  frontend:
    image: node:lts
    volumes:
      - myapp:/home/node/app
volumes:
  myapp:
</code></pre>
<h2 id="start-a-service-with-volumes"><a class="header" href="#start-a-service-with-volumes">Start a service with volumes</a></h2>
<pre><code class="language-sh">$ docker service create -d \
  --replicas=4 \
  --name devtest-service \
  --mount source=myvol2,target=/app \
  nginx:latest
</code></pre>
<p>删除该服务不会删除该服务创建的任何卷。
卷删除是一个单独的步骤。</p>
<p>docker service create 命令不支持 -v 或 --volume 标志。
将卷挂载到服务的容器中时，您必须使用 --mount 标志。</p>
<h2 id="use-a-read-only-volume"><a class="header" href="#use-a-read-only-volume">Use a read-only volume</a></h2>
<p>多个容器可以挂载同一个卷，并且可以同时为其中一些容器以读写方式挂载，对其他容器以只读方式挂载</p>
<pre><code>$ docker run -d \
  --name=nginxtest \
  --mount source=nginx-vol,destination=/usr/share/nginx/html,readonly \
  nginx:latest
</code></pre>
<h1 id="在机器之间共享数据"><a class="header" href="#在机器之间共享数据">在机器之间共享数据</a></h1>
<p>构建容错应用程序时，您可能需要配置同一服务的多个副本才能访问相同的文件</p>
<p>在开发应用程序时，有多种方法可以实现这一点。
一种是向您的应用程序添加逻辑，以将文件存储在 Amazon S3 等云对象存储系统上。
另一种方法是使用支持将文件写入外部存储系统（如 NFS 或 Amazon S3）的驱动程序创建卷。</p>
<p>卷驱动程序允许您从应用程序逻辑中抽象出底层存储系统。
例如，如果您的服务使用带有 NFS 驱动程序的卷，您可以更新服务以使用不同的驱动程序，例如将数据存储在云中，而无需更改应用程序逻辑。</p>
<h2 id="use-a-volume-driver"><a class="header" href="#use-a-volume-driver">Use a volume driver</a></h2>
<p>当您使用 docker volume create 创建卷时，或者当您启动使用尚未创建的卷的容器时，您可以指定卷驱动程序。
以下示例首先在创建独立卷时使用 vieux/sshfs 卷驱动程序，然后在启动创建新卷的容器时使用。</p>
<h3 id="initial-set-up"><a class="header" href="#initial-set-up">Initial set-up</a></h3>
<p>在 Docker 主机上，安装 vieux/sshfs 插件：</p>
<pre><code class="language-sh">$ docker plugin install --grant-all-permissions vieux/sshfs
</code></pre>
<h2 id="create-a-volume-using-a-volume-driver"><a class="header" href="#create-a-volume-using-a-volume-driver">Create a volume using a volume driver</a></h2>
<p>此示例指定了 SSH 密码，但如果两台主机配置了共享密钥，则可以省略密码。
每个卷驱动程序可能有零个或多个可配置选项，每个选项都使用 -o 标志指定。</p>
<pre><code class="language-sh">docker volume create --driver vieux/sshfs \
  -o sshcmd=test@node2:/home/test \
  -o password=testpassword \
  sshvolume
</code></pre>
<h2 id="创建-nfs-卷的服务"><a class="header" href="#创建-nfs-卷的服务">创建 NFS 卷的服务</a></h2>
<p>此示例说明如何在创建服务时创建 NFS 卷。
本示例使用 10.0.0.10 作为 NFS 服务器，使用 /var/docker-nfs 作为 NFS 服务器上的导出目录。
请注意，指定的卷驱动程序是本地的。</p>
<pre><code class="language-sh">$ docker service create -d \
  --name nfs-service \
  --mount 'type=volume,source=nfsvolume,target=/app,volume-driver=local,volume-opt=type=nfs,volume-opt=device=:/var/docker-nfs,volume-opt=o=addr=10.0.0.10' \
  nginx:latest
</code></pre>
<pre><code class="language-sh">docker service create -d \
    --name nfs-service \
    --mount 'type=volume,source=nfsvolume,target=/app,volume-driver=local,volume-opt=type=nfs,volume-opt=device=:/var/docker-nfs,&quot;volume-opt=o=addr=10.0.0.10,rw,nfsvers=4,async&quot;' \
    nginx:latest
</code></pre>
<h2 id="create-cifssamba-volumes"><a class="header" href="#create-cifssamba-volumes">Create CIFS/Samba volumes</a></h2>
<blockquote>
<p>请注意，如果使用主机名而不是 IP，则需要 addr 选项，以便 docker 可以执行主机名查找。</p>
</blockquote>
<pre><code class="language-sh">docker volume create \
	--driver local \
	--opt type=cifs \
	--opt device=//uxxxxx.your-server.de/backup \
	--opt o=addr=uxxxxx.your-server.de,username=uxxxxxxx,password=*****,file_mode=0777,dir_mode=0777 \
	--name cif-volume
</code></pre>
<p><strong>手动创建</strong></p>
<pre><code>docker volume create \
	--driver local \
	--opt type=cifs \
	--opt device=//192.168.1.166/gitrepo/docker_test \
	--opt o=username=networkshare,password=123456,file_mode=0777,dir_mode=0777 \
	--name cif-volume
</code></pre>
<p><strong>docker-compose语法</strong></p>
<pre><code class="language-yaml">volumes:
  cif-volume:
    driver: local
    driver_opts:
      type: cifs
      device: //192.168.1.166/gitrepo/docker_test
      o:  username=networkshare,password=123456,file_mode=0777,dir_mode=0777
</code></pre>
<h1 id="备份恢复或迁移数据卷"><a class="header" href="#备份恢复或迁移数据卷">备份、恢复或迁移数据卷</a></h1>
<h2 id="备份容器"><a class="header" href="#备份容器">备份容器</a></h2>
<pre><code class="language-sh">$ docker run -v /dbdata --name dbstore ubuntu /bin/bash

$ docker run --rm --volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata
</code></pre>
<h2 id="从备份恢复容器"><a class="header" href="#从备份恢复容器">从备份恢复容器</a></h2>
<pre><code class="language-sh">$ docker run -v /dbdata --name dbstore2 ubuntu /bin/bash
$ docker run --rm --volumes-from dbstore2 -v $(pwd):/backup ubuntu bash -c &quot;cd /dbdata &amp;&amp; tar xvf /backup/backup.tar --strip 1&quot;
</code></pre>
<h1 id="remove-volumes"><a class="header" href="#remove-volumes">Remove volumes</a></h1>
<p>删除容器后，Docker 数据卷仍然存在。
有两种类型的卷需要考虑：</p>
<p>命名卷具有来自容器外部的特定来源，例如 awesome:/bar。
匿名卷没有特定的来源，所以当容器被删除时，指示 Docker 引擎守护进程将它们删除。</p>
<h2 id="remove-anonymous-volumes"><a class="header" href="#remove-anonymous-volumes">Remove anonymous volumes</a></h2>
<p>要自动删除匿名卷，请使用 --rm 选项。
例如，此命令创建匿名 /foo 卷。
当容器被移除时，Docker 引擎会移除 /foo 卷而不是 awesome 卷。</p>
<pre><code class="language-sh">$ docker run --rm -v /foo -v awesome:/bar busybox top
</code></pre>
<h2 id="remove-all-volumes"><a class="header" href="#remove-all-volumes">Remove all volumes</a></h2>
<p>To remove all unused volumes and free up space:</p>
<pre><code class="language-sh">$ docker volume prune
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="连接到-已启动的容器中"><a class="header" href="#连接到-已启动的容器中">连接到 已启动的容器中</a></h1>
<h2 id="使用docker-attach进入docker容器"><a class="header" href="#使用docker-attach进入docker容器">使用docker attach进入Docker容器</a></h2>
<pre><code class="language-sh"># 创建 守护进程
sudo docker run -itd ubuntu:14.04 /bin/bash  
# 连接该容器 的输入输出 到 宿主机的标准输入输出
sudo docker attach 44fc0f0582d9  
</code></pre>
<h2 id="使用ssh进入docker容器"><a class="header" href="#使用ssh进入docker容器">使用SSH进入Docker容器</a></h2>
<p><a href="https://www.oschina.net/translate/why-you-dont-need-to-run-sshd-in-docker?cmp">不推荐使用</a></p>
<h2 id="使用nsenter进入docker容器"><a class="header" href="#使用nsenter进入docker容器">使用nsenter进入Docker容器</a></h2>
<p>什么是 <a href="https://github.com/jpetazzo/nsenter">nsenter</a></p>
<p>　　nsenter可以访问另一个进程的名称空间。所以为了连接到某个容器我们还需要获取该容器的第一个进程的PID。可以使用docker inspect命令来拿到该PID。</p>
<p>docker inspect命令使用如下：</p>
<pre><code class="language-sh">sudo docker inspect 44fc0f0582d9  
sudo docker inspect -f {{.State.Pid}} 44fc0f0582d9  
sudo nsenter --target 3326 --mount --uts --ipc --net --pid 
</code></pre>
<h2 id="使用docker-exec进入docker容器"><a class="header" href="#使用docker-exec进入docker容器"><strong>使用docker exec进入Docker容器</strong></a></h2>
<p><strong>交互式模式终端</strong></p>
<pre><code class="language-sh"># i:交互式连接，t：分配一个伪终端
docker exec -i -t [容器名] /bin/bash
</code></pre>
<p><strong>运行容器内的脚本</strong></p>
<pre><code class="language-sh">docker exec -it [容器名] /bin/sh /root/runoob.sh
</code></pre>
<p><strong>利用容器ID</strong></p>
<pre><code class="language-sh">docker exec -it [容器ID] /bin/bash
</code></pre>
<p><a href="https://www.cnblogs.com/xhyan/p/6593075.html">参考链接</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="总览"><a class="header" href="#总览">总览</a></h1>
<blockquote>
<p>registry 是一个无状态、高度可扩展的服务器端应用程序，用于存储和分发 Docker 镜像</p>
</blockquote>
<h1 id="基本命令"><a class="header" href="#基本命令">基本命令</a></h1>
<p><strong>建立镜像</strong></p>
<pre><code>docker run -d -p 5000:5000 --name registry registry:2
</code></pre>
<p><strong>推送与拉取镜像</strong></p>
<pre><code class="language-sh">docker pull ubuntu
docker image tag ubuntu localhost:5000/myfirstimage
docker push localhost:5000/myfirstimage
docker pull localhost:5000/myfirstimage
</code></pre>
<p><strong>删除镜像</strong></p>
<pre><code class="language-sh">docker container stop registry &amp;&amp; docker container rm -v registry
</code></pre>
<h1 id="镜像命名"><a class="header" href="#镜像命名">镜像命名</a></h1>
<p>典型 docker 命令中使用的 镜像名称反映了它们的来源：</p>
<ul>
<li><code>docker pull ubuntu</code> instructs docker to pull an image named <code>ubuntu</code> from the official Docker Hub. This is simply a shortcut for the longer <code>docker pull docker.io/library/ubuntu</code> command</li>
<li><code>docker pull myregistrydomain:port/foo/bar</code> instructs docker to contact the registry located at <code>myregistrydomain:port</code> to find the image <code>foo/bar</code></li>
</ul>
<h1 id="搭建外部访问的-registry"><a class="header" href="#搭建外部访问的-registry">搭建外部访问的 registry</a></h1>
<h2 id="获取自签名证书"><a class="header" href="#获取自签名证书">获取自签名证书</a></h2>
<p><strong>修改  /etc/pki/tls/openssl.cnf</strong></p>
<pre><code>sed  '/^\[ v3_ca \]/  a subjectAltName = IP:192.168.1.73'   /etc/pki/tls/openssl.cnf
</code></pre>
<p><strong>生成证书</strong></p>
<pre><code class="language-sh">openssl req \
  -newkey rsa:4096 -nodes -sha256 -keyout certs/domain.key \
  -x509 -days 365 -out certs/domain.crt
  
  #-addext &quot;subjectAltName = IP:192.168.1.73&quot; \

</code></pre>
<p><strong>加入到docker</strong></p>
<pre><code>docker secret rm domain.crt
docker secret rm domain.key
docker secret create domain.crt certs/domain.crt
docker secret create domain.key certs/domain.key
</code></pre>
<p><strong>copy证书到 所有docker</strong></p>
<pre><code>cp certs/domain.crt  /etc/docker/certs.d/192.168.1.73:5000/ca.crt

</code></pre>
<p><strong>创建镜像</strong></p>
<pre><code>docker service create \
  --name registry \
  --secret domain.crt \
  --secret domain.key \
  --constraint 'node.role==manager' \
  --mount type=bind,source=/data/registry,destination=/var/lib/registry \
  -e REGISTRY_HTTP_TLS_CERTIFICATE=/run/secrets/domain.crt \
  -e REGISTRY_HTTP_TLS_KEY=/run/secrets/domain.key \
  --publish published=5000,target=5000 \
  --replicas 1 \
  registry:2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前言-1"><a class="header" href="#前言-1">前言</a></h1>
<p>主要介绍registry、harbor两种私有仓库搭建。</p>
<h1 id="registry-的搭建"><a class="header" href="#registry-的搭建">registry 的搭建</a></h1>
<p>Docker 官方提供了一个搭建私有仓库的镜像 <strong>registry</strong> ，只需把镜像下载下来，运行容器并暴露5000端口，就可以使用了。</p>
<pre><code>docker pull registry:2
docker run -d -v /opt/registry:/var/lib/registry -p 5000:5000 --name myregistry registry:2

</code></pre>
<p>Registry服务默认会将上传的镜像保存在容器的/var/lib/registry，我们将主机的/opt/registry目录挂载到该目录，即可实现将镜像保存到主机的/opt/registry目录了。</p>
<p>浏览器访问http://127.0.0.1:5000/v2，出现下面情况说明registry运行正常。</p>
<p>现在通过push镜像到registry来验证一下。</p>
<p><strong>要通过docker tag将该镜像标志为要推送到私有仓库：</strong></p>
<pre><code class="language-sh">使用docker tag将session-web:latest这个镜像标记为 127.0.0.1:5000/session-web:latest
#格式为
docker tag IMAGE[:TAG][REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]
docker tag session-web:latest 127.0.0.1:5000/session-web:latest
#使用docker push上传标记的镜像
docker push 127.0.0.1:5000/session-web:latest
</code></pre>
<p><strong>下载私有仓库的镜像，使用如下命令：</strong></p>
<pre><code class="language-sh">docker pull localhost:5000/镜像名:版本号
docker pull localhost:5000/nginx:latest
</code></pre>
<h1 id="harbor-的搭建"><a class="header" href="#harbor-的搭建">harbor 的搭建</a></h1>
<p>docker 官方提供的私有仓库 registry，用起来虽然简单 ，但在管理的功能上存在不足。 Harbor是一个用于存储和分发Docker镜像的企业级Registry服务器，harbor使用的是官方的docker registry(v2命名是distribution)服务去完成。harbor在docker distribution的基础上增加了一些安全、访问控制、管理的功能以满足企业对于镜像仓库的需求。</p>
<h2 id="搭建"><a class="header" href="#搭建">搭建</a></h2>
<h3 id="下载"><a class="header" href="#下载">下载</a></h3>
<p><a href="https://github.com/goharbor/harbor/releases">github</a></p>
<h3 id="配置"><a class="header" href="#配置">配置</a></h3>
<pre><code>tar -xvf harbor-offline-installer-{version}.tgz
</code></pre>
<p>**修改 harbor.yml **</p>
<pre><code>#hostname 改为 0.0.0.0
hostname = 
https 配置注释掉
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker离线安装"><a class="header" href="#docker离线安装">Docker离线安装</a></h1>
<h2 id="下载-1"><a class="header" href="#下载-1">下载</a></h2>
<p>下载链接：<a href="https://download.docker.com/linux/static/stable/x86_64/docker-20.10.7.tgz">20.10.7.tgz</a></p>
<h2 id="解压"><a class="header" href="#解压">解压</a></h2>
<p>将解压出来的docker文件内容移动到 /usr/bin/ 目录下</p>
<h2 id="注册为service"><a class="header" href="#注册为service">注册为service</a></h2>
<pre><code class="language-sh">vim /etc/systemd/system/docker.service
</code></pre>
<pre><code>[Unit]
Description=Docker Application Container Engine
Documentation=https://docs.docker.com
After=network-online.target firewalld.service
Wants=network-online.target
[Service]
Type=notify
# the default is not to use systemd for cgroups because the delegate issues still
# exists and systemd currently does not support the cgroup feature set required
# for containers run by docker
ExecStart=/usr/bin/dockerd
ExecReload=/bin/kill -s HUP $MAINPID
# Having non-zero Limit*s causes performance problems due to accounting overhead
# in the kernel. We recommend using cgroups to do container-local accounting.
LimitNOFILE=infinity
LimitNPROC=infinity
LimitCORE=infinity
# Uncomment TasksMax if your systemd version supports it.
# Only systemd 226 and above support this version.
#TasksMax=infinity
TimeoutStartSec=0
# set delegate yes so that systemd does not reset the cgroups of docker containers
Delegate=yes
# kill only the docker process, not all processes in the cgroup
KillMode=process
# restart the docker process if it exits prematurely
Restart=on-failure
StartLimitBurst=3
StartLimitInterval=60s
 
[Install]
WantedBy=multi-user.target
</code></pre>
<p>添加文件权限并启动docker，执行如下命令：</p>
<pre><code class="language-bash">chmod +x /etc/systemd/system/docker.service                      #添加文件权限
systemctl daemon-reload                                                       #重载unit配置文件
systemctl start docker                                                            #启动Docker
systemctl enable docker.service                                            #设置开机自启
</code></pre>
<p>验证docker安装是否成功：</p>
<pre><code class="language-bash">systemctl status docker                                                         #查看Docker状态
docker -v                                                                                #查看Docker版本
</code></pre>
<h2 id="导入离线镜像"><a class="header" href="#导入离线镜像">导入离线镜像</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前言-2"><a class="header" href="#前言-2">前言</a></h1>
<p>Docker 存在 4种网络工作方式，和一些自定义网络模式</p>
<p>安装Docker时，它会自动创建三个网络，bridge（创建容器默认连接到此网络）、 none 、host</p>
<p><strong>host</strong></p>
<p>容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。</p>
<p><strong>Container</strong></p>
<p>创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围。</p>
<p><strong>None</strong></p>
<p>该模式关闭了容器的网络功能。</p>
<p><strong>Bridge</strong></p>
<p>此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及Iptables nat表配置与宿主机通信。</p>
<p>Docker内置这三个网络，运行容器时，你可以使用该--network标志来指定容器应连接到哪些网络。</p>
<p><strong>指定网络</strong></p>
<pre><code class="language-sh">host模式：使用 --net=host 指定。

none模式：使用 --net=none 指定。

bridge模式：使用 --net=bridge 指定，默认设置。

container模式：使用 --net=container:NAME_or_ID 指定。
</code></pre>
<h1 id="网络模式详解"><a class="header" href="#网络模式详解">网络模式详解</a></h1>
<h2 id="host"><a class="header" href="#host">Host</a></h2>
<p><strong>与宿主机在同一个网络中，但没有独立IP地址</strong></p>
<p><strong>命名空间隔离资源</strong></p>
<p>众所周知，Docker使用了Linux的Namespaces技术来进行资源隔离，</p>
<p>如PID Namespace隔离进程，Mount Namespace隔离文件系统，Network Namespace隔离网络等。</p>
<p><strong>network 隔离网络</strong></p>
<p>一个Network Namespace提供了一份独立的网络环境，包括网卡、路由、Iptable规则等都与其他的Network Namespace隔离。</p>
<p>一个Docker容器一般会分配一个独立的Network Namespace。</p>
<p>但如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。</p>
<p><strong>例如</strong></p>
<pre><code class="language-sh">docker run --name nginx1 -p80:80 --net=host -d nginx
</code></pre>
<h2 id="container"><a class="header" href="#container">Container</a></h2>
<p>这个模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace</p>
<p>而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等</p>
<p>同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过lo网卡设备通信。</p>
<h2 id="none"><a class="header" href="#none">None</a></h2>
<p>该模式关闭了容器的网络功能</p>
<h2 id="bridge"><a class="header" href="#bridge">Bridge</a></h2>
<p>容器使用独立network Namespace，并连接到docker0虚拟网卡</p>
<p>通过docker0网桥以及Iptables nat表配置与宿主机通信；bridge模式是Docker默认的网络设置，此模式会为每一个容器分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到一个虚拟网桥上。下面着重介绍一下此模式。</p>
<h3 id="bridge模式的拓扑结构"><a class="header" href="#bridge模式的拓扑结构">Bridge模式的拓扑结构</a></h3>
<p><strong>创建虚拟网桥</strong></p>
<p>当Docker server启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上</p>
<p><strong>分配容器IP</strong></p>
<p>虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中</p>
<p>接下来就要为容器分配IP了，Docker会从RFC1918所定义的私有IP网段中，选择一个和宿主机不同的IP地址和子网分配给docker0，连接到docker0的容器就从这个子网中选择一个未占用的IP使用，如一般Docker会使用172.17.0.0/16这个网段，并将172.17.0.1/16分配给docker0网桥</p>
<p><img src="1.%E5%AE%B9%E5%99%A8_docker//images/docker-network-bridge-example1.jpg" alt="" /></p>
<h3 id="网络配置过程"><a class="header" href="#网络配置过程">网络配置过程</a></h3>
<ul>
<li>在主机上创建一对虚拟网卡veth pair设备</li>
</ul>
<p>veth设备总是成对出现的，它们组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来。因此，veth设备常用来连接两个网络设备</p>
<ul>
<li>
<p>Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0。另一端放在主机中，以veth65f9这样类似的名字命名，并将这个网络设备加入到docker0网桥中</p>
</li>
<li>
<p>从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。</p>
</li>
</ul>
<h3 id="bridge模式下容器的通信"><a class="header" href="#bridge模式下容器的通信">bridge模式下容器的通信</a></h3>
<p><strong>容器间可以相互通信</strong></p>
<p>在bridge模式下，连在同一网桥上的容器可以相互通信</p>
<p>（若出于安全考虑，也可以禁止它们之间通信，方法是在DOCKER_OPTS变量中设置–icc=false，这样只有使用–link才能使两个容器通信）</p>
<p><strong>限制容器间的通信</strong></p>
<p>Docker可以开启容器间通信（意味着默认配置--icc=true），也就是说，宿主机上的所有容器可以不受任何限制地相互通信，这可能导致拒绝服务攻击。</p>
<p>Docker可以通过--ip_forward和--iptables两个选项控制容器间、容器和外部世界的通信。</p>
<pre><code>-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE
</code></pre>
<pre><code>这条规则会将源地址为172.17.0.0/16的包（也就是从Docker容器产生的包），并且不是从docker0网卡发出的，进行源地址转换，转换成主机网卡的地址。

这么说可能不太好理解，举一个例子说明一下。假设主机有一块网卡为eth0，IP地址为10.10.101.105/24，网关为10.10.101.254。从主机上一个IP为172.17.0.1/16的容器中ping百度（180.76.3.151）。IP包首先从容器发往自己的默认网关docker0，包到达docker0后，也就到达了主机上。然后会查询主机的路由表，发现包应该从主机的eth0发往主机的网关10.10.105.254/24。接着包会转发给eth0，并从eth0发出去（主机的ip_forward转发应该已经打开）。这时候，上面的Iptable规则就会起作用，对包做SNAT转换，将源地址换为eth0的地址。这样，在外界看来，这个包就是从10.10.101.105上发出来的，Docker容器对外是不可见的。
</code></pre>
<h3 id="外面的机器是如何访问docker容器的服务呢"><a class="header" href="#外面的机器是如何访问docker容器的服务呢">外面的机器是如何访问Docker容器的服务呢？</a></h3>
<pre><code class="language-sh"> docker run --name=nginx_bridge --net=bridge -p 80:80 -d nginx
</code></pre>
<pre><code class="language-sh">iptables -L
-A DOCKER ! -i docker0 -p tcp -m tcp --dport 80 -j DNAT --to-destination 172.17.0.2:80
</code></pre>
<pre><code>此条规则就是对主机eth0收到的目的端口为80的tcp流量进行DNAT转换，将流量发往172.17.0.2:80，也就是我们上面创建的Docker容器。所以，外界只需访问10.10.101.105:80就可以访问到容器中的服务。

除此之外，我们还可以自定义Docker使用的IP地址、DNS等信息，甚至使用自己定义的网桥，但是其工作方式还是一样的。
</code></pre>
<h2 id="自定义网络"><a class="header" href="#自定义网络">自定义网络</a></h2>
<p>建议使用自定义的网桥来控制哪些容器可以相互通信，还可以自动DNS解析容器名称到IP地址。Docker提供了创建这些网络的默认网络驱动程序，你可以创建一个新的Bridge网络，Overlay或Macvlan网络。你还可以创建一个网络插件或远程网络进行完整的自定义和控制。</p>
<p>你可以根据需要创建任意数量的网络，并且可以在任何给定时间将容器连接到这些网络中的零个或多个网络。此外，您可以连接并断开网络中的运行容器，而无需重新启动容器。当容器连接到多个网络时，其外部连接通过第一个非内部网络以词法顺序提供。</p>
<h3 id="自定义桥接网络"><a class="header" href="#自定义桥接网络">自定义桥接网络</a></h3>
<pre><code class="language-sh">docker network create --driver bridge new_bridge

创建网络后，可以看到新增加了一个网桥（172.18.0.1）。

72: br-2edfc1326986: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default 
    link/ether 02:42:07:cc:f8:33 brd ff:ff:ff:ff:ff:ff
    inet 172.18.0.1/16 scope global br-2edfc1326986
       valid_lft forever preferred_lft forever
</code></pre>
<h3 id="macvlan"><a class="header" href="#macvlan">Macvlan</a></h3>
<p><strong>简介</strong></p>
<p>Macvlan是一个新的尝试，是真正的网络虚拟化技术的转折点。Linux实现非常轻量级，因为与传统的Linux Bridge隔离相比，它们只是简单地与一个Linux以太网接口或子接口相关联，以实现网络之间的分离和与物理网络的连接。</p>
<p>Macvlan提供了许多独特的功能，并有充足的空间进一步创新与各种模式。这些方法的两个高级优点是绕过Linux网桥的正面性能以及移动部件少的简单性。删除传统上驻留在Docker主机NIC和容器接口之间的网桥留下了一个非常简单的设置，包括容器接口，直接连接到Docker主机接口。由于在这些情况下没有端口映射，因此可以轻松访问外部服务。</p>
<p><strong>Macvlan Bridge模式示例用法</strong></p>
<p>略</p>
<p><a href="https://www.cnblogs.com/zuxing/articles/8780661.html">详见</a></p>
<h1 id="docker网络管理命令"><a class="header" href="#docker网络管理命令">docker网络管理命令</a></h1>
<pre><code class="language-sh">#创建自定义网络
docker network create
# 上线一个网络
docker network connect
# 查看网络
docker network ls
# 删除网络
docker network rm
# 下线网络
docker network disconnect
# 查看网络明细
docker network inspect
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="以idea为例"><a class="header" href="#以idea为例">以IDEA为例</a></h1>
<p>配置 <code>TLS</code> 实现安全的 Docker 远程连接。</p>
<h1 id="非安全的连接方式"><a class="header" href="#非安全的连接方式">非安全的连接方式</a></h1>
<p>以CentOS为例</p>
<h2 id="配置-socket-service"><a class="header" href="#配置-socket-service">配置 socket-service</a></h2>
<pre><code>vim /etc/systemd/system/docker-tcp.socket

[Unit]
Description=Docker Socket for the API

[Socket]
# ListenStream=127.0.0.1:2375
ListenStream=2375
BindIPv6Only=both
Service=docker.service

[Install]
WantedBy=sockets.target
</code></pre>
<h2 id="重新启动服务"><a class="header" href="#重新启动服务">重新启动服务</a></h2>
<pre><code class="language-javascript">$ sudo systemctl daemon-reload
$ sudo systemctl enable docker-tcp.socket
$ sudo systemctl stop docker
$ sudo systemctl start docker-tcp.socket
$ sudo systemctl start docker

# 注意：这种方法必须先启动 docker-tcp.socket，再启动 Docker，一定要注意启动顺序！
</code></pre>
<h2 id="客户端测试连接"><a class="header" href="#客户端测试连接">客户端测试连接</a></h2>
<pre><code>
docker -H 192.168.57.110:2375 info
</code></pre>
<h2 id="配置环境变量简化连接"><a class="header" href="#配置环境变量简化连接">配置环境变量简化连接</a></h2>
<pre><code> export DOCKER_HOST=&quot;tcp://0.0.0.0:2375&quot;
 docker info
</code></pre>
<h1 id="配置tls安全连接"><a class="header" href="#配置tls安全连接">配置TLS安全连接</a></h1>
<p><a href="https://docs.docker.com/engine/security/protect-access/">官方文档</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1047265">步骤</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="全局修改地方"><a class="header" href="#全局修改地方">全局修改地方</a></h1>
<pre><code>protected-mode no
appendonly yes
</code></pre>
<h1 id="变量定义"><a class="header" href="#变量定义">变量定义</a></h1>
<h2 id="redis通用变量"><a class="header" href="#redis通用变量">redis通用变量</a></h2>
<pre><code>port 6001
pidfile &quot;/var/run/redis_6001.pid&quot;
bind 172.16.48.129 127.0.0.1
</code></pre>
<h2 id="redis进程"><a class="header" href="#redis进程">redis进程</a></h2>
<pre><code>requirepass &quot;123456&quot;
masterauth &quot;123456&quot;
</code></pre>
<h2 id="redis从进程"><a class="header" href="#redis从进程">redis从进程</a></h2>
<pre><code>#新增
requirepass &quot;123456&quot;
masterauth &quot;123456&quot;
slaveof 192.168.1.88 6001
</code></pre>
<h2 id="哨兵进程"><a class="header" href="#哨兵进程">哨兵进程</a></h2>
<pre><code>sentinel monitor mymaster 192.168.1.32 6001 2
sentinel down-after-milliseconds mymaster 5000
sentinel failover-timeout mymaster 15000
sentinel parallel-syncs mymaster 2
sentinel auth-pass mymaster 123456
</code></pre>
<h1 id="ip配置"><a class="header" href="#ip配置">IP配置</a></h1>
<pre><code>#通用变量
REDIS_IMAGE_NAME=myredis-server
SENTINEl_IMAGE_NAME=myredis-sentinel

# 创建 一主两从，三哨兵

MASTER1=172.18.1.2
SLAVE1=172.18.1.3
SLAVE2=172.18.1.4
SENTINEL1=172.18.1.5
SENTINEL2=172.18.1.6
SENTINEL3=172.18.1.7



# 函数定义  --------------------------------------------------------------------------------------
# 创建容器
create_container(){
 ip=$1;shift;
 image_name=$1;shift;
 docker run -d --name ${image_name}_${ip} --ip $ip --network=mynet   $image_name
}

function delete_container(){
        ip=$1;shift;
        image_name=$1;shift;
        docker stop ${image_name}_${ip}
        docker rm ${image_name}_${ip}
}

function restartContainer(){
        ip=$1;shift;
        image_name=$1;shift;
        docker restart ${image_name}_${ip}
}


# 函数定义结束  --------------------------------------------------------------------------------------
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker安装-1"><a class="header" href="#docker安装-1">docker安装</a></h1>
<pre><code class="language-sh">#安装仓库管理工具
yum install -y yum-utils
# 添加阿里云docker仓库
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
# 查看docker版本
yum list docker-ce --showduplicates
# 安装docker
yum install docker-ce
</code></pre>
<h1 id="mysql"><a class="header" href="#mysql">mysql</a></h1>
<p>docker hub 链接：<a href="https://hub.docker.com/_/mysql">https://hub.docker.com/_/mysql</a></p>
<h2 id="docker拉取"><a class="header" href="#docker拉取">docker拉取</a></h2>
<pre><code class="language-shell">docker pull mysql
</code></pre>
<h2 id="docker从镜像启动容器"><a class="header" href="#docker从镜像启动容器">docker从镜像启动容器</a></h2>
<pre><code class="language-sh">docker stop mysql1
docker rm mysql1
docker container  run   --name  mysql1 --privileged=true     -v /data/mysqldata:/var/lib/mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7.34  --lower_case_table_names=1
</code></pre>
<h2 id="docker容器管理"><a class="header" href="#docker容器管理">docker容器管理</a></h2>
<pre><code class="language-sh">docker container restart mysql1
docker container start mysql1
docker container stop mysql1
</code></pre>
<h2 id="直连mysql服务"><a class="header" href="#直连mysql服务">直连mysql服务</a></h2>
<p><strong>查询容器IP</strong></p>
<pre><code class="language-sh">docker inspect 容器ID | grep IPAddress
docker inspect --format='{{.NetworkSettings.IPAddress}}' mycentos3
</code></pre>
<p><strong>启动一个mysql客户端连接</strong></p>
<pre><code class="language-sh">docker run -it --rm  mysql:5.7.34   mysql -uroot -proot -h172.17.0.2
</code></pre>
<h1 id="删除无关容器"><a class="header" href="#删除无关容器"><strong>删除无关容器</strong></a></h1>
<p>未命名容器</p>
<pre><code class="language-sh">docker rmi $(docker images --filter dangling=true -q)
</code></pre>
<h2 id="修改数据源存放路径"><a class="header" href="#修改数据源存放路径">修改数据源存放路径</a></h2>
<pre><code>vi /etc/docker/daemon.json 
{
  &quot;data-root&quot;: &quot;/www/docker&quot;
}
systemctl restart docker
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<p><a href="https://kubernetes.io/docs/tasks/tools/">安装工具</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation"><a href="http://ansible.com.cn/docs/intro_installation.html#id9">Installation</a></a></h1>
<h3 id="从github获取ansible"><a class="header" href="#从github获取ansible"><a href="http://ansible.com.cn/docs/intro_installation.html#id10">从Github获取Ansible</a></a></h3>
<p>如果你有一个github账户,可以跟进Ansible在Github的项目: <a href="https://github.com/ansible/ansible">Github project</a> 我们在这里保持对bugs和feature ideas的跟踪.</p>
<h3 id="需要安装些什么"><a class="header" href="#需要安装些什么"><a href="http://ansible.com.cn/docs/intro_installation.html#id11">需要安装些什么</a></a></h3>
<ol>
<li>
<p>Ansible默认通过 SSH 协议管理机器.</p>
</li>
<li>
<p>安装Ansible之后,不需要启动或运行一个后台进程,或是添加一个数据库.只要在一台电脑(可以是一台笔记本)上安装好,就可以通过这台电脑管理一组远程的机器.在远程被管理的机器上,不需要安装运行任何软件,</p>
</li>
<li>
<p>因此升级Ansible版本不会有太多问题.</p>
</li>
</ol>
<h3 id="选择哪一个版本"><a class="header" href="#选择哪一个版本"><a href="http://ansible.com.cn/docs/intro_installation.html#id12">选择哪一个版本?</a></a></h3>
<ol>
<li>
<p>因为Ansible可以很简单的从源码运行,且不必在远程被管理机器上安装任何软件,很多Ansible用户会跟进使用开发版本.</p>
</li>
<li>
<p>Ansible一般每两个月出一个发行版本.小bugs一般在下一个发行版本中修复,并在稳定分支中做backports.</p>
</li>
<li>
<p>大bugs会在必要时出一个维护版本,不过这不是很频繁.</p>
</li>
<li>
<p>若你希望使用Ansible的最新版本,并且你使用的操作系统是 Red Hat Enterprise Linux (TM), CentOS, Fedora, Debian, Ubuntu,我们建议使用系统的软件包管理器.</p>
</li>
<li>
<p>另有一种选择是通过”pip”工具安装,”pip”是一个安装和管理Python包的工具.</p>
</li>
<li>
<p>若你希望跟进开发版本,想使用和测试最新的功能特性,我们会分享如何从源码运行Ansible的方法.从源码运行程序不需要进行软件安装.</p>
</li>
</ol>
<h3 id="对管理主机的要求"><a class="header" href="#对管理主机的要求"><a href="http://ansible.com.cn/docs/intro_installation.html#id13">对管理主机的要求</a></a></h3>
<ol>
<li>目前,只要机器上安装了 Python 2.6 或 Python 2.7 (windows系统不可以做控制主机),都可以运行Ansible.</li>
<li>主机的系统可以是 Red Hat, Debian, CentOS, OS X, BSD的各种版本,等等.</li>
<li>自2.0版本开始,ansible使用了更多句柄来管理它的子进程,对于OS X系统,你需要增加ulimit值才能使用15个以上子进程,方法 sudo launchctl limit maxfiles 1024 2048,否则你可能会看见”Too many open file”的错误提示.</li>
</ol>
<h3 id="对托管节点的要求"><a class="header" href="#对托管节点的要求"><a href="http://ansible.com.cn/docs/intro_installation.html#id14">对托管节点的要求</a></a></h3>
<ol>
<li>通常我们使用 ssh 与托管节点通信，默认使用 sftp.如果 sftp 不可用，可在 ansible.cfg 配置文件中配置成 scp 的方式</li>
<li>在托管节点上也需要安装 Python 2.4 或以上的版本.如果版本低于 Python 2.5 ,还需要额外安装一个模块:<code>python-simplejson</code></li>
<li>没安装python-simplejson,也可以使用Ansible的”raw”模块和script模块,因此从技术上讲,你可以通过Ansible的”raw”模块安装python-simplejson,之后就可以使用Ansible的所有功能了.</li>
<li>如果托管节点上开启了SElinux,你需要安装libselinux-python,这样才可使用Ansible中与copy/file/template相关的函数.你可以通过Ansible的yum模块在需要的托管节点上安装libselinux-python.</li>
<li>Python 3 与 Python 2 是稍有不同的语言,大多数Python程序还不能在 Python 3 中正确运行.一些Linux发行版(Gentoo, Arch)没有默认安装 Python 2.X 解释器.在这些系统上,你需要安装一个 Python 2.X 解释器,并在 inventory (详见 <a href="http://ansible.com.cn/docs/intro_inventory.html"><em>Inventory文件</em></a>) 中设置 ‘ansible_python_interpreter’ 变量指向你的 2.X Python.你可以使用 ‘raw’ 模块在托管节点上远程安装Python 2.X.</li>
<li>例如：ansible myhost --sudo -m raw -a &quot;yum install -y python2 python-simplejson&quot; 这条命令可以通过远程方式在托管节点上安装 Python 2.X 和 simplejson 模块.</li>
<li>Red Hat Enterprise Linux, CentOS, Fedora, and Ubuntu 等发行版都默认安装了 2.X 的解释器,包括几乎所有的Unix系统也是如此.</li>
</ol>
<h3 id="安装管理主机"><a class="header" href="#安装管理主机"><a href="http://ansible.com.cn/docs/intro_installation.html#id15">安装管理主机</a></a></h3>
<ol>
<li>
<p>从项目的checkout中可以很容易运行Ansible,Ansible的运行不要求root权限,也不依赖于其他软件,不要求运行后台进程,也不需要设置数据库.</p>
</li>
<li>
<p>因此我们社区的许多用户一直使用Ansible的开发版本,这样可以利用最新的功能特性,也方便对项目做贡献.因为不需要安装任何东西,跟进Ansible的开发版相对于其他开源项目要容易很多.</p>
</li>
</ol>
<h4 id="从源码安装的步骤"><a class="header" href="#从源码安装的步骤">从源码安装的步骤</a></h4>
<pre><code>$ git clone git://github.com/ansible/ansible.git --recursive
$ cd ./ansible
</code></pre>
<h4 id="使用-bash"><a class="header" href="#使用-bash">使用 Bash:</a></h4>
<pre><code>$ source ./hacking/env-setup
</code></pre>
<h4 id="使用-fish"><a class="header" href="#使用-fish">使用 Fish:</a></h4>
<pre><code>$ . ./hacking/env-setup.fish
</code></pre>
<p>If you want to suppress spurious warnings/errors, use:</p>
<pre><code>$ source ./hacking/env-setup -q
</code></pre>
<p>如果没有安装pip, 请先安装对应于你的Python版本的pip:</p>
<pre><code>$ sudo easy_install pip
</code></pre>
<p>以下的Python模块也需要安装</p>
<pre><code>$ sudo pip install paramiko PyYAML Jinja2 httplib2 six
</code></pre>
<p>注意,当更新ansible版本时,不只要更新git的源码树,也要更新git中指向Ansible自身模块的 “submodules” (不是同一种模块)</p>
<pre><code>$ git pull --rebase
$ git submodule update --init --recursive
</code></pre>
<p>一旦运行env-setup脚本,就意味着Ansible从源码中运行起来了.默认的inventory文件是 /etc/ansible/hosts.inventory文件也可以另行指定 (详见 <a href="http://ansible.com.cn/docs/intro_inventory.html"><em>Inventory文件</em></a>) :</p>
<pre><code>$ echo &quot;127.0.0.1&quot; &gt; ~/ansible_hosts
$ export ANSIBLE_HOSTS=~/ansible_hosts
</code></pre>
<p>你可以在手册的后续章节阅读更多关于 inventory 文件的使用,现在让我们测试一条ping命令:</p>
<pre><code>$ ansible all -m ping --ask-pass
</code></pre>
<pre><code>你也可以使用命令 “sudo make install”
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-guide"><a class="header" href="#user-guide">User Guide</a></h1>
<h2 id="getting-started"><a class="header" href="#getting-started"><a href="https://docs.ansible.com/ansible/latest/user_guide/index.html#getting-started">Getting started</a></a></h2>
<ul>
<li>·我想概述一下Ansible是如何工作的。我在哪里可以找到:
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/quickstart.html#quickstart-guide">quick video overview</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_getting_started.html#intro-getting-started">text introduction</a></li>
</ul>
</li>
<li>我准备好学习Ansible了：What <a href="https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html#basic-concepts">Ansible concepts</a> do I need to learn?</li>
<li>即时命令行：How do I use <a href="https://docs.ansible.com/ansible/latest/user_guide/intro_adhoc.html#intro-adhoc">ad hoc commands</a>?</li>
</ul>
<h2 id="writing-tasks-plays-and-playbooks"><a class="header" href="#writing-tasks-plays-and-playbooks"><a href="https://docs.ansible.com/ansible/latest/user_guide/index.html#writing-tasks-plays-and-playbooks">Writing tasks, plays, and playbooks</a></a></h2>
<ul>
<li>我正在写我的第一本剧本。应该做什么： I <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html#playbooks-tips-and-tricks">know before I begin</a>?</li>
<li>我有一个任务或剧本的特定用例:
<ul>
<li>Executing tasks with elevated privileges or as a different user with <a href="https://docs.ansible.com/ansible/latest/user_guide/become.html#become">become</a></li>
<li>以提升的权限执行任务，或者以不同的用户的身份执行 任务   <a href="https://docs.ansible.com/ansible/latest/user_guide/become.html#become">become</a></li>
<li>使用不同参数重复执行任务  <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#playbooks-loops">loops</a></li>
<li>在不同的机器上执行任务， <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_delegation.html#playbooks-delegation">delegation</a></li>
<li>当且仅当 一定条件满足  <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_conditionals.html#playbooks-conditionals">conditionals</a> ，才运行任务。使用  <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_tests.html#playbooks-tests">tests</a> 评估条件</li>
<li>使用 <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_blocks.html#playbooks-blocks">blocks</a>  任务分组</li>
<li>仅当某些内容发生变化时才运行任务：<a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_handlers.html#handlers">handlers</a></li>
<li>Changing the way Ansible <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_error_handling.html#playbooks-error-handling">handles failures</a></li>
<li>Setting remote <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_environment.html#playbooks-environment">environment values</a></li>
</ul>
</li>
<li>I want to take advantage of the power of re-usable Ansible artifacts. How do I create re-usable <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.html#playbooks-reuse">files</a> and <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html#playbooks-reuse-roles">roles</a>?</li>
<li>I need to incorporate one file or playbook inside another. What is the difference between <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.html#dynamic-vs-static">including and importing</a>?</li>
<li>I want to run selected parts of my playbook. How do I add and use <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_tags.html#tags">tags</a>?</li>
</ul>
<h2 id="working-with-inventory"><a class="header" href="#working-with-inventory"><a href="https://docs.ansible.com/ansible/latest/user_guide/index.html#working-with-inventory">Working with inventory</a></a></h2>
<ul>
<li>I have a list of servers and devices I want to automate. How do I create <a href="https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html#intro-inventory">inventory</a> to track them?</li>
<li>I use cloud services and constantly have servers and devices starting and stopping. How do I track them using <a href="https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html#intro-dynamic-inventory">dynamic inventory</a>?</li>
<li>I want to automate specific sub-sets of my inventory. How do I use <a href="https://docs.ansible.com/ansible/latest/user_guide/intro_patterns.html#intro-patterns">patterns</a>?</li>
</ul>
<h2 id="interacting-with-data"><a class="header" href="#interacting-with-data"><a href="https://docs.ansible.com/ansible/latest/user_guide/index.html#interacting-with-data">Interacting with data</a></a></h2>
<p>Once your playbook is ready to run, you may need to use these topics:</p>
<ul>
<li>Executing “dry run” playbooks with <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_checkmode.html#check-mode-dry">check mode and diff</a></li>
<li>Running playbooks while troubleshooting with <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_startnstep.html#playbooks-start-and-step">start and step</a></li>
<li>Correcting tasks during execution with the <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_debugger.html#playbook-debugger">Ansible debugger</a></li>
<li>Controlling how my playbook executes with <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_strategies.html#playbooks-strategies">strategies and more</a></li>
<li>Running tasks, plays, and playbooks <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_async.html#playbooks-async">asynchronously</a></li>
</ul>
<h2 id="advanced-features-and-reference"><a class="header" href="#advanced-features-and-reference"><a href="https://docs.ansible.com/ansible/latest/user_guide/index.html#advanced-features-and-reference">Advanced features and reference</a></a></h2>
<ul>
<li>Using <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_advanced_syntax.html#playbooks-advanced-syntax">advanced syntax</a></li>
<li>Manipulating <a href="https://docs.ansible.com/ansible/latest/user_guide/complex_data_manipulation.html#complex-data-manipulation">complex data</a></li>
<li>Using <a href="https://docs.ansible.com/ansible/latest/plugins/plugins.html#plugins-lookup">plugins</a></li>
<li>Using <a href="https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html#playbook-keywords">playbook keywords</a></li>
<li>Using <a href="https://docs.ansible.com/ansible/latest/user_guide/command_line_tools.html#command-line-tools">command-line tools</a></li>
<li>Rejecting <a href="https://docs.ansible.com/ansible/latest/user_guide/plugin_filtering_config.html#plugin-filtering-config">specific modules</a></li>
<li>Module <a href="https://docs.ansible.com/ansible/latest/user_guide/modules_support.html#modules-support">maintenance</a></li>
</ul>
<h2 id="traditional-table-of-contents"><a class="header" href="#traditional-table-of-contents"><a href="https://docs.ansible.com/ansible/latest/user_guide/index.html#traditional-table-of-contents">Traditional Table of Contents</a></a></h2>
<p>If you prefer to read the entire User Guide, here’s a list of the pages in order:</p>
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/quickstart.html">Ansible Quickstart Guide</a></li>
<li>Ansible concepts
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html#control-node">Control node</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html#managed-nodes">Managed nodes</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html#inventory">Inventory</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html#collections">Collections</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html#modules">Modules</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html#tasks">Tasks</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html#playbooks">Playbooks</a></li>
</ul>
</li>
<li>Getting Started
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_getting_started.html#selecting-machines-from-inventory">Selecting machines from inventory</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_getting_started.html#connecting-to-remote-nodes">Connecting to remote nodes</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_getting_started.html#copying-and-executing-modules">Copying and executing modules</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_getting_started.html#resources">Resources</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_getting_started.html#next-steps">Next steps</a></li>
</ul>
</li>
<li>Introduction to ad hoc commands
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_adhoc.html#why-use-ad-hoc-commands">Why use ad hoc commands?</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_adhoc.html#use-cases-for-ad-hoc-tasks">Use cases for ad hoc tasks</a></li>
</ul>
</li>
<li>Working with playbooks
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html">Templating (Jinja2)</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_special_topics.html">Advanced playbooks features</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/guide_rolling_upgrade.html">Playbook Example: Continuous Delivery and Rolling Upgrades</a></li>
</ul>
</li>
<li>Intro to playbooks
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_intro.html#playbook-syntax">Playbook syntax</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_intro.html#playbook-execution">Playbook execution</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_intro.html#ansible-pull">Ansible-Pull</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_intro.html#verifying-playbooks">Verifying playbooks</a></li>
</ul>
</li>
<li>Tips and tricks
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html#general-tips">General tips</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html#playbook-tips">Playbook tips</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html#inventory-tips">Inventory tips</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html#execution-tricks">Execution tricks</a></li>
</ul>
</li>
<li>Understanding privilege escalation: become
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/become.html#using-become">Using become</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/become.html#risks-and-limitations-of-become">Risks and limitations of become</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/become.html#become-and-network-automation">Become and network automation</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/become.html#become-and-windows">Become and Windows</a></li>
</ul>
</li>
<li>Loops
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#comparing-loop-and-with">Comparing <code>loop</code> and <code>with_*</code></a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#standard-loops">Standard loops</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#registering-variables-with-a-loop">Registering variables with a loop</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#complex-loops">Complex loops</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#ensuring-list-input-for-loop-using-query-rather-than-lookup">Ensuring list input for <code>loop</code>: using <code>query</code> rather than <code>lookup</code></a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#adding-controls-to-loops">Adding controls to loops</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#migrating-from-with-x-to-loop">Migrating from with_X to loop</a></li>
</ul>
</li>
<li>Controlling where tasks run: delegation and local actions
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_delegation.html#tasks-that-cannot-be-delegated">Tasks that cannot be delegated</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_delegation.html#delegating-tasks">Delegating tasks</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_delegation.html#delegation-and-parallel-execution">Delegation and parallel execution</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_delegation.html#delegating-facts">Delegating facts</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_delegation.html#local-playbooks">Local playbooks</a></li>
</ul>
</li>
<li>Conditionals
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_conditionals.html#basic-conditionals-with-when">Basic conditionals with <code>when</code></a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_conditionals.html#commonly-used-facts">Commonly-used facts</a></li>
</ul>
</li>
<li>Tests
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_tests.html#test-syntax">Test syntax</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_tests.html#testing-strings">Testing strings</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_tests.html#vault">Vault</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_tests.html#testing-truthiness">Testing truthiness</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_tests.html#comparing-versions">Comparing versions</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_tests.html#set-theory-tests">Set theory tests</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_tests.html#testing-if-a-list-contains-a-value">Testing if a list contains a value</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_tests.html#testing-if-a-list-value-is-true">Testing if a list value is True</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_tests.html#testing-paths">Testing paths</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_tests.html#testing-size-formats">Testing size formats</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_tests.html#testing-task-results">Testing task results</a></li>
</ul>
</li>
<li>Blocks
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_blocks.html#grouping-tasks-with-blocks">Grouping tasks with blocks</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_blocks.html#handling-errors-with-blocks">Handling errors with blocks</a></li>
</ul>
</li>
<li>Handlers: running operations on change
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_handlers.html#handler-example">Handler example</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_handlers.html#controlling-when-handlers-run">Controlling when handlers run</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_handlers.html#using-variables-with-handlers">Using variables with handlers</a></li>
</ul>
</li>
<li>Error handling in playbooks
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_error_handling.html#ignoring-failed-commands">Ignoring failed commands</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_error_handling.html#ignoring-unreachable-host-errors">Ignoring unreachable host errors</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_error_handling.html#resetting-unreachable-hosts">Resetting unreachable hosts</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_error_handling.html#handlers-and-failure">Handlers and failure</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_error_handling.html#defining-failure">Defining failure</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_error_handling.html#defining-changed">Defining “changed”</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_error_handling.html#ensuring-success-for-command-and-shell">Ensuring success for command and shell</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_error_handling.html#aborting-a-play-on-all-hosts">Aborting a play on all hosts</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_error_handling.html#controlling-errors-in-blocks">Controlling errors in blocks</a></li>
</ul>
</li>
<li>Setting the remote environment
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_environment.html#setting-the-remote-environment-in-a-task">Setting the remote environment in a task</a></li>
</ul>
</li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_environment.html#working-with-language-specific-version-managers">Working with language-specific version managers</a></li>
<li>Re-using Ansible artifacts
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.html#creating-re-usable-files-and-roles">Creating re-usable files and roles</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.html#re-using-playbooks">Re-using playbooks</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.html#re-using-files-and-roles">Re-using files and roles</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.html#re-using-tasks-as-handlers">Re-using tasks as handlers</a></li>
</ul>
</li>
<li>Roles
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html#role-directory-structure">Role directory structure</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html#storing-and-finding-roles">Storing and finding roles</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html#using-roles">Using roles</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html#role-argument-validation">Role argument validation</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html#running-a-role-multiple-times-in-one-playbook">Running a role multiple times in one playbook</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html#using-role-dependencies">Using role dependencies</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html#embedding-modules-and-plugins-in-roles">Embedding modules and plugins in roles</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html#sharing-roles-ansible-galaxy">Sharing roles: Ansible Galaxy</a></li>
</ul>
</li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_includes.html">Including and importing</a></li>
<li>Tags
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_tags.html#adding-tags-with-the-tags-keyword">Adding tags with the tags keyword</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_tags.html#special-tags-always-and-never">Special tags: always and never</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_tags.html#selecting-or-skipping-tags-when-you-run-a-playbook">Selecting or skipping tags when you run a playbook</a></li>
</ul>
</li>
<li>How to build your inventory
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html#inventory-basics-formats-hosts-and-groups">Inventory basics: formats, hosts, and groups</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html#adding-variables-to-inventory">Adding variables to inventory</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html#assigning-a-variable-to-one-machine-host-variables">Assigning a variable to one machine: host variables</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html#assigning-a-variable-to-many-machines-group-variables">Assigning a variable to many machines: group variables</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html#organizing-host-and-group-variables">Organizing host and group variables</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html#how-variables-are-merged">How variables are merged</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html#using-multiple-inventory-sources">Using multiple inventory sources</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html#connecting-to-hosts-behavioral-inventory-parameters">Connecting to hosts: behavioral inventory parameters</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html#inventory-setup-examples">Inventory setup examples</a></li>
</ul>
</li>
<li>Working with dynamic inventory
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html#inventory-script-example-cobbler">Inventory script example: Cobbler</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html#inventory-script-example-openstack">Inventory script example: OpenStack</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html#other-inventory-scripts">Other inventory scripts</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html#using-inventory-directories-and-multiple-inventory-sources">Using inventory directories and multiple inventory sources</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html#static-groups-of-dynamic-groups">Static groups of dynamic groups</a></li>
</ul>
</li>
<li>Patterns: targeting hosts and groups
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_patterns.html#using-patterns">Using patterns</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_patterns.html#common-patterns">Common patterns</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_patterns.html#limitations-of-patterns">Limitations of patterns</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_patterns.html#advanced-pattern-options">Advanced pattern options</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_patterns.html#patterns-and-ad-hoc-commands">Patterns and ad-hoc commands</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_patterns.html#patterns-and-ansible-playbook-flags">Patterns and ansible-playbook flags</a></li>
</ul>
</li>
<li>Connection methods and details
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/connection_details.html#controlpersist-and-paramiko">ControlPersist and paramiko</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/connection_details.html#setting-a-remote-user">Setting a remote user</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/connection_details.html#setting-up-ssh-keys">Setting up SSH keys</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/connection_details.html#running-against-localhost">Running against localhost</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/connection_details.html#managing-host-key-checking">Managing host key checking</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/connection_details.html#other-connection-methods">Other connection methods</a></li>
</ul>
</li>
<li>Working with command line tools
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/cli/ansible.html">ansible</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/cli/ansible-config.html">ansible-config</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/cli/ansible-console.html">ansible-console</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/cli/ansible-doc.html">ansible-doc</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/cli/ansible-galaxy.html">ansible-galaxy</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/cli/ansible-inventory.html">ansible-inventory</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/cli/ansible-playbook.html">ansible-playbook</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/cli/ansible-pull.html">ansible-pull</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/cli/ansible-vault.html">ansible-vault</a></li>
</ul>
</li>
<li>Using Variables
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#creating-valid-variable-names">Creating valid variable names</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#simple-variables">Simple variables</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#when-to-quote-variables-a-yaml-gotcha">When to quote variables (a YAML gotcha)</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#list-variables">List variables</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#dictionary-variables">Dictionary variables</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#registering-variables">Registering variables</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#referencing-nested-variables">Referencing nested variables</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#transforming-variables-with-jinja2-filters">Transforming variables with Jinja2 filters</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#where-to-set-variables">Where to set variables</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable">Variable precedence: Where should I put a variable?</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#using-advanced-variable-syntax">Using advanced variable syntax</a></li>
</ul>
</li>
<li>Discovering variables: facts and magic variables
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_vars_facts.html#ansible-facts">Ansible facts</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_vars_facts.html#information-about-ansible-magic-variables">Information about Ansible: magic variables</a></li>
</ul>
</li>
<li>Encrypting content with Ansible Vault
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/vault.html#managing-vault-passwords">Managing vault passwords</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/vault.html#id1">Encrypting content with Ansible Vault</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/vault.html#using-encrypted-variables-and-files">Using encrypted variables and files</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/vault.html#configuring-defaults-for-using-encrypted-content">Configuring defaults for using encrypted content</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/vault.html#when-are-encrypted-files-made-visible">When are encrypted files made visible?</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/vault.html#format-of-files-encrypted-with-ansible-vault">Format of files encrypted with Ansible Vault</a></li>
</ul>
</li>
<li>Using filters to manipulate data
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#handling-undefined-variables">Handling undefined variables</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#defining-different-values-for-true-false-null-ternary">Defining different values for true/false/null (ternary)</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#managing-data-types">Managing data types</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#formatting-data-yaml-and-json">Formatting data: YAML and JSON</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#combining-and-selecting-data">Combining and selecting data</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#randomizing-data">Randomizing data</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#managing-list-variables">Managing list variables</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#selecting-from-sets-or-lists-set-theory">Selecting from sets or lists (set theory)</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#calculating-numbers-math">Calculating numbers (math)</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#managing-network-interactions">Managing network interactions</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#hashing-and-encrypting-strings-and-passwords">Hashing and encrypting strings and passwords</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#manipulating-text">Manipulating text</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#manipulating-strings">Manipulating strings</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#managing-uuids">Managing UUIDs</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#handling-dates-and-times">Handling dates and times</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#getting-kubernetes-resource-names">Getting Kubernetes resource names</a></li>
</ul>
</li>
<li>Lookups
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_lookups.html#using-lookups-in-variables">Using lookups in variables</a></li>
</ul>
</li>
<li>Interactive input: prompts
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_prompts.html#encrypting-values-supplied-by-vars-prompt">Encrypting values supplied by <code>vars_prompt</code></a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_prompts.html#allowing-special-characters-in-vars-prompt-values">Allowing special characters in <code>vars_prompt</code> values</a></li>
</ul>
</li>
<li>Module defaults
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_module_defaults.html#module-defaults-groups">Module defaults groups</a></li>
</ul>
</li>
<li>Validating tasks: check mode and diff mode
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_checkmode.html#using-check-mode">Using check mode</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_checkmode.html#using-diff-mode">Using diff mode</a></li>
</ul>
</li>
<li>Executing playbooks for troubleshooting
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_startnstep.html#start-at-task">start-at-task</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_startnstep.html#step-mode">Step mode</a></li>
</ul>
</li>
<li>Debugging tasks
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_debugger.html#enabling-the-debugger">Enabling the debugger</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_debugger.html#resolving-errors-in-the-debugger">Resolving errors in the debugger</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_debugger.html#available-debug-commands">Available debug commands</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_debugger.html#how-the-debugger-interacts-with-the-free-strategy">How the debugger interacts with the free strategy</a></li>
</ul>
</li>
<li>Controlling playbook execution: strategies and more
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_strategies.html#selecting-a-strategy">Selecting a strategy</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_strategies.html#setting-the-number-of-forks">Setting the number of forks</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_strategies.html#using-keywords-to-control-execution">Using keywords to control execution</a></li>
</ul>
</li>
<li>Asynchronous actions and polling
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_async.html#asynchronous-ad-hoc-tasks">Asynchronous ad hoc tasks</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_async.html#asynchronous-playbook-tasks">Asynchronous playbook tasks</a></li>
</ul>
</li>
<li>Advanced Syntax
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_advanced_syntax.html#unsafe-or-raw-strings">Unsafe or raw strings</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_advanced_syntax.html#yaml-anchors-and-aliases-sharing-variable-values">YAML anchors and aliases: sharing variable values</a></li>
</ul>
</li>
<li>Data manipulation
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/complex_data_manipulation.html#loops-and-list-comprehensions">Loops and list comprehensions</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/complex_data_manipulation.html#complex-type-transformations">Complex Type transformations</a></li>
</ul>
</li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/plugin_filtering_config.html">Rejecting modules</a></li>
<li>Sample Ansible setup
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/sample_setup.html#sample-directory-layout">Sample directory layout</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/sample_setup.html#alternative-directory-layout">Alternative directory layout</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/sample_setup.html#sample-group-and-host-variables">Sample group and host variables</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/sample_setup.html#sample-playbooks-organized-by-function">Sample playbooks organized by function</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/sample_setup.html#sample-task-and-handler-files-in-a-function-based-role">Sample task and handler files in a function-based role</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/sample_setup.html#what-the-sample-setup-enables">What the sample setup enables</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/sample_setup.html#organizing-for-deployment-or-configuration">Organizing for deployment or configuration</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/sample_setup.html#using-local-ansible-modules">Using local Ansible modules</a></li>
</ul>
</li>
<li>Working With Modules
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/modules_intro.html">Introduction to modules</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/modules_support.html">Module Maintenance &amp; Support</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/reference_appendices/common_return_values.html">Return Values</a></li>
</ul>
</li>
<li>Working with plugins
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/plugins/action.html">Action plugins</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/plugins/become.html">Become plugins</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/plugins/cache.html">Cache plugins</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/plugins/callback.html">Callback plugins</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/plugins/cliconf.html">Cliconf plugins</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/plugins/connection.html">Connection plugins</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/plugins/docs_fragment.html">Docs fragments</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/plugins/filter.html">Filter plugins</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/plugins/httpapi.html">Httpapi plugins</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/plugins/inventory.html">Inventory plugins</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/plugins/lookup.html">Lookup plugins</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/plugins/module.html">Modules</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/plugins/module_util.html">Module utilities</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/plugins/netconf.html">Netconf plugins</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/plugins/shell.html">Shell plugins</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/plugins/strategy.html">Strategy plugins</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/plugins/terminal.html">Terminal plugins</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/plugins/test.html">Test plugins</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/plugins/vars.html">Vars plugins</a></li>
</ul>
</li>
<li>Playbook Keywords
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html#play">Play</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html#role">Role</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html#block">Block</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html#task">Task</a></li>
</ul>
</li>
<li>Ansible and BSD
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_bsd.html#connecting-to-bsd-nodes">Connecting to BSD nodes</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_bsd.html#bootstrapping-bsd">Bootstrapping BSD</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_bsd.html#setting-the-python-interpreter">Setting the Python interpreter</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_bsd.html#which-modules-are-available">Which modules are available?</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_bsd.html#using-bsd-as-the-control-node">Using BSD as the control node</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_bsd.html#bsd-facts">BSD facts</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_bsd.html#bsd-efforts-and-contributions">BSD efforts and contributions</a></li>
</ul>
</li>
<li>Windows Guides
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/windows_setup.html">Setting up a Windows Host</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/windows_winrm.html">Windows Remote Management</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/windows_usage.html">Using Ansible and Windows</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/windows_dsc.html">Desired State Configuration</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/windows_performance.html">Windows performance</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/windows_faq.html">Windows Frequently Asked Questions</a></li>
</ul>
</li>
<li>Using collections
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/collections_using.html#installing-collections">Installing collections</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/collections_using.html#downloading-collections">Downloading collections</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/collections_using.html#listing-collections">Listing collections</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/collections_using.html#verifying-collections">Verifying collections</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/collections_using.html#using-collections-in-a-playbook">Using collections in a Playbook</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/collections_using.html#simplifying-module-names-with-the-collections-keyword">Simplifying module names with the <code>collections</code> keyword</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/collections_using.html#using-a-playbook-from-a-collection">Using a playbook from a collection</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="关于ansible"><a class="header" href="#关于ansible">关于Ansible</a></h1>
<p>Ansible是一个IT自动化工具，能够配置系统，部署软件，编码高级的IT任务例如 持续部署或者 0宕机 滚动更新</p>
<h1 id="安装ansible"><a class="header" href="#安装ansible">安装Ansible</a></h1>
<h2 id="安装ansible自身"><a class="header" href="#安装ansible自身">安装Ansible自身</a></h2>
<p><code>sudo yum install ansible</code></p>
<h2 id="安装shell命令行自动补全"><a class="header" href="#安装shell命令行自动补全">安装shell命令行自动补全</a></h2>
<p><code>yum install epel-release</code></p>
<p><code>yum install python-argcomplete</code></p>
<h2 id="自动补全设置"><a class="header" href="#自动补全设置">自动补全设置</a></h2>
<p><code>activate-global-python-argcomplete</code></p>
<h1 id="概念"><a class="header" href="#概念">概念</a></h1>
<h2 id="控制节点"><a class="header" href="#控制节点">控制节点</a></h2>
<p>能够运行Ansible命令 和playbooks 通过</p>
<p><code>/usr/bin/ansible or/usr/bin/ansible-playbook</code></p>
<h2 id="受管节点"><a class="header" href="#受管节点">受管节点</a></h2>
<p>Ansible管理的网络设备</p>
<p><code>/etc/ansible/hosts</code> 中记录着 受管结点的主机名</p>
<h2 id="inventory"><a class="header" href="#inventory">Inventory</a></h2>
<p>一系列的受管节点，清单文件也叫做 hostfile,可以为每个受管节点指定IP，也可以用来创建或者嵌套组，方便扩容，</p>
<h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<p>ansible功能单位，每一个module都有专门的 功能，从管理特定数据库的用户到 管理特定类型的网络设备VLAN接口，可以执行一个模块的一个task，也可以执行多个模块的多个功能，也就是剧本</p>
<h2 id="tasks"><a class="header" href="#tasks">tasks</a></h2>
<p>Ansible的 执行动作单位</p>
<h2 id="playbooks"><a class="header" href="#playbooks">playbooks</a></h2>
<ul>
<li>有序的任务列表</li>
<li>以YAML方式写的</li>
</ul>
<h1 id="动态清单"><a class="header" href="#动态清单">动态清单</a></h1>
<p>description</p>
<ul>
<li>如果你的配置根据需求 时常变动，你可能需要从多个源头 载入hosts，例如云服务提供商，LDAP，Cobber,或者其他企业的CMDB</li>
<li>Ansible提供两种方式，连接外部存储
<ul>
<li>inventory plugins：推荐使用plugins</li>
<li>inventory scripts</li>
</ul>
</li>
<li>红帽的 RedHatAnsibleTower 提供GUI界面编辑与同步，并提供web and Rest服务</li>
</ul>
<p>example with Cobber</p>
<ul>
<li>Ansible能与cobber无缝集成。cobber主要用于OS安装，DHCP,DNS 管理，从当轻量级的CMDB</li>
</ul>
<h1 id="模式定位主机和组"><a class="header" href="#模式定位主机和组">模式：定位主机和组</a></h1>
<ul>
<li>
<p><code>ansible &lt;pattern&gt; -m &lt;module_name&gt; -a &quot;&lt;module options&gt;&quot;&quot;</code></p>
</li>
<li>
<p>pattern 是 playbook的 hosts 选项</p>
</li>
<li>
<p>pattern模式</p>
<table><thead><tr><th>Description</th><th>Pattern(s)</th><th>Targets</th></tr></thead><tbody>
<tr><td>All hosts</td><td>all (or *)</td><td></td></tr>
<tr><td>One host</td><td>host1</td><td></td></tr>
<tr><td>Multiple hosts</td><td>host1:host2 (or host1,host2)</td><td></td></tr>
<tr><td>One group</td><td>webservers</td><td></td></tr>
<tr><td>Multiple groups</td><td>webservers:dbservers</td><td>all hosts in webservers plus all hosts in dbservers</td></tr>
<tr><td>Excluding groups</td><td>webservers:!atlanta</td><td>all hosts in webservers except those in atlanta</td></tr>
<tr><td>Intersection of groups</td><td>webservers:&amp;staging</td><td>any hosts in webservers that are also in staging</td></tr>
</tbody></table>
</li>
<li>
<p>pattern高级用法</p>
<ul>
<li>
<p>使用变量 ， ansible-playbook， -e 传递的ansible-playbook</p>
</li>
<li>
<p>使用组定位，</p>
<pre><code>webservers[0]       # == cobweb
webservers[-1]      # == weber
webservers[0:2]     # == webservers[0],webservers[1]
                    # == cobweb,webbing
webservers[1:]      # == webbing,weber
webservers[:3]      # == cobweb,webbing,weber
</code></pre>
</li>
<li>
<p>使用正则表达式 ，以 ~ 开头的</p>
</li>
<li>
<p>在命令行选项指定 --limit </p>
<ul>
<li>
<pre><code>ansible-playbook site.yml --limit datacenter2 //指定主机
</code></pre>
</li>
<li>
<pre><code>ansible-playbook site.yml --limit @retry_hosts.txt //指定从文件读主机
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="loops"><a class="header" href="#loops"><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html">Loops</a></a></h3>
<ol>
<li>
<p>Ansible提供 ， <code>loop</code>, <code>with_&lt;lookup&gt;</code>, and <code>until</code> 关键字多次执行任务。</p>
</li>
<li>
<p>常用循环的示例 包括使用文件模块更改多个文件和/或目录的所有权， <a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/file_module.html#file-module">file module</a></p>
</li>
<li>
<p>creating multiple users with the <a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/user_module.html#user-module">user module</a>,</p>
</li>
<li>
<p>并重复轮询步骤，直到达到某个结果。</p>
</li>
</ol>
<h3 id="standard-loops"><a class="header" href="#standard-loops"><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#id4">Standard loops</a></a></h3>
<h4 id="iterating-over-a-simple-list"><a class="header" href="#iterating-over-a-simple-list"><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#id5">Iterating over a simple list</a></a></h4>
<pre><code class="language-yml">- name: Add several users
  ansible.builtin.user:
    name: &quot;{{ item }}&quot;
    state: present
    groups: &quot;wheel&quot;
  loop:
     - testuser1
     - testuser2
</code></pre>
<p>您可以在variables 文件中或  play 的 vars 部分中定义列表，然后参考任务中列表的名称。</p>
<pre><code>loop: &quot;{{ somelist }}&quot;

</code></pre>
<pre><code>- name: Add user testuser1
  ansible.builtin.user:
    name: &quot;testuser1&quot;
    state: present
    groups: &quot;wheel&quot;

- name: Add user testuser2
  ansible.builtin.user:
    name: &quot;testuser2&quot;
    state: present
    groups: &quot;wheel&quot;
</code></pre>
<p><strong>注意</strong></p>
<ol>
<li>
<p>您可以将列表直接传递给某些插件的参数。</p>
</li>
<li>
<p>大多数包装模块，例如yum和apt，都具有此功能。</p>
</li>
<li>
<p>在可用时，将列表传递给参数比循环任务更好。例如</p>
</li>
</ol>
<h4 id="iterating-over-a-list-of-hashes"><a class="header" href="#iterating-over-a-list-of-hashes"><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#id6">Iterating over a list of hashes</a></a></h4>
<pre><code>- name: Add several users
  ansible.builtin.user:
    name: &quot;{{ item.name }}&quot;
    state: present
    groups: &quot;{{ item.groups }}&quot;
  loop:
    - { name: 'testuser1', groups: 'wheel' }
    - { name: 'testuser2', groups: 'root' }
</code></pre>
<ol>
<li>When combining <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_conditionals.html#playbooks-conditionals">conditionals</a> with a loop, </li>
<li>the <code>when:</code> statement is processed separately for each item. See <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_conditionals.html#the-when-statement">Basic conditionals with when</a> for examples.</li>
</ol>
<h3 id="iterating-over-a-dictionary"><a class="header" href="#iterating-over-a-dictionary"><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#id7">Iterating over a dictionary</a></a></h3>
<p>To loop over a dict, use the <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#dict-filter">dict2items</a>:</p>
<pre><code class="language-yaml">- name: Using dict2items
  ansible.builtin.debug:
    msg: &quot;{{ item.key }} - {{ item.value }}&quot;
  loop: &quot;{{ tag_data | dict2items }}&quot;
  vars:
    tag_data:
      Environment: dev
      Application: payment
</code></pre>
<h4 id="registering-variables-with-a-loop"><a class="header" href="#registering-variables-with-a-loop"><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#id8">Registering variables with a loop</a></a></h4>
<p><strong>output 注册为变量</strong></p>
<pre><code class="language-yaml">- name: Register loop output as a variable
  ansible.builtin.shell: &quot;echo {{ item }}&quot;
  loop:
    - &quot;one&quot;
    - &quot;two&quot;
  register: echo
</code></pre>
<ol>
<li>使用 loop注册<code>register</code>  变量时： </li>
<li>返回结果包含 <code>results</code> </li>
<li>无loop的注册情况与此不同</li>
</ol>
<pre><code class="language-json">{
    &quot;changed&quot;: true,
    &quot;msg&quot;: &quot;All items completed&quot;,
    &quot;results&quot;: [
        {
            &quot;changed&quot;: true,
            &quot;cmd&quot;: &quot;echo \&quot;one\&quot; &quot;,
            &quot;delta&quot;: &quot;0:00:00.003110&quot;,
            &quot;end&quot;: &quot;2013-12-19 12:00:05.187153&quot;,
            &quot;invocation&quot;: {
                &quot;module_args&quot;: &quot;echo \&quot;one\&quot;&quot;,
                &quot;module_name&quot;: &quot;shell&quot;
            },
            &quot;item&quot;: &quot;one&quot;,
            &quot;rc&quot;: 0,
            &quot;start&quot;: &quot;2013-12-19 12:00:05.184043&quot;,
            &quot;stderr&quot;: &quot;&quot;,
            &quot;stdout&quot;: &quot;one&quot;
        },
        {
            &quot;changed&quot;: true,
            &quot;cmd&quot;: &quot;echo \&quot;two\&quot; &quot;,
            &quot;delta&quot;: &quot;0:00:00.002920&quot;,
            &quot;end&quot;: &quot;2013-12-19 12:00:05.245502&quot;,
            &quot;invocation&quot;: {
                &quot;module_args&quot;: &quot;echo \&quot;two\&quot;&quot;,
                &quot;module_name&quot;: &quot;shell&quot;
            },
            &quot;item&quot;: &quot;two&quot;,
            &quot;rc&quot;: 0,
            &quot;start&quot;: &quot;2013-12-19 12:00:05.242582&quot;,
            &quot;stderr&quot;: &quot;&quot;,
            &quot;stdout&quot;: &quot;two&quot;
        }
    ]
}
</code></pre>
<p>在注册变量上的后续循环以检查结果可能看起来像</p>
<pre><code class="language-yaml">- name: Fail if return code is not 0
  ansible.builtin.fail:
    msg: &quot;The command ({{ item.cmd }}) did not have a 0 return code&quot;
  when: item.rc != 0
  loop: &quot;{{ echo.results }}&quot;
</code></pre>
<p>在迭代过程中，当前项 的结果将被放置在变量中。</p>
<pre><code class="language-yaml">- name: Place the result of the current item in the variable
  ansible.builtin.shell: echo &quot;{{ item }}&quot;
  loop:
    - one
    - two
  register: echo
  changed_when: echo.stdout != &quot;one&quot;
</code></pre>
<h3 id="complex-loops"><a class="header" href="#complex-loops"><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#id9">Complex loops</a></a></h3>
<h4 id="iterating-over-nested-lists"><a class="header" href="#iterating-over-nested-lists"><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#id10">Iterating over nested lists</a></a></h4>
<p>您可以使用Jinja2表达式迭代复杂列表。例如，一个循环可以组合嵌套列表。</p>
<pre><code class="language-yaml">- name: Give users access to multiple databases
  community.mysql.mysql_user:
    name: &quot;{{ item[0] }}&quot;
    priv: &quot;{{ item[1] }}.*:ALL&quot;
    append_privs: yes
    password: &quot;foo&quot;
  loop: &quot;{{ ['alice', 'bob'] | product(['clientdb', 'employeedb', 'providerdb']) | list }}&quot;
</code></pre>
<h4 id="retrying-a-task-until-a-condition-is-met"><a class="header" href="#retrying-a-task-until-a-condition-is-met"><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#id11">Retrying a task until a condition is met</a></a></h4>
<ol>
<li><em>New in version 1.4.</em></li>
<li>您可以使用 &quot;until&quot; 关键字重试任务，直到满足特定条件。下面是一个例子:</li>
</ol>
<pre><code class="language-yaml">- name: Retry a task until a certain condition is met
  ansible.builtin.shell: /usr/bin/foo
  register: result
  until: result.stdout.find(&quot;all systems go&quot;) != -1
  retries: 5
  delay: 10
</code></pre>
<ol>
<li>
<p>此任务最多运行5次，每次尝试之间延迟10秒。</p>
</li>
<li>
<p>If the result of any attempt has “all systems go” in its stdout, the task succeeds</p>
</li>
<li>
<p>“retries” 的默认值为3，“delay” 为5。</p>
</li>
<li>
<p>要查看每次重试的结果，请使用-vv运行play。</p>
</li>
<li>
<p>当使用 until 关键字，注册变量时 会多一个  <em>attempts</em> 记录 任务重试的次数</p>
</li>
</ol>
<h3 id="looping-over-inventory"><a class="header" href="#looping-over-inventory"><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#id12">Looping over inventory</a></a></h3>
<ol>
<li>To loop over your inventory, or just a subset of it, you can use a regular <code>loop</code> with the <code>ansible_play_batch</code> or <code>groups</code> variables.</li>
</ol>
<pre><code class="language-yaml">- name: Show all the hosts in the inventory
  ansible.builtin.debug:
    msg: &quot;{{ item }}&quot;
  loop: &quot;{{ groups['all'] }}&quot;

- name: Show all the hosts in the current play
  ansible.builtin.debug:
    msg: &quot;{{ item }}&quot;
  loop: &quot;{{ ansible_play_batch }}&quot;
</code></pre>
<p>There is also a specific lookup plugin <code>inventory_hostnames</code> that can be used like this</p>
<pre><code>- name: Show all the hosts in the inventory
  ansible.builtin.debug:
    msg: &quot;{{ item }}&quot;
  loop: &quot;{{ query('inventory_hostnames', 'all') }}&quot;

- name: Show all the hosts matching the pattern, ie all but the group www
  ansible.builtin.debug:
    msg: &quot;{{ item }}&quot;
  loop: &quot;{{ query('inventory_hostnames', 'all:!www') }}&quot;
</code></pre>
<p>More information on the patterns can be found in <a href="https://docs.ansible.com/ansible/latest/user_guide/intro_patterns.html#intro-patterns">Patterns: targeting hosts and groups</a>.</p>
<h4 id="ensuring-list-input-for-loop-using-query-rather-than-lookup"><a class="header" href="#ensuring-list-input-for-loop-using-query-rather-than-lookup"><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#id13">Ensuring list input for <code>loop</code>: using <code>query</code> rather than <code>lookup</code></a></a></h4>
<ol>
<li>loop关键字需要一个列表作为输入，但是lookup关键字默认返回一个逗号分隔的值字符串</li>
<li>Ansible 2.5引入了一个名为 <a href="https://docs.ansible.com/ansible/latest/plugins/lookup.html#query">query</a> 的新Jinja2函数，该函数始终返回一个列表</li>
<li>使用loop关键字时，提供更简单的接口和更可预测的查找插件输出。</li>
<li>您可以指定 <em>wantlist = True</em>  强制  <em>loop</em> 返回列表以循环，也可以使用<em>query</em>代替。</li>
</ol>
<pre><code>loop: &quot;{{ query('inventory_hostnames', 'all') }}&quot;

loop: &quot;{{ lookup('inventory_hostnames', 'all', wantlist=True) }}&quot;
</code></pre>
<h3 id="adding-controls-to-loops"><a class="header" href="#adding-controls-to-loops"><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#id14">Adding controls to loops</a></a></h3>
<p><em>New in version 2.1.</em></p>
<p>The <code>loop_control</code> keyword lets you manage your loops in useful ways.</p>
<h4 id="limiting-loop-output-with-label"><a class="header" href="#limiting-loop-output-with-label"><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#id15">Limiting loop output with <code>label</code></a></a></h4>
<p><em>New in version 2.2.</em></p>
<ol>
<li>当循环遍历复杂的数据结构时，任务的控制台输出可能是巨大的. </li>
<li>限制显示的输出, use the <code>label</code> directive with <code>loop_control</code>.</li>
</ol>
<pre><code class="language-yaml">- name: Create servers
  digital_ocean:
    name: &quot;{{ item.name }}&quot;
    state: present
  loop:
    - name: server1
      disks: 3gb
      ram: 15Gb
      network:
        nic01: 100Gb
        nic02: 10Gb
        ...
  loop_control:
    label: &quot;{{ item.name }}&quot;
</code></pre>
<ol>
<li>
<p>此任务的输出将仅显示每个 item 的 name field ，而不是多行 {{ item }} 变量的全部内容。</p>
</li>
<li>
<p>这是为了使控制台输出更具可读性，而不是保护敏感数据。如果循环中有敏感数据，请在任务上设置no_log: yes以防止泄露。</p>
</li>
</ol>
<h4 id="pausing-within-a-loop"><a class="header" href="#pausing-within-a-loop"><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#id16">Pausing within a loop</a></a></h4>
<p><em>New in version 2.2.</em></p>
<p>要控制任务循环中每个itm执行之间的时间 (以秒为单位)，请使用带有loop_control的pause指令。</p>
<pre><code class="language-yaml"># main.yml
- name: Create servers, pause 3s before creating next
  community.digitalocean.digital_ocean:
    name: &quot;{{ item }}&quot;
    state: present
  loop:
    - server1
    - server2
  loop_control:
    pause: 3
</code></pre>
<h4 id="tracking-progress-through-a-loop-with-index_var"><a class="header" href="#tracking-progress-through-a-loop-with-index_var"><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#id17">Tracking progress through a loop with <code>index_var</code></a></a></h4>
<p><em>New in version 2.5.</em></p>
<ol>
<li>跟踪你在循环中的位置</li>
<li>使用 <code>index_var</code> directive with <code>loop_control</code>. </li>
<li>此指令指定一个变量名，以包含当前循环索引。</li>
</ol>
<pre><code class="language-yaml">- name: Count our fruit
  ansible.builtin.debug:
    msg: &quot;{{ item }} with index {{ my_idx }}&quot;
  loop:
    - apple
    - banana
    - pear
  loop_control:
    index_var: my_idx
</code></pre>
<p>index_var is 0 indexed.</p>
<h4 id="defining-inner-and-outer-variable-names-with-loop_var"><a class="header" href="#defining-inner-and-outer-variable-names-with-loop_var"><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#id18">Defining inner and outer variable names with <code>loop_var</code></a></a></h4>
<p><em>New in version 2.1.</em></p>
<ol>
<li>通过使用  <code>include_tasks</code>  迭代 两个嵌套任务</li>
<li>但是，默认情况下Ansible为每个循环设置循环变量 <em>item</em>。</li>
<li>这意味着内部嵌套循环将覆盖外部循环中的<em>item</em>值</li>
<li>您可以使用loop_var和loop_control为每个循环指定变量的名称。</li>
</ol>
<pre><code class="language-yaml"># main.yml
- include_tasks: inner.yml
  loop:
    - 1
    - 2
    - 3
  loop_control:
    loop_var: outer_item

# inner.yml
- name: Print outer and inner items
  ansible.builtin.debug:
    msg: &quot;outer item={{ outer_item }} inner item={{ item }}&quot;
  loop:
    - a
    - b
    - c
</code></pre>
<p>如果Ansible检测到当前循环使用的是已经定义的变量，则会引发错误以使任务失败。</p>
<h4 id="extended-loop-variables"><a class="header" href="#extended-loop-variables"><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#id19">Extended loop variables</a></a></h4>
<p><em>New in version 2.8.</em></p>
<p>从Ansible 2.8开始，您可以使用扩展选项来循环控制来获取扩展的循环信息。此选项将公开以下信息。</p>
<table><thead><tr><th>Variable</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ansible_loop.allitems</code></td><td>The list of all items in the loop</td></tr>
<tr><td><code>ansible_loop.index</code></td><td>The current iteration of the loop. (1 indexed)</td></tr>
<tr><td><code>ansible_loop.index0</code></td><td>The current iteration of the loop. (0 indexed)</td></tr>
<tr><td><code>ansible_loop.revindex</code></td><td>The number of iterations from the end of the loop (1 indexed)</td></tr>
<tr><td><code>ansible_loop.revindex0</code></td><td>The number of iterations from the end of the loop (0 indexed)</td></tr>
<tr><td><code>ansible_loop.first</code></td><td><code>True</code> if first iteration</td></tr>
<tr><td><code>ansible_loop.last</code></td><td><code>True</code> if last iteration</td></tr>
<tr><td><code>ansible_loop.length</code></td><td>The number of items in the loop</td></tr>
<tr><td><code>ansible_loop.previtem</code></td><td>The item from the previous iteration of the loop. Undefined during the first iteration.</td></tr>
<tr><td><code>ansible_loop.nextitem</code></td><td>The item from the following iteration of the loop. Undefined during the last iteration.</td></tr>
</tbody></table>
<pre><code>loop_control:
  extended: yes
</code></pre>
<p>When using <code>loop_control.extended</code> more memory will be utilized on the control node. </p>
<ol>
<li>当使用<em>loop_control.extended</em>时，控制节点上将利用更多的内存</li>
<li>因为 <code>ansible_loop.allitems</code>  包含 所有数据的引用</li>
<li>当序列化结果以显示在主ansible进程内的回调插件中时，这些引用可能会被取消引用，导致内存使用量增加。</li>
</ol>
<h4 id="accessing-the-name-of-your-loop_var"><a class="header" href="#accessing-the-name-of-your-loop_var"><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#id20">Accessing the name of your loop_var</a></a></h4>
<p><em>New in version 2.8.</em></p>
<ol>
<li>从 Ansible 2.8 可以获取 <code>loop_control.loop_var</code> 变量名称</li>
<li>对于role authors, ，编写允许循环的角色， instead of dictating the required <code>loop_var</code> value, you can gather the value via the following</li>
</ol>
<pre><code>&quot;{{ lookup('vars', ansible_loop_var) }}&quot;
</code></pre>
<h3 id="see-also"><a class="header" href="#see-also">See also</a></h3>
<ul>
<li>
<p><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_intro.html#about-playbooks">Intro to playbooks</a></p>
<p>An introduction to playbooks</p>
</li>
<li>
<p><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html#playbooks-reuse-roles">Roles</a></p>
<p>Playbook organization by roles</p>
</li>
<li>
<p><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html#playbooks-best-practices">Tips and tricks</a></p>
<p>Tips and tricks for playbooks</p>
</li>
<li>
<p><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_conditionals.html#playbooks-conditionals">Conditionals</a></p>
<p>Conditional statements in playbooks</p>
</li>
<li>
<p><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#playbooks-variables">Using Variables</a></p>
<p>All about variables</p>
</li>
<li>
<p><a href="https://groups.google.com/group/ansible-devel">User Mailing List</a></p>
<p>Have a question? Stop by the google group!</p>
</li>
<li>
<p><a href="https://docs.ansible.com/ansible/latest/community/communication.html#communication-irc">Real-time chat</a></p>
<p>How to join Ansible chat channels</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="合法变量名"><a class="header" href="#合法变量名">合法变量名</a></h1>
<p>变量名可以为字母,数字以及下划线.变量始终应该以字母开头</p>
<h1 id="在inventory中定义变量"><a class="header" href="#在inventory中定义变量">在Inventory中定义变量</a></h1>
<h1 id="在playbook中定义变量"><a class="header" href="#在playbook中定义变量">在playbook中定义变量</a></h1>
<pre><code class="language-sh">- hosts: webservers
  vars:
    http_port: 80
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="公钥互信机制"><a class="header" href="#公钥互信机制">公钥互信机制</a></h1>
<pre><code class="language-sh">ssh-key-gen -t rsa
ssh-copy-key 192.168.3.101  192.168.3.102 192.168.3.103
</code></pre>
<h1 id="ping所有主机"><a class="header" href="#ping所有主机">ping所有主机</a></h1>
<pre><code># ping所有主机
ansible all -m ping
# 带用户名
ansible all -m ping -u bruce  
# 以sudo运行
ansible all -m ping -u bruce --sudo
# 以 sudo用户执行
ansible all -m ping -u bruce --sudo --sudo-user batman
</code></pre>
<h1 id="往所有机器上写东西"><a class="header" href="#往所有机器上写东西">往所有机器上写东西</a></h1>
<pre><code class="language-shell">ansible myserver  -m shell -a &quot;echo helloWorld&gt;~/a.txt&quot;
</code></pre>
<h1 id="包管理"><a class="header" href="#包管理">包管理</a></h1>
<pre><code class="language-shell"># 安装 epel数据源
ansible myserver -m yum -a &quot;name=https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm state=present&quot;

# 安装nginx
ansible myserver -m yum -a &quot;name=nginx.x86_64 state=present&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前言-3"><a class="header" href="#前言-3">前言</a></h1>
<p><strong>inventor文件</strong></p>
<p>Ansible 可同时操作属于一个组的多台主机,组和主机之间的关系通过 inventory 文件配置. 默认的文件路径为 <code>/etc/ansible/hosts</code></p>
<p><strong>组名分组</strong></p>
<p>方括号[]中是组名,用于对系统进行分类,便于对不同系统进行个别的管理.</p>
<p><strong>一个系统可从属不同的组</strong></p>
<p>一个系统可以属于不同的组,比如一台服务器可以同时属于 webserver组 和 dbserver组</p>
<pre><code class="language-ini">mail.example.com

[webservers]
foo.example.com
bar.example.com

[dbservers]
one.example.com
two.example.com
three.example.com
</code></pre>
<p><strong>ssh连接收管主机</strong></p>
<p>如果有主机的SSH端口不是标准的22端口,可在主机名之后加上端口号,用冒号分隔</p>
<pre><code>badwolf.example.com:5309
</code></pre>
<h1 id="构建清单"><a class="header" href="#构建清单">构建清单</a></h1>
<ul>
<li>
<p>清单文件是 受管主机的IP或主机名 列表</p>
</li>
<li>
<p>组名 用 [groupname]标识，组之间用 组名分隔</p>
</li>
<li>
<p>可以使用YAML格式</p>
</li>
<li>
<p>组</p>
<ul>
<li>有两个默认组，all, ungruoped</li>
<li>all组包含每一个主机</li>
<li>ungrouped 包含没有组的主机</li>
<li>每一个组至少有两个组 all，ungrouped</li>
<li>每一个主机 可以放在多个组</li>
</ul>
</li>
<li>
<p>主机名 符号</p>
<ul>
<li>数值区间：<code>www[01:50].example.com</code></li>
<li>字母区间：<code>db-p[a:f].example.com</code></li>
</ul>
</li>
<li>
<p>添加变量</p>
<ul>
<li>
<p>INI：<code>host1 http_port=80 maxRequestsPerChild=808</code></p>
</li>
<li>
<p>YAML：</p>
<pre><code class="language-yaml">atlanta:
  host1:
    http_port: 80
    maxRequestsPerChild: 808

</code></pre>
</li>
</ul>
</li>
<li>
<p>添加组变量，<code>:vars</code></p>
<pre><code>[atlanta]
host1
host2

[atlanta:vars]
ntp_server=ntp.atlanta.example.com
proxy=proxy.atlanta.example.com
</code></pre>
<pre><code>atlanta:
  hosts:
    host1:
    host2:
  vars:
    ntp_server: ntp.atlanta.example.com
    proxy: proxy.atlanta.example.com
</code></pre>
</li>
<li>
<p>使用children: 给组分组</p>
<pre><code class="language-yaml">all:
  children:
    usa:
      children:
        southeast:
          children:
            atlanta:
              hosts:
                host1:
                host2:
            raleigh:
              hosts:
                host2:
                host3:
          vars:
            some_server: foo.southeast.example.com
            halon_system_timeout: 30
            self_destruct_countdown: 60
            escape_pods: 2
        northeast:
        northwest:
        southwest:
</code></pre>
</li>
<li>
<p>子组的变量 会覆盖父组的变量</p>
</li>
<li>
<p>主机变量与 组变量 可以定义在如下路径</p>
<pre><code>/etc/ansible/group_vars/raleigh # can optionally end in '.yml', '.yaml', or '.json'
/etc/ansible/group_vars/webservers
/etc/ansible/host_vars/foosball
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述-1"><a class="header" href="#概述-1">概述</a></h1>
<p><a href="https://github.com/ansible/ansible-examples">playBooks 练习</a> </p>
<h1 id="playbook语言示例"><a class="header" href="#playbook语言示例">PlayBook语言示例</a></h1>
<ul>
<li>playbook 由一个或多个 ‘plays’ 组成.它的内容是一个以 ‘plays’ 为元素的列表.</li>
<li>play是由一系列 中的 tasks组成</li>
<li>一个任务是对一个 absinel模块的调用</li>
</ul>
<pre><code class="language-yaml">---
- hosts: webservers
  vars:
    http_port: 80
    max_clients: 200
  remote_user: root
  tasks:
  - name: ensure apache is at the latest version
    yum: pkg=httpd state=latest
  - name: write the apache config file
    template: src=/srv/httpd.j2 dest=/etc/httpd.conf
    notify:
    - restart apache
  - name: ensure apache is running
    service: name=httpd state=started
  handlers:
    - name: restart apache
      service: name=httpd state=restarted
</code></pre>
<h1 id="playbook基础"><a class="header" href="#playbook基础">playbook基础</a></h1>
<h2 id="主机与用户"><a class="header" href="#主机与用户">主机与用户</a></h2>
<p><strong>要执行的主机，与用户</strong></p>
<pre><code class="language-yaml">---
- hosts: webservers
  remote_user: root
</code></pre>
<p><strong>再者,在每一个 task 中,可以定义自己的远程用户:</strong></p>
<pre><code class="language-yaml">---
- hosts: webservers
  remote_user: root
  tasks:
    - name: test connection
      ping:
      remote_user: yourname
</code></pre>
<p><strong>也支持从 sudo 执行命令:</strong></p>
<pre><code class="language-sh">---
- hosts: webservers
  remote_user: yourname
  sudo: yes
</code></pre>
<p>同样的,你可以仅在一个 task 中,使用 sudo 执行命令,而不是在整个 play 中使用 sudo:</p>
<pre><code class="language-sh">---
- hosts: webservers
  remote_user: yourname
  tasks:
    - service: name=nginx state=started
      sudo: yes
</code></pre>
<p>你也可以登陆后,sudo 到不同的用户身份,而不是使用 root:</p>
<pre><code class="language-sh">---
- hosts: webservers
  remote_user: yourname
  sudo: yes
  sudo_user: postgres
</code></pre>
<blockquote>
<p>如果你需要在使用 sudo 时指定密码,可在运行 ansible-playbook 命令时加上选项 <code>--ask-sudo-pass</code> (-K). 如果使用 sudo 时,playbook 疑似被挂起,可能是在 sudo prompt 处被卡住,这时可执行 Control-C 杀死卡住的任务,再重新运行一次.</p>
</blockquote>
<blockquote>
<p>当使用 sudo_user 切换到 非root 用户时,模块的参数会暂时写入 /tmp 目录下的一个随机临时文件. 当命令执行结束后,临时文件立即删除.这种情况发生在普通用户的切换时,比如从 ‘bob’ 切换到 ‘timmy’, 切换到 root 账户时,不会发生,如从 ‘bob’ 切换到 ‘root’,直接以普通用户或root身份登录也不会发生. 如果你不希望这些数据在短暂的时间内可以被读取（不可写）,请避免在 sudo_user 中传递未加密的密码. 其他情况下,’/tmp’ 目录不被使用,这种情况不会发生.Ansible 也有意识的在日志中不记录密码参数.</p>
</blockquote>
<h2 id="tasks-列表"><a class="header" href="#tasks-列表">Tasks 列表</a></h2>
<p>每一个 play 包含了一个 task 列表（任务列表）.一个 task 在其所对应的所有主机上（通过 host pattern 匹配的所有主机）执行完毕之后,下一个 task 才会执行</p>
<p>有一点需要明白的是（很重要）,在一个 play 之中,所有 hosts 会获取相同的任务指令</p>
<p>每个 task 的目标在于执行一个 moudle, 通常是带有特定的参数来执行.在参数中可以使用变量（variables）.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-2"><a class="header" href="#简介-2">简介</a></h1>
<p>在命令行即时输入的命令叫临时命令行 <em>ad-hoc</em>命令</p>
<h1 id="语法格式"><a class="header" href="#语法格式">语法格式</a></h1>
<p><code>ansible [pattern] -m [module] -a &quot;[module options]&quot;</code></p>
<p><code>pattern</code></p>
<p>主机选择模式</p>
<p><code>-m module</code></p>
<p>-m 指定命令模块，默认是 commandModule</p>
<p><code>-a</code> </p>
<p>模块选项</p>
<h1 id="示例"><a class="header" href="#示例">示例</a></h1>
<h2 id="重启"><a class="header" href="#重启">重启</a></h2>
<pre><code class="language-sh"># -fork10个进程来执行
ansible atlanta -a &quot;/sbin/reboot&quot; -f 10

# 默认使用当前用户执行，可以指定用户
ansible atlanta -a &quot;/sbin/reboot&quot; -f 10 -u username //默认以当前用户运行

# --ask-become-pass or -K ：提示密码输入
ansible atlanta -a &quot;/sbin/reboot&quot; -f 10 -u username --become [--ask-become-pass]
</code></pre>
<h1 id="模式"><a class="header" href="#模式">模式</a></h1>
<h2 id="commandmodule"><a class="header" href="#commandmodule">commandModule</a></h2>
<p>command 模块不支持 shell 变量,也不支持管道等 shell 相关的东西</p>
<h2 id="shellmode"><a class="header" href="#shellmode">shellmode</a></h2>
<pre><code class="language-sh">ansible raleigh -m shell -a 'echo $TERM'
</code></pre>
<h2 id="copy-1"><a class="header" href="#copy-1">copy</a></h2>
<blockquote>
<p>从服务主机 copy到 受管理主机</p>
</blockquote>
<pre><code>ansible atlanta -m copy -a &quot;src=/etc/hosts dest=/tmp/hosts&quot;
</code></pre>
<h2 id="文件管理"><a class="header" href="#文件管理">文件管理</a></h2>
<blockquote>
<p>使用 <code>file</code> 模块可以做到修改文件的属主和权限,(在这里可替换为 <code>copy</code> 模块,是等效的):</p>
</blockquote>
<pre><code class="language-sh"># 改变文件 属组
ansible webservers -m file -a &quot;dest=/srv/foo/b.txt mode=600 owner=mdehaan group=mdehaan&quot;
# 新建目录
ansible webservers -m file -a &quot;dest=/path/to/c mode=755 owner=mdehaan group=mdehaan state=directory&quot;
#删除目录和文件
ansible webservers -m file -a &quot;dest=/path/to/c state=absent
</code></pre>
<h2 id="管理包"><a class="header" href="#管理包">管理包</a></h2>
<pre><code class="language-shell">#确认一个软件包已经安装,但不去升级它:
ansible webservers -m yum -a &quot;name=acme state=present&quot;
# 确认一个软件包的安装版本:
ansible webservers -m yum -a &quot;name=acme-1.5 state=present&quot;
#安装最新的包
ansible webservers -m yum -a &quot;name=acme state=latest&quot;
#确认一个软件包还没有安装:
ansible webservers -m yum -a &quot;name=acme state=absent&quot;
</code></pre>
<h2 id="管理用户和组"><a class="header" href="#管理用户和组">管理用户和组</a></h2>
<blockquote>
<p>使用 ‘user’ 模块可以方便的创建账户,删除账户,或是管理现有的账户:</p>
</blockquote>
<pre><code class="language-sh">ansible all -m user -a &quot;name=foo password=&lt;crypted password here&gt;&quot;
ansible all -m user -a &quot;name=foo state=absent&quot;
</code></pre>
<h2 id="从源代码管理中心部署服务"><a class="header" href="#从源代码管理中心部署服务">从源代码管理中心部署服务</a></h2>
<pre><code class="language-sh"># 直接使用 git 部署 webapp:
ansible webservers -m git -a &quot;repo=git://foo.example.org/repo.git dest=/srv/myapp version=HEAD&quot;
</code></pre>
<h2 id="管理服务"><a class="header" href="#管理服务">管理服务</a></h2>
<pre><code class="language-sh"># 确认某个服务在所有的webservers上都已经启动:
ansible webservers -m service -a &quot;name=httpd state=started&quot;
# 或是在所有的webservers上重启某个服务
ansible webservers -m service -a &quot;name=httpd state=restarted&quot;
# 确认某个服务已经停止，如果没有停止则 停止服务：必须是被 systemctl管理的服务
ansible webservers -m service -a &quot;name=httpd state=stopped&quot;
</code></pre>
<h2 id="有时限的后台操作"><a class="header" href="#有时限的后台操作">有时限的后台操作</a></h2>
<pre><code>#  -B 1800 表示最多运行30分钟, -P 60 表示每隔60秒获取一次状态信息.
ansible all -B 3600 -P 0 -a &quot;/usr/bin/long_running_operation --do-stuff&quot;
</code></pre>
<ul>
<li>Polling 获取状态信息的操作会在后台工作任务启动之后开始</li>
<li>你希望所有的工作任务快速启动, <code>--forks</code> 这个选项的值 要设置得足够大,这是前面讲过的并发进程的个数.在运行指定的时间(由<code>-B</code>选项所指定)后,远程节点上的任务进程便会被终止.</li>
</ul>
<h2 id="收集信息"><a class="header" href="#收集信息">收集信息</a></h2>
<pre><code>ansible all -m setup
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ansible-concepts"><a class="header" href="#ansible-concepts"><a href="https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html#ansible-concepts">Ansible concepts</a></a></h1>
<p>这些概念对于Ansible的所有用途都是通用的。您需要了解它们才能将Ansible用于任何类型的自动化。本基本介绍提供了您需要遵循用户指南其余部分的背景。</p>
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html#control-node">Control node</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html#managed-nodes">Managed nodes</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html#inventory">Inventory</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html#collections">Collections</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html#modules">Modules</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html#tasks">Tasks</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html#playbooks">Playbooks</a></li>
</ul>
<h2 id="control-node"><a class="header" href="#control-node"><a href="https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html#id1">Control node</a></a></h2>
<ol>
<li>任何安装了Ansible的机器</li>
<li>您可以通过从任何控制节点调用Ansible或ansible-playbook命令来运行ansible命令和playbook。</li>
<li>您可以使用任何具有Python安装的计算机作为控制节点-笔记本电脑，共享台式机和服务器都可以运行Ansible。</li>
<li>但是，您不能将Windows机器用作控制节点。</li>
<li>您可以有多个控制节点。</li>
</ol>
<h2 id="managed-nodes"><a class="header" href="#managed-nodes"><a href="https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html#id2">Managed nodes</a></a></h2>
<p>您使用Ansible管理的网络设备 (和/或服务器)。托管节点有时也称为 “主机”。Ansible未安装在托管节点上。</p>
<h2 id="inventory-1"><a class="header" href="#inventory-1"><a href="https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html#id3">Inventory</a></a></h2>
<ol>
<li>托管节点列表。inventory file 有时也称为 “hostfile”</li>
<li>您的清单可以为每个托管节点指定像ip地址这样的信息</li>
<li>清单还可以组织托管节点，创建和嵌套组，以便于扩展</li>
<li>详见： <a href="https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html#intro-inventory">the Working with Inventory</a> </li>
</ol>
<h2 id="collections"><a class="header" href="#collections"><a href="https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html#id4">Collections</a></a></h2>
<ol>
<li>
<p>Collections 是Ansible内容的发布格式，可以包括剧本、角色、模块和插件。</p>
</li>
<li>
<p>You can install and use collections through <a href="https://galaxy.ansible.com/">Ansible Galaxy</a>. </p>
</li>
<li>
<p>To learn more about collections, see <a href="https://docs.ansible.com/ansible/latest/user_guide/collections_using.html#collections">Using collections</a>.</p>
</li>
</ol>
<h2 id="modules-1"><a class="header" href="#modules-1"><a href="https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html#id5">Modules</a></a></h2>
<ol>
<li>Ansible执行的代码单位</li>
<li>每个模块都有特定的用途，从在特定类型的数据库上管理用户到在特定类型的网络设备上管理VLAN接口</li>
<li>您可以使用任务调用单个模块，或者在剧本中调用几个不同的模块</li>
<li>从Ansible 2.10开始，模块在集合中分组</li>
<li>关于Ansible包括多少个collections，详见 <a href="https://docs.ansible.com/ansible/latest/collections/index.html#list-of-collections">Collection Index</a>.</li>
</ol>
<h2 id="tasks-1"><a class="header" href="#tasks-1"><a href="https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html#id6">Tasks</a></a></h2>
<p>Ansible中的行动单位。您可以使用临时命令执行一次单个任务。</p>
<h2 id="playbooks-1"><a class="header" href="#playbooks-1"><a href="https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html#id7">Playbooks</a></a></h2>
<ol>
<li>
<p>已保存的任务顺序列表，以便您可以按该顺序重复运行这些任务</p>
</li>
<li>
<p>剧本可以包括变量和任务。</p>
</li>
<li>
<p>剧本用YAML编写，易于阅读，写作，分享和理解</p>
</li>
<li>
<p>详见： <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_intro.html#about-playbooks">Intro to playbooks</a>.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ansiblebuiltin"><a class="header" href="#ansiblebuiltin"><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/index.html#ansible-builtin">Ansible.Builtin</a></a></h1>
<p>Collection version 2.12.6.post0</p>
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/index.html#description">Description</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/index.html#communication">Communication</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/index.html#plugin-index">Plugin Index</a></li>
</ul>
<h2 id="description"><a class="header" href="#description"><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/index.html#id1">Description</a></a></h2>
<p>这些都是ansible-core中包含的所有模块和插件。</p>
<p><strong>Author:</strong></p>
<ul>
<li>Ansible, Inc.</li>
</ul>
<p><a href="https://github.com/ansible/ansible/issues">Issue Tracker</a><a href="https://github.com/ansible/ansible">Repository (Sources)</a></p>
<h2 id="communication"><a class="header" href="#communication"><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/index.html#id2">Communication</a></a></h2>
<ul>
<li>Matrix room <code>#users:ansible.im</code>: <a href="https://matrix.to/#/#users:ansible.im">General usage and support questions</a>.</li>
<li>IRC channel <code>#ansible</code> (Libera network): <a href="https://web.libera.chat/?channel=#ansible">General usage and support questions</a>.</li>
<li>Mailing list: <a href="https://groups.google.com/g/ansible-project">Ansible Project List</a>. (<a href="mailto:ansible-project+subscribe@googlegroups.com?subject=subscribe">Subscribe</a>)</li>
</ul>
<h2 id="plugin-index"><a class="header" href="#plugin-index"><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/index.html#id3">Plugin Index</a></a></h2>
<p>这些是ansible.builtin集合中的插件:</p>
<h3 id="modules-2"><a class="header" href="#modules-2">Modules<a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/index.html#modules"></a></a></h3>
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/add_host_module.html#ansible-collections-ansible-builtin-add-host-module">add_host module</a> – Add a host (and alternatively a group) to the ansible-playbook in-memory inventory</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/apt_module.html#ansible-collections-ansible-builtin-apt-module">apt module</a> – Manages apt-packages</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/apt_key_module.html#ansible-collections-ansible-builtin-apt-key-module">apt_key module</a> – Add or remove an apt key</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/apt_repository_module.html#ansible-collections-ansible-builtin-apt-repository-module">apt_repository module</a> – Add and remove APT repositories</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/assemble_module.html#ansible-collections-ansible-builtin-assemble-module">assemble module</a> – Assemble configuration files from fragments</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/assert_module.html#ansible-collections-ansible-builtin-assert-module">assert module</a> – Asserts given expressions are true</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/async_status_module.html#ansible-collections-ansible-builtin-async-status-module">async_status module</a> – Obtain status of asynchronous task</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/blockinfile_module.html#ansible-collections-ansible-builtin-blockinfile-module">blockinfile module</a> – Insert/update/remove a text block surrounded by marker lines</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/command_module.html#ansible-collections-ansible-builtin-command-module">command module</a> – Execute commands on targets</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/copy_module.html#ansible-collections-ansible-builtin-copy-module">copy module</a> – Copy files to remote locations</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/cron_module.html#ansible-collections-ansible-builtin-cron-module">cron module</a> – Manage cron.d and crontab entries</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/debconf_module.html#ansible-collections-ansible-builtin-debconf-module">debconf module</a> – Configure a .deb package</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/debug_module.html#ansible-collections-ansible-builtin-debug-module">debug module</a> – Print statements during execution</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/dnf_module.html#ansible-collections-ansible-builtin-dnf-module">dnf module</a> – Manages packages with the <em>dnf</em> package manager</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/dpkg_selections_module.html#ansible-collections-ansible-builtin-dpkg-selections-module">dpkg_selections module</a> – Dpkg package selection selections</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/expect_module.html#ansible-collections-ansible-builtin-expect-module">expect module</a> – Executes a command and responds to prompts</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/fail_module.html#ansible-collections-ansible-builtin-fail-module">fail module</a> – Fail with custom message</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/fetch_module.html#ansible-collections-ansible-builtin-fetch-module">fetch module</a> – Fetch files from remote nodes</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/file_module.html#ansible-collections-ansible-builtin-file-module">file module</a> – Manage files and file properties</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/find_module.html#ansible-collections-ansible-builtin-find-module">find module</a> – Return a list of files based on specific criteria</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/gather_facts_module.html#ansible-collections-ansible-builtin-gather-facts-module">gather_facts module</a> – Gathers facts about remote hosts</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/get_url_module.html#ansible-collections-ansible-builtin-get-url-module">get_url module</a> – Downloads files from HTTP, HTTPS, or FTP to node</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/getent_module.html#ansible-collections-ansible-builtin-getent-module">getent module</a> – A wrapper to the unix getent utility</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/git_module.html#ansible-collections-ansible-builtin-git-module">git module</a> – Deploy software (or files) from git checkouts</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/group_module.html#ansible-collections-ansible-builtin-group-module">group module</a> – Add or remove groups</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/group_by_module.html#ansible-collections-ansible-builtin-group-by-module">group_by module</a> – Create Ansible groups based on facts</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/hostname_module.html#ansible-collections-ansible-builtin-hostname-module">hostname module</a> – Manage hostname</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/import_playbook_module.html#ansible-collections-ansible-builtin-import-playbook-module">import_playbook module</a> – Import a playbook</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/import_role_module.html#ansible-collections-ansible-builtin-import-role-module">import_role module</a> – Import a role into a play</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/import_tasks_module.html#ansible-collections-ansible-builtin-import-tasks-module">import_tasks module</a> – Import a task list</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/include_module.html#ansible-collections-ansible-builtin-include-module">include module</a> – Include a play or task list</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/include_role_module.html#ansible-collections-ansible-builtin-include-role-module">include_role module</a> – Load and execute a role</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/include_tasks_module.html#ansible-collections-ansible-builtin-include-tasks-module">include_tasks module</a> – Dynamically include a task list</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/include_vars_module.html#ansible-collections-ansible-builtin-include-vars-module">include_vars module</a> – Load variables from files, dynamically within a task</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/iptables_module.html#ansible-collections-ansible-builtin-iptables-module">iptables module</a> – Modify iptables rules</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/known_hosts_module.html#ansible-collections-ansible-builtin-known-hosts-module">known_hosts module</a> – Add or remove a host from the <code>known_hosts</code> file</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/lineinfile_module.html#ansible-collections-ansible-builtin-lineinfile-module">lineinfile module</a> – Manage lines in text files</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/meta_module.html#ansible-collections-ansible-builtin-meta-module">meta module</a> – Execute Ansible ‘actions’</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/package_module.html#ansible-collections-ansible-builtin-package-module">package module</a> – Generic OS package manager</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/package_facts_module.html#ansible-collections-ansible-builtin-package-facts-module">package_facts module</a> – Package information as facts</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/pause_module.html#ansible-collections-ansible-builtin-pause-module">pause module</a> – Pause playbook execution</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/ping_module.html#ansible-collections-ansible-builtin-ping-module">ping module</a> – Try to connect to host, verify a usable python and return <code>pong</code> on success</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/pip_module.html#ansible-collections-ansible-builtin-pip-module">pip module</a> – Manages Python library dependencies</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/raw_module.html#ansible-collections-ansible-builtin-raw-module">raw module</a> – Executes a low-down and dirty command</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/reboot_module.html#ansible-collections-ansible-builtin-reboot-module">reboot module</a> – Reboot a machine</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/replace_module.html#ansible-collections-ansible-builtin-replace-module">replace module</a> – Replace all instances of a particular string in a file using a back-referenced regular expression</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/rpm_key_module.html#ansible-collections-ansible-builtin-rpm-key-module">rpm_key module</a> – Adds or removes a gpg key from the rpm db</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/script_module.html#ansible-collections-ansible-builtin-script-module">script module</a> – Runs a local script on a remote node after transferring it</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/service_module.html#ansible-collections-ansible-builtin-service-module">service module</a> – Manage services</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/service_facts_module.html#ansible-collections-ansible-builtin-service-facts-module">service_facts module</a> – Return service state information as fact data</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/set_fact_module.html#ansible-collections-ansible-builtin-set-fact-module">set_fact module</a> – Set host variable(s) and fact(s).</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/set_stats_module.html#ansible-collections-ansible-builtin-set-stats-module">set_stats module</a> – Define and display stats for the current ansible run</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/setup_module.html#ansible-collections-ansible-builtin-setup-module">setup module</a> – Gathers facts about remote hosts</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/shell_module.html#ansible-collections-ansible-builtin-shell-module">shell module</a> – Execute shell commands on targets</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/slurp_module.html#ansible-collections-ansible-builtin-slurp-module">slurp module</a> – Slurps a file from remote nodes</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/stat_module.html#ansible-collections-ansible-builtin-stat-module">stat module</a> – Retrieve file or file system status</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/subversion_module.html#ansible-collections-ansible-builtin-subversion-module">subversion module</a> – Deploys a subversion repository</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/systemd_module.html#ansible-collections-ansible-builtin-systemd-module">systemd module</a> – Manage systemd units</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/sysvinit_module.html#ansible-collections-ansible-builtin-sysvinit-module">sysvinit module</a> – Manage SysV services.</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/tempfile_module.html#ansible-collections-ansible-builtin-tempfile-module">tempfile module</a> – Creates temporary files and directories</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/template_module.html#ansible-collections-ansible-builtin-template-module">template module</a> – Template a file out to a target host</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/unarchive_module.html#ansible-collections-ansible-builtin-unarchive-module">unarchive module</a> – Unpacks an archive after (optionally) copying it from the local machine</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/uri_module.html#ansible-collections-ansible-builtin-uri-module">uri module</a> – Interacts with webservices</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/user_module.html#ansible-collections-ansible-builtin-user-module">user module</a> – Manage user accounts</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/validate_argument_spec_module.html#ansible-collections-ansible-builtin-validate-argument-spec-module">validate_argument_spec module</a> – Validate role argument specs.</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/wait_for_module.html#ansible-collections-ansible-builtin-wait-for-module">wait_for module</a> – Waits for a condition before continuing</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/wait_for_connection_module.html#ansible-collections-ansible-builtin-wait-for-connection-module">wait_for_connection module</a> – Waits until remote system is reachable/usable</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/yum_module.html#ansible-collections-ansible-builtin-yum-module">yum module</a> – Manages packages with the <em>yum</em> package manager</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/yum_repository_module.html#ansible-collections-ansible-builtin-yum-repository-module">yum_repository module</a> – Add or remove YUM repositories</li>
</ul>
<h3 id="become-plugins"><a class="header" href="#become-plugins">Become Plugins<a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/index.html#become-plugins"></a></a></h3>
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/runas_become.html#ansible-collections-ansible-builtin-runas-become">runas become</a> – Run As user</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/su_become.html#ansible-collections-ansible-builtin-su-become">su become</a> – Substitute User</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/sudo_become.html#ansible-collections-ansible-builtin-sudo-become">sudo become</a> – Substitute User DO</li>
</ul>
<h3 id="cache-plugins"><a class="header" href="#cache-plugins">Cache Plugins<a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/index.html#cache-plugins"></a></a></h3>
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/jsonfile_cache.html#ansible-collections-ansible-builtin-jsonfile-cache">jsonfile cache</a> – JSON formatted files.</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/memory_cache.html#ansible-collections-ansible-builtin-memory-cache">memory cache</a> – RAM backed, non persistent</li>
</ul>
<h3 id="callback-plugins"><a class="header" href="#callback-plugins">Callback Plugins<a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/index.html#callback-plugins"></a></a></h3>
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/default_callback.html#ansible-collections-ansible-builtin-default-callback">default callback</a> – default Ansible screen output</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/junit_callback.html#ansible-collections-ansible-builtin-junit-callback">junit callback</a> – write playbook output to a JUnit file.</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/minimal_callback.html#ansible-collections-ansible-builtin-minimal-callback">minimal callback</a> – minimal Ansible screen output</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/oneline_callback.html#ansible-collections-ansible-builtin-oneline-callback">oneline callback</a> – oneline Ansible screen output</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/tree_callback.html#ansible-collections-ansible-builtin-tree-callback">tree callback</a> – Save host events to files</li>
</ul>
<h3 id="connection-plugins"><a class="header" href="#connection-plugins">Connection Plugins<a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/index.html#connection-plugins"></a></a></h3>
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/local_connection.html#ansible-collections-ansible-builtin-local-connection">local connection</a> – execute on controller</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/paramiko_ssh_connection.html#ansible-collections-ansible-builtin-paramiko-ssh-connection">paramiko_ssh connection</a> – Run tasks via python ssh (paramiko)</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/psrp_connection.html#ansible-collections-ansible-builtin-psrp-connection">psrp connection</a> – Run tasks over Microsoft PowerShell Remoting Protocol</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/ssh_connection.html#ansible-collections-ansible-builtin-ssh-connection">ssh connection</a> – connect via SSH client binary</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/winrm_connection.html#ansible-collections-ansible-builtin-winrm-connection">winrm connection</a> – Run tasks over Microsoft’s WinRM</li>
</ul>
<h3 id="inventory-plugins"><a class="header" href="#inventory-plugins">Inventory Plugins<a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/index.html#inventory-plugins"></a></a></h3>
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/advanced_host_list_inventory.html#ansible-collections-ansible-builtin-advanced-host-list-inventory">advanced_host_list inventory</a> – Parses a ‘host list’ with ranges</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/auto_inventory.html#ansible-collections-ansible-builtin-auto-inventory">auto inventory</a> – Loads and executes an inventory plugin specified in a YAML config</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/constructed_inventory.html#ansible-collections-ansible-builtin-constructed-inventory">constructed inventory</a> – Uses Jinja2 to construct vars and groups based on existing inventory.</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/generator_inventory.html#ansible-collections-ansible-builtin-generator-inventory">generator inventory</a> – Uses Jinja2 to construct hosts and groups from patterns</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/host_list_inventory.html#ansible-collections-ansible-builtin-host-list-inventory">host_list inventory</a> – Parses a ‘host list’ string</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/ini_inventory.html#ansible-collections-ansible-builtin-ini-inventory">ini inventory</a> – Uses an Ansible INI file as inventory source.</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/script_inventory.html#ansible-collections-ansible-builtin-script-inventory">script inventory</a> – Executes an inventory script that returns JSON</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/toml_inventory.html#ansible-collections-ansible-builtin-toml-inventory">toml inventory</a> – Uses a specific TOML file as an inventory source.</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/yaml_inventory.html#ansible-collections-ansible-builtin-yaml-inventory">yaml inventory</a> – Uses a specific YAML file as an inventory source.</li>
</ul>
<h3 id="lookup-plugins"><a class="header" href="#lookup-plugins">Lookup Plugins<a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/index.html#lookup-plugins"></a></a></h3>
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/config_lookup.html#ansible-collections-ansible-builtin-config-lookup">config lookup</a> – Lookup current Ansible configuration values</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/csvfile_lookup.html#ansible-collections-ansible-builtin-csvfile-lookup">csvfile lookup</a> – read data from a TSV or CSV file</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/dict_lookup.html#ansible-collections-ansible-builtin-dict-lookup">dict lookup</a> – returns key/value pair items from dictionaries</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/env_lookup.html#ansible-collections-ansible-builtin-env-lookup">env lookup</a> – Read the value of environment variables</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/file_lookup.html#ansible-collections-ansible-builtin-file-lookup">file lookup</a> – read file contents</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/fileglob_lookup.html#ansible-collections-ansible-builtin-fileglob-lookup">fileglob lookup</a> – list files matching a pattern</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/first_found_lookup.html#ansible-collections-ansible-builtin-first-found-lookup">first_found lookup</a> – return first file found from list</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/indexed_items_lookup.html#ansible-collections-ansible-builtin-indexed-items-lookup">indexed_items lookup</a> – rewrites lists to return ‘indexed items’</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/ini_lookup.html#ansible-collections-ansible-builtin-ini-lookup">ini lookup</a> – read data from a ini file</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/inventory_hostnames_lookup.html#ansible-collections-ansible-builtin-inventory-hostnames-lookup">inventory_hostnames lookup</a> – list of inventory hosts matching a host pattern</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/items_lookup.html#ansible-collections-ansible-builtin-items-lookup">items lookup</a> – list of items</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/lines_lookup.html#ansible-collections-ansible-builtin-lines-lookup">lines lookup</a> – read lines from command</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/list_lookup.html#ansible-collections-ansible-builtin-list-lookup">list lookup</a> – simply returns what it is given.</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/nested_lookup.html#ansible-collections-ansible-builtin-nested-lookup">nested lookup</a> – composes a list with nested elements of other lists</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/password_lookup.html#ansible-collections-ansible-builtin-password-lookup">password lookup</a> – retrieve or generate a random password, stored in a file</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/pipe_lookup.html#ansible-collections-ansible-builtin-pipe-lookup">pipe lookup</a> – read output from a command</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/random_choice_lookup.html#ansible-collections-ansible-builtin-random-choice-lookup">random_choice lookup</a> – return random element from list</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/sequence_lookup.html#ansible-collections-ansible-builtin-sequence-lookup">sequence lookup</a> – generate a list based on a number sequence</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/subelements_lookup.html#ansible-collections-ansible-builtin-subelements-lookup">subelements lookup</a> – traverse nested key from a list of dictionaries</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/template_lookup.html#ansible-collections-ansible-builtin-template-lookup">template lookup</a> – retrieve contents of file after templating with Jinja2</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/together_lookup.html#ansible-collections-ansible-builtin-together-lookup">together lookup</a> – merges lists into synchronized list</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/unvault_lookup.html#ansible-collections-ansible-builtin-unvault-lookup">unvault lookup</a> – read vaulted file(s) contents</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/url_lookup.html#ansible-collections-ansible-builtin-url-lookup">url lookup</a> – return contents from URL</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/varnames_lookup.html#ansible-collections-ansible-builtin-varnames-lookup">varnames lookup</a> – Lookup matching variable names</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/vars_lookup.html#ansible-collections-ansible-builtin-vars-lookup">vars lookup</a> – Lookup templated value of variables</li>
</ul>
<h3 id="shell-plugins"><a class="header" href="#shell-plugins">Shell Plugins<a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/index.html#shell-plugins"></a></a></h3>
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/cmd_shell.html#ansible-collections-ansible-builtin-cmd-shell">cmd shell</a> – Windows Command Prompt</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/powershell_shell.html#ansible-collections-ansible-builtin-powershell-shell">powershell shell</a> – Windows PowerShell</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/sh_shell.html#ansible-collections-ansible-builtin-sh-shell">sh shell</a> – POSIX shell (/bin/sh)</li>
</ul>
<h3 id="strategy-plugins"><a class="header" href="#strategy-plugins">Strategy Plugins<a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/index.html#strategy-plugins"></a></a></h3>
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/debug_strategy.html#ansible-collections-ansible-builtin-debug-strategy">debug strategy</a> – Executes tasks in interactive debug session.</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/free_strategy.html#ansible-collections-ansible-builtin-free-strategy">free strategy</a> – Executes tasks without waiting for all hosts</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/host_pinned_strategy.html#ansible-collections-ansible-builtin-host-pinned-strategy">host_pinned strategy</a> – Executes tasks on each host without interruption</li>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/linear_strategy.html#ansible-collections-ansible-builtin-linear-strategy">linear strategy</a> – Executes tasks in a linear fashion</li>
</ul>
<h3 id="vars-plugins"><a class="header" href="#vars-plugins">Vars Plugins<a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/index.html#vars-plugins"></a></a></h3>
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/host_group_vars_vars.html#ansible-collections-ansible-builtin-host-group-vars-vars">host_group_vars vars</a> – In charge of loading group_vars and host_vars</li>
</ul>
<p>List of <a href="https://docs.ansible.com/ansible/latest/collections/index.html#list-of-collections">collections</a> with docs hosted here.</p>
<p><a href="https://docs.ansible.com/ansible/latest/collections/ansible/index.html"> Previous</a><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/runas_become.html">Next </a></p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="ansiblebuiltincommand-module--execute-commands-on-targets"><a class="header" href="#ansiblebuiltincommand-module--execute-commands-on-targets"><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/command_module.html#ansible-builtin-command-module-execute-commands-on-targets">ansible.builtin.command module – Execute commands on targets</a></a></h3>
<ol>
<li>位于 <code>ansible-core</code> </li>
<li>可以直接指定 <code>command</code> 不用 <code>collections:</code>  关键字</li>
<li>推荐使用 FQCN。避免命名冲突</li>
</ol>
<h3 id="synopsis"><a class="header" href="#synopsis"><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/command_module.html#id1">Synopsis</a></a></h3>
<ul>
<li>命令模块  采用 命令名称，后跟空格分隔的参数列表。</li>
<li>给定的命令将在所有选定的节点上执行。</li>
<li>命令不会通过shell处理，因此变量 (如 $HOSTNAME) 和 操作符 &quot;*&quot;<code>, </code>&quot;&lt;&quot;<code>, </code>&quot;&gt;&quot;<code>, </code>&quot;|&quot;<code>, </code>&quot;;&quot;<code>and</code>&quot;&amp;&quot; 不会被处理。如果需要使用<a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/shell_module.html#ansible-collections-ansible-builtin-shell-module">ansible.builtin.shell</a> 模块</li>
<li>创建 command tasks 比使用空格分隔参数的任务更容易阅读，  使用 args 或者cmd 传递参数</li>
<li>自由格式命令 或 cmd参数，请参见示例。</li>
<li>对于Windows目标， use the <a href="https://docs.ansible.com/ansible/latest/collections/ansible/windows/win_command_module.html#ansible-collections-ansible-windows-win-command-module">ansible.windows.win_command</a> module instead.</li>
</ul>
<p>This module has a corresponding <a href="https://docs.ansible.com/ansible/latest/plugins/action.html#action-plugins">action plugin</a>.</p>
<h3 id="parameters"><a class="header" href="#parameters"><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/command_module.html#id2">Parameters</a></a></h3>
<table><thead><tr><th>Parameter</th><th>Comments</th></tr></thead><tbody>
<tr><td><strong>argv</strong> list / elements=string<em>added in 2.6 of ansible.builtin</em></td><td>1. 将命令作为列表而不是字符串传递<br />2. argv可以避免转义<br />3. 自由格式或者 argv 必须二者提供其一</td></tr>
<tr><td><strong>chdir</strong> path<em>added in 0.6 of ansible.builtin</em></td><td>切换工作目录</td></tr>
<tr><td><strong>cmd</strong> string</td><td>执行的命令</td></tr>
<tr><td><strong>creates</strong> path</td><td>1. 文件名或 (自2.0起) glob模式<br />2. 如果已经存在匹配的文件，则不会运行此步骤.<br />3.  在 <em>removes</em> 检查 前</td></tr>
<tr><td><strong>free_form</strong> string</td><td>1. 命令模块将一个自由形式的字符串作为命令运行.<br />2. 类似于 <em>modulename: cmdstr</em></td></tr>
<tr><td><strong>removes</strong> path<em>added in 0.8 of ansible.builtin</em></td><td>1. 文件名或 (自2.0起) glob模式<br />2. 如果已经存在匹配的文件，则会运行此步骤.<br />3. This is checked after <em>creates</em> is checked.</td></tr>
<tr><td><strong>stdin</strong> string<em>added in 2.4 of ansible.builtin</em></td><td>将命令的stdin 直接设置为指定值。</td></tr>
<tr><td><strong>stdin_add_newline</strong> boolean<em>added in 2.8 of ansible.builtin</em></td><td>If set to <code>yes</code>, append a newline to stdin data.<br /><strong>Choices:</strong><br />no<br /><strong>yes</strong> ← (default)</td></tr>
<tr><td><strong>strip_empty_ends</strong> boolean<em>added in 2.8 of ansible.builtin</em></td><td>Strip empty lines from the end of stdout/stderr in result<br /><strong>Choices:</strong><br />no<br /><strong>yes</strong> ← (default)</td></tr>
<tr><td><strong>warn</strong> boolean<em>added in 1.8 of ansible.builtin</em></td><td>(deprecated) Enable or disable task warnings.This feature is deprecated and will be removed in 2.14.As of version 2.11, this option is now disabled by default.**Choices:**<strong>no</strong> ← (default)yes</td></tr>
</tbody></table>
<h3 id="see-also-1"><a class="header" href="#see-also-1"><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/command_module.html#id5">See Also</a></a></h3>
<ul>
<li>
<p><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/raw_module.html#ansible-collections-ansible-builtin-raw-module">ansible.builtin.raw</a></p>
<p>The official documentation on the <strong>ansible.builtin.raw</strong> module.</p>
</li>
<li>
<p><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/script_module.html#ansible-collections-ansible-builtin-script-module">ansible.builtin.script</a></p>
<p>The official documentation on the <strong>ansible.builtin.script</strong> module.</p>
</li>
<li>
<p><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/shell_module.html#ansible-collections-ansible-builtin-shell-module">ansible.builtin.shell</a></p>
<p>The official documentation on the <strong>ansible.builtin.shell</strong> module.</p>
</li>
<li>
<p><a href="https://docs.ansible.com/ansible/latest/collections/ansible/windows/win_command_module.html#ansible-collections-ansible-windows-win-command-module">ansible.windows.win_command</a></p>
<p>The official documentation on the <strong>ansible.windows.win_command</strong> module.</p>
</li>
</ul>
<h3 id="examples"><a class="header" href="#examples"><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/command_module.html#id6">Examples</a></a></h3>
<pre><code class="language-yaml">- name: Return motd to registered var
  ansible.builtin.command: cat /etc/motd
  register: mymotd
  
  
# free-form (string) arguments, all arguments on one line
- name: Run command if /path/to/database does not exist (without 'args')
  ansible.builtin.command: /usr/bin/make_database.sh db_user db_name creates=/path/to/database
  
# free-form (string) arguments, some arguments on separate lines with the 'args' keyword
# 'args' is a task keyword, passed at the same level as the module
- name: Run command if /path/to/database does not exist (with 'args' keyword)
  ansible.builtin.command: /usr/bin/make_database.sh db_user db_name
  args:
    creates: /path/to/database
    
    
# 'cmd' is module parameter
- name: Run command if /path/to/database does not exist (with 'cmd' parameter)
  ansible.builtin.command:
    cmd: /usr/bin/make_database.sh db_user db_name
    creates: /path/to/database
    
- name: Change the working directory to somedir/ and run the command as db_owner if /path/to/database does not exist
  ansible.builtin.command: /usr/bin/make_database.sh db_user db_name
  become: yes
  become_user: db_owner
  args:
    chdir: somedir/
    creates: /path/to/database
    
# argv (list) arguments, each argument on a separate line, 'args' keyword not necessary
# 'argv' is a parameter, indented one level from the module
- name: Use 'argv' to send a command as a list - leave 'command' empty
  ansible.builtin.command:
    argv:
      - /usr/bin/make_database.sh
      - Username with whitespace
      - dbname with whitespace
    creates: /path/to/database

- name: Safely use templated variable to run command. Always use the quote filter to avoid injection issues
  ansible.builtin.command: cat {{ myfile|quote }}
  register: myoutput

</code></pre>
<h2 id="return-values"><a class="header" href="#return-values"><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/command_module.html#id7">Return Values</a></a></h2>
<table><thead><tr><th>Key</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>cmd</strong> list / elements=string</td><td>The command executed by the task.<br /><strong>Returned:</strong> always<br /><strong>Sample:</strong> [“echo”, “hello”]</td></tr>
<tr><td><strong>delta</strong> string</td><td>The command execution delta time.<br /><strong>Returned:</strong> always<br /><strong>Sample:</strong> “0:00:00.001529”</td></tr>
<tr><td><strong>end</strong> string</td><td>The command execution end time.<br /><strong>Returned:</strong> always<br /><strong>Sample:</strong> “2017-09-29 22:03:48.084657”</td></tr>
<tr><td><strong>msg</strong> boolean</td><td>changed<br /><strong>Returned:</strong> always<br /><strong>Sample:</strong> true</td></tr>
<tr><td><strong>rc</strong> integer</td><td>The command return code (0 means success).<br /><strong>Returned:</strong> always<br /><strong>Sample:</strong> 0</td></tr>
<tr><td><strong>start</strong> string</td><td>The command execution start time.<br /><strong>Returned:</strong> always<br /><strong>Sample:</strong> “2017-09-29 22:03:48.083128”</td></tr>
<tr><td><strong>stderr</strong> string</td><td>The command standard error.<br /><strong>Returned:</strong> always<br /><strong>Sample:</strong> “ls cannot access foo: No such file or directory”</td></tr>
<tr><td><strong>stderr_lines</strong> list / elements=string</td><td>The command standard error split in lines.<br /><strong>Returned:</strong> always<br /><strong>Sample:</strong> [{“u\u0027ls cannot access foo”: “No such file or directory\u0027”}, “u\u0027ls \u2026\u0027”]</td></tr>
<tr><td><strong>stdout</strong> string</td><td>The command standard output.<br /><strong>Returned:</strong> always<br /><strong>Sample:</strong> “Clustering node <a href="mailto:rabbit@slave1">rabbit@slave1</a> with <a href="mailto:rabbit@master">rabbit@master</a> \u2026”</td></tr>
<tr><td><strong>stdout_lines</strong> list / elements=string</td><td>The command standard output split in lines.<br /><strong>Returned:</strong> always<br /><strong>Sample:</strong> [“u\u0027Clustering node <a href="mailto:rabbit@slave1">rabbit@slave1</a> with <a href="mailto:rabbit@master">rabbit@master</a> \u2026\u0027”]</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h3 id="ansiblebuiltinshell-module--execute-shell-commands-on-targets"><a class="header" href="#ansiblebuiltinshell-module--execute-shell-commands-on-targets">ansible.builtin.shell module – Execute shell commands on targets</a></h3>
<ol>
<li>位于 <code>ansible-core</code> </li>
<li>可以直接指定 <code>command</code> 不用 <code>collections:</code>  关键字</li>
<li>推荐使用 FQCN。避免命名冲突</li>
</ol>
<h3 id="synopsis-1"><a class="header" href="#synopsis-1"><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/shell_module.html#id1">Synopsis</a></a></h3>
<ul>
<li>执行shell命令</li>
</ul>
<ul>
<li>可以使用 <em>free-form</em> 格式指定</li>
<li>类似 <a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/command_module.html#ansible-collections-ansible-builtin-command-module">ansible.builtin.command</a> ，但使用 (<code>/bin/sh</code>) 执行</li>
<li>For Windows targets, use the <a href="https://docs.ansible.com/ansible/latest/collections/ansible/windows/win_shell_module.html#ansible-collections-ansible-windows-win-shell-module">ansible.windows.win_shell</a> module instead.</li>
</ul>
<h2 id="parameters-1"><a class="header" href="#parameters-1"><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/shell_module.html#id2">Parameters</a></a></h2>
<table><thead><tr><th>Parameter</th><th>Comments</th></tr></thead><tbody>
<tr><td><strong>chdir</strong> path<em>added in 0.6 of ansible.builtin</em></td><td>Change into this directory before running the command.</td></tr>
<tr><td><strong>cmd</strong> string</td><td>The command to run followed by optional arguments.</td></tr>
<tr><td><strong>creates</strong> path</td><td>A filename, when it already exists, this step will <strong>not</strong> be run.</td></tr>
<tr><td><strong>executable</strong> path<em>added in 0.9 of ansible.builtin</em></td><td>Change the shell used to execute the command.This expects an absolute path to the executable.</td></tr>
<tr><td><strong>free_form</strong> string</td><td>The shell module takes a free form command to run, as a string.There is no actual parameter named ‘free form’.See the examples on how to use this module.</td></tr>
<tr><td><strong>removes</strong> path<em>added in 0.8 of ansible.builtin</em></td><td>A filename, when it does not exist, this step will <strong>not</strong> be run.</td></tr>
<tr><td><strong>stdin</strong> string<em>added in 2.4 of ansible.builtin</em></td><td>Set the stdin of the command directly to the specified value.</td></tr>
<tr><td><strong>stdin_add_newline</strong> boolean<em>added in 2.8 of ansible.builtin</em></td><td>Whether to append a newline to stdin data.<strong>Choices:<strong>no</strong>yes</strong> ← (default)</td></tr>
<tr><td><strong>warn</strong> boolean<em>added in 1.8 of ansible.builtin</em></td><td>Whether to enable task warnings.<strong>Choices:<strong>no</strong>yes</strong> ← (default)</td></tr>
</tbody></table>
<h2 id="attributes"><a class="header" href="#attributes"><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/shell_module.html#id3">Attributes</a></a></h2>
<table><thead><tr><th>Attribute</th><th>Support</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>check_mode</strong></td><td><strong>partial</strong><br />while the command itself is arbitrary and cannot be subject to the check mode semantics it adds <code>creates</code>/<code>removes</code> options as a workaround</td><td>Can run in check_mode and return changed status prediction withought modifying target</td></tr>
<tr><td><strong>diff_mode</strong></td><td><strong>none</strong></td><td>Will return details on what has changed (or possibly needs changing in check_mode), when in diff mode</td></tr>
<tr><td><strong>platform</strong></td><td><strong>Platform:</strong> <strong>posix</strong></td><td>Target OS/families that can be operated against</td></tr>
<tr><td><strong>raw</strong></td><td><strong>full</strong></td><td>Indicates if an action takes a ‘raw’ or ‘free form’ string as an option and has it’s own special parsing of it</td></tr>
</tbody></table>
<h3 id="注意"><a class="header" href="#注意">注意</a></h3>
<ul>
<li>如果您想安全且可预测地执行命令, it may be better to use the <a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/command_module.html#ansible-collections-ansible-builtin-command-module">ansible.builtin.command</a> module instead. Best practices when writing playbooks will follow the trend of using <a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/command_module.html#ansible-collections-ansible-builtin-command-module">ansible.builtin.command</a> unless the <a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/shell_module.html#ansible-collections-ansible-builtin-shell-module">ansible.builtin.shell</a> module is explicitly required. When running ad-hoc commands, use your best judgement.</li>
<li>To sanitize any variables passed to the shell module, you should use <code>{{ var | quote }}</code> instead of just <code>{{ var }}</code> to make sure they do not include evil things like semicolons.</li>
<li>An alternative to using inline shell scripts with this module is to use the <a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/script_module.html#ansible-collections-ansible-builtin-script-module">ansible.builtin.script</a> module possibly together with the <a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/template_module.html#ansible-collections-ansible-builtin-template-module">ansible.builtin.template</a> module.</li>
<li>For rebooting systems, use the <a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/reboot_module.html#ansible-collections-ansible-builtin-reboot-module">ansible.builtin.reboot</a> or <a href="https://docs.ansible.com/ansible/latest/collections/ansible/windows/win_reboot_module.html#ansible-collections-ansible-windows-win-reboot-module">ansible.windows.win_reboot</a> module.</li>
</ul>
<h3 id="see-also-2"><a class="header" href="#see-also-2"><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/shell_module.html#id5">See Also</a></a></h3>
<ul>
<li>
<p><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/command_module.html#ansible-collections-ansible-builtin-command-module">ansible.builtin.command</a></p>
<p>The official documentation on the <strong>ansible.builtin.command</strong> module.</p>
</li>
<li>
<p><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/raw_module.html#ansible-collections-ansible-builtin-raw-module">ansible.builtin.raw</a></p>
<p>The official documentation on the <strong>ansible.builtin.raw</strong> module.</p>
</li>
<li>
<p><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/script_module.html#ansible-collections-ansible-builtin-script-module">ansible.builtin.script</a></p>
<p>The official documentation on the <strong>ansible.builtin.script</strong> module.</p>
</li>
<li>
<p><a href="https://docs.ansible.com/ansible/latest/collections/ansible/windows/win_shell_module.html#ansible-collections-ansible-windows-win-shell-module">ansible.windows.win_shell</a></p>
<p>The official documentation on the <strong>ansible.windows.win_shell</strong> module.</p>
</li>
</ul>
<h3 id="examples-1"><a class="header" href="#examples-1"><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/shell_module.html#id6">Examples</a></a></h3>
<pre><code class="language-yaml">- name: Execute the command in remote shell; stdout goes to the specified file on the remote
  ansible.builtin.shell: somescript.sh &gt;&gt; somelog.txt
  

- name: Change the working directory to somedir/ before executing the command
  ansible.builtin.shell: somescript.sh &gt;&gt; somelog.txt
  args:
  chdir: somedir/
  
 
 # You can also use the 'args' form to provide the options.
- name: This command will change the working directory to somedir/ and will only run when somedir/somelog.txt doesn't exist
  ansible.builtin.shell: somescript.sh &gt;&gt; somelog.txt
  args:
    chdir: somedir/
    creates: somelog.txt
    
# You can also use the 'cmd' parameter instead of free form format.
- name: This command will change the working directory to somedir/
  ansible.builtin.shell:
    cmd: ls -l | grep log
    chdir: somedir/

- name: Run a command that uses non-posix shell-isms (in this example /bin/sh doesn't handle redirection and wildcards together but bash does)
  ansible.builtin.shell: cat &lt; /tmp/*txt
  args:
    executable: /bin/bash

- name: Run a command using a templated variable (always use quote filter to avoid injection)
  ansible.builtin.shell: cat {{ myfile|quote }}
  
  
  # You can use shell to run other executables to perform actions inline
- name: Run expect to wait for a successful PXE boot via out-of-band CIMC
  ansible.builtin.shell: |
    set timeout 300
    spawn ssh admin@{{ cimc_host }}

    expect &quot;password:&quot;
    send &quot;{{ cimc_password }}\n&quot;

    expect &quot;\n{{ cimc_name }}&quot;
    send &quot;connect host\n&quot;

    expect &quot;pxeboot.n12&quot;
    send &quot;\n&quot;

    exit 0
  args:
    executable: /usr/bin/expect
  delegate_to: localhost
  
# Disabling warnings
- name: Using curl to connect to a host via SOCKS proxy (unsupported in uri). Ordinarily this would throw a warning
  ansible.builtin.shell: curl --socks5 localhost:9000 http://www.ansible.com
  args:
    warn: no
</code></pre>
<h2 id="return-values-1"><a class="header" href="#return-values-1"><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/shell_module.html#id7">Return Values</a></a></h2>
<table><thead><tr><th>Key</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>cmd</strong> string</td><td>The command executed by the task.<strong>Returned:</strong> always<strong>Sample:</strong> “rabbitmqctl join_cluster <a href="mailto:rabbit@master">rabbit@master</a>”</td></tr>
<tr><td><strong>delta</strong> string</td><td>The command execution delta time.<strong>Returned:</strong> always<strong>Sample:</strong> “0:00:00.325771”</td></tr>
<tr><td><strong>end</strong> string</td><td>The command execution end time.<strong>Returned:</strong> always<strong>Sample:</strong> “2016-02-25 09:18:26.755339”</td></tr>
<tr><td><strong>msg</strong> boolean</td><td>changed<strong>Returned:</strong> always<strong>Sample:</strong> true</td></tr>
<tr><td><strong>rc</strong> integer</td><td>The command return code (0 means success).<strong>Returned:</strong> always<strong>Sample:</strong> 0</td></tr>
<tr><td><strong>start</strong> string</td><td>The command execution start time.<strong>Returned:</strong> always<strong>Sample:</strong> “2016-02-25 09:18:26.429568”</td></tr>
<tr><td><strong>stderr</strong> string</td><td>The command standard error.<strong>Returned:</strong> always<strong>Sample:</strong> “ls: cannot access foo: No such file or directory”</td></tr>
<tr><td><strong>stderr_lines</strong> list / elements=string</td><td>The command standard error split in lines.<strong>Returned:</strong> always<strong>Sample:</strong> [{“u\u0027ls cannot access foo”: “No such file or directory\u0027”}, “u\u0027ls \u2026\u0027”]</td></tr>
<tr><td><strong>stdout</strong> string</td><td>The command standard output.<strong>Returned:</strong> always<strong>Sample:</strong> “Clustering node <a href="mailto:rabbit@slave1">rabbit@slave1</a> with <a href="mailto:rabbit@master">rabbit@master</a> \u2026”</td></tr>
<tr><td><strong>stdout_lines</strong> list / elements=string</td><td>The command standard output split in lines.<strong>Returned:</strong> always<strong>Sample:</strong> [“u\u0027Clustering node <a href="mailto:rabbit@slave1">rabbit@slave1</a> with <a href="mailto:rabbit@master">rabbit@master</a> \u2026\u0027”]</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设置webhook"><a class="header" href="#设置webhook">设置webhook</a></h1>
<p>以 gitee为例</p>
<ol>
<li>
<p>git生成token,<a href="https://gitee.com/profile/personal_access_tokens">生成地址</a></p>
</li>
<li>
<p>Jenkins安装 git插件 重启</p>
</li>
<li>
<p>复制其 webhookURL到gitee项目的 <a href="https://gitee.com/weisanju/note/hooks">webhook</a></p>
</li>
<li>
<p>在Jenkins中生成webhook密码</p>
</li>
<li>
<p>测试推送是否成功</p>
</li>
</ol>
<h1 id="为jenkins启用反向代理"><a class="header" href="#为jenkins启用反向代理">为Jenkins启用反向代理</a></h1>
<ol>
<li>
<p>修改Jenkins上下文路径</p>
<p>在文件 /etc/default/jenkins </p>
<pre><code>JENKINS_ARGS=&quot;--webroot=/var/cache/$NAME/war --httpPort=$HTTP_PORT --prefix=/jenkins&quot;
</code></pre>
</li>
<li>
<p>Manage Jenkins / Configure System，将Jenkins URL后添加<code>/jenkins</code></p>
</li>
<li>
<p>nginx配置</p>
<pre><code class="language-nginx">	server{
		listen 192.168.3.15:80;
		server_name  &quot;&quot;;
		#root /home/pi/gitbook/_book;
		location /jenkins/ {
			 proxy_pass http://localhost:8080;
		}
	}
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述-2"><a class="header" href="#概述-2">概述</a></h1>
<p><strong>该文档覆盖了 Jenkins Pipeline功能的所有推荐的方面</strong></p>
<p>包括</p>
<ul>
<li>如何 在 UI界面、SCM、定义Pipeline </li>
<li>创建并使用 Jenkinsfile</li>
<li>git分支 与 pull request</li>
<li>在Pipeline中使用Docker</li>
<li>Pipeline中的继承</li>
<li>使用不同的开发工具 加速 Pipeline的创建</li>
<li>使用流水线语法 - 此页面是所有声明式流水线语法的综合参考。</li>
</ul>
<h2 id="什么是jenkinspipeline"><a class="header" href="#什么是jenkinspipeline">什么是JenkinsPipeline</a></h2>
<p>持续交付 (CD) 管道是将软件从版本控制到用户和客户的过程的自动化</p>
<p>对您的软件（在源代码控制中提交）的每一次更改在发布之前都经历了一个复杂的过程。</p>
<p>此过程涉及以可靠且可重复的方式构建软件，以及通过多个测试和部署阶段推进构建的软件</p>
<p>Pipeline 提供了一组可扩展的工具，用于通过 Pipeline 域特定语言 (DSL) 语法将简单到复杂的交付管道“作为代码”建模。 </p>
<p>Jenkins 管道的定义被写入一个文本文件（称为 Jenkinsfile），该文件又可以提交到项目的源代码控制存储库。 </p>
<p>[2] 这是“Pipeline-as-code”的基础；</p>
<p>将 CD 管道视为要进行版本控制和审查的应用程序的一部分，就像任何其他代码一样。</p>
<p>创建 Jenkinsfile 并将其提交到源代码控制提供了许多直接的好处：</p>
<ol>
<li>
<p>自动为所有分支和拉取请求创建流水线构建过程。</p>
</li>
<li>
<p>流水线上的代码审查/迭代（以及剩余的源代码）。</p>
</li>
<li>
<p>管道的审计跟踪。</p>
</li>
<li>
<p>管道的单一事实来源 [3]，可由项目的多个成员查看和编辑。</p>
</li>
</ol>
<p>尽管在 Web UI 中或使用 Jenkinsfile 定义流水线的语法是相同的，但通常认为最佳实践是在 Jenkinsfile 中定义流水线并将其签入源代码控制。</p>
<h2 id="声明式与脚本式-流水线语法"><a class="header" href="#声明式与脚本式-流水线语法">声明式与脚本式 流水线语法</a></h2>
<p>Jenkinsfile 可以使用两种类型的语法编写 - 声明式和脚本式。</p>
<p>声明式管道和脚本式管道的构造根本不同。</p>
<p>声明式流水线是 Jenkins 流水线的一个更新的特性，它：</p>
<p>提供比 Scripted Pipeline 语法更丰富的语法特性，旨在使编写和阅读 Pipeline 代码更容易。</p>
<p>然而，许多写入 Jenkinsfile 的单个语法组件（或“步骤”）对于声明式和脚本式流水线都是通用的。</p>
<h2 id="why-pipeline"><a class="header" href="#why-pipeline">Why Pipeline?</a></h2>
<p>从根本上说，Jenkins 是一个支持多种自动化模式的自动化引擎。</p>
<p>Pipeline 在 Jenkins 上添加了一组强大的自动化工具，支持从简单的持续集成到全面的 CD 管道的用例。</p>
<p>通过对一系列相关任务进行建模，用户可以利用 Pipeline 的许多特性：</p>
<ul>
<li><strong>Code</strong>: 管道在代码中实现，通常会签入源代码管理，使团队能够编辑、审查和迭代他们的交付管道</li>
<li><strong>Durable</strong>: 管道可以在 Jenkins 控制器的计划内和计划外重启中存活下来。</li>
<li><strong>Pausable</strong>: 流水线可以选择停止并等待人工输入或批准，然后再继续流水线运行。 </li>
<li><strong>Versatile</strong>: 管道支持复杂的现实世界 CD 要求，包括分叉/加入、循环和并行执行工作的能力。</li>
<li><strong>Extensible</strong>: 管道插件支持对其 DSL [<a href="https://www.jenkins.io/doc/book/pipeline/#_footnotedef_1">1</a>] 的自定义扩展以及与其他插件集成的多个选项。</li>
</ul>
<p>基于 Jenkins 可扩展性的核心价值，Pipeline 也可以由使用 Pipeline Shared Libraries 的用户和插件开发人员扩展。 </p>
<p>下面的流程图是在 Jenkins Pipeline 中轻松建模的一个 CD 场景的示例：</p>
<h1 id="pipeline-concepts"><a class="header" href="#pipeline-concepts">Pipeline concepts</a></h1>
<h2 id="pipeline"><a class="header" href="#pipeline">Pipeline</a></h2>
<p>管道是用户定义的 CD 管道模型。</p>
<p>管道的代码定义了整个构建过程，通常包括</p>
<ul>
<li>构建应用程序</li>
<li>测试应用程序</li>
<li>和交付应用程序的阶段。</li>
</ul>
<h2 id="node"><a class="header" href="#node">Node</a></h2>
<p>节点是一台机器，它是 Jenkins 环境的一部分，能够执行流水线。</p>
<h2 id="stage"><a class="header" href="#stage">Stage</a></h2>
<p>阶段块定义了通过整个流水线（例如“构建”、“测试”和“部署”阶段）执行的概念上不同的任务子集，许多插件使用它来可视化或呈现 Jenkins 流水线状态/进度。 </p>
<h2 id="step"><a class="header" href="#step">Step</a></h2>
<p>一个任务。</p>
<p>从根本上说，步骤告诉 Jenkins 在特定时间点（或过程中的“步骤”）要做什么。</p>
<p>例如，要执行 shell 命令 make 使用 sh 步骤：sh 'make'。</p>
<h1 id="pipeline-syntax-overview"><a class="header" href="#pipeline-syntax-overview">Pipeline syntax overview</a></h1>
<p>以下流水线代码框架说明了声明式流水线语法和脚本式流水线语法之间的根本区别。</p>
<h2 id="declarative-pipeline-fundamentals"><a class="header" href="#declarative-pipeline-fundamentals">Declarative Pipeline fundamentals</a></h2>
<p>Jenkinsfile (Declarative Pipeline)</p>
<pre><code class="language-groovy">pipeline {
    agent any 
    stages {
        stage('Build') { 
            steps {
                // 
            }
        }
        stage('Test') { 
            steps {
                // 
            }
        }
        stage('Deploy') { 
            steps {
                // 
            }
        }
    }
}
</code></pre>
<h2 id="scripted-pipeline-fundamentals"><a class="header" href="#scripted-pipeline-fundamentals">Scripted Pipeline fundamentals</a></h2>
<p>在脚本化流水线语法中，一个或多个节点块在整个流水线中完成核心工作。</p>
<p>尽管这不是 Scripted Pipeline 语法的强制性要求，但将 Pipeline 的工作限制在节点块内有两件事：</p>
<ul>
<li>通过将项目添加到 Jenkins 队列来安排块中包含的步骤运行。一旦执行程序在节点上空闲，这些步骤就会运行。</li>
<li>创建一个工作区（特定于该特定管道的目录），可以在其中对从源代码管理检出的文件进行工作</li>
</ul>
<blockquote>
<p>根据您的 Jenkins 配置，某些工作区在一段时间不活动后可能不会自动清理。</p>
</blockquote>
<p>Jenkinsfile (Scripted Pipeline)</p>
<pre><code class="language-groovy">node {  
    stage('Build') { 
        // 
    }
    stage('Test') { 
        // 
    }
    stage('Deploy') { 
        // 
    }
}
</code></pre>
<h2 id="pipeline-example"><a class="header" href="#pipeline-example">Pipeline example</a></h2>
<p>Jenkinsfile (Declarative Pipeline)</p>
<pre><code class="language-groovy">pipeline { 
    agent any 
    options {
        skipStagesAfterUnstable()
    }
    stages {
        stage('Build') { 
            steps { 
                sh 'make' 
            }
        }
        stage('Test'){
            steps {
                sh 'make check'
                junit 'reports/**/*.xml' 
            }
        }
        stage('Deploy') {
            steps {
                sh 'make publish'
            }
        }
    }
}
</code></pre>
<table><thead><tr><th><a href="https://www.jenkins.io/doc/book/pipeline/syntax#declarative-pipeline"><code>pipeline</code></a> is Declarative Pipeline-specific syntax that defines a &quot;block&quot; containing all content and instructions for executing the entire Pipeline.</th><th></th></tr></thead><tbody>
<tr><td></td><td><a href="https://www.jenkins.io/doc/book/pipeline/syntax#agent"><code>agent</code></a> is Declarative Pipeline-specific syntax that instructs Jenkins to allocate an executor (on a node) and workspace for the entire Pipeline.</td></tr>
<tr><td></td><td><code>stage</code> is a syntax block that describes a <a href="https://www.jenkins.io/doc/book/pipeline/#stage">stage of this Pipeline</a>. Read more about <code>stage</code> blocks in Declarative Pipeline syntax on the <a href="https://www.jenkins.io/doc/book/pipeline/syntax#stage">Pipeline syntax</a> page. As mentioned <a href="https://www.jenkins.io/doc/book/pipeline/#scripted-pipeline-fundamentals">above</a>, <code>stage</code> blocks are optional in Scripted Pipeline syntax.</td></tr>
<tr><td></td><td><a href="https://www.jenkins.io/doc/book/pipeline/syntax#steps"><code>steps</code></a> is Declarative Pipeline-specific syntax that describes the steps to be run in this <code>stage</code>.</td></tr>
<tr><td></td><td><code>sh</code> is a Pipeline <a href="https://www.jenkins.io/doc/book/pipeline/syntax#steps">step</a> (provided by the <a href="https://plugins.jenkins.io/workflow-durable-task-step">Pipeline: Nodes and Processes plugin</a>) that executes the given shell command.</td></tr>
<tr><td></td><td><code>junit</code> is another Pipeline <a href="https://www.jenkins.io/doc/book/pipeline/syntax#steps">step</a> (provided by the <a href="https://plugins.jenkins.io/junit">JUnit plugin</a>) for aggregating test reports.</td></tr>
<tr><td></td><td><code>node</code> is Scripted Pipeline-specific syntax that instructs Jenkins to execute this Pipeline (and any stages contained within it), on any available agent/node. This is effectively equivalent to <code>agent</code> in Declarative Pipeline-specific syntax.</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="快速安装"><a class="header" href="#快速安装">快速安装</a></h2>
<h3 id="step-1-install-filebeat"><a class="header" href="#step-1-install-filebeat">Step 1: Install Filebeat</a></h3>
<pre><code class="language-sh">curl -L -O https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-8.1.1-darwin-x86_64.tar.gz
tar xzvf filebeat-8.1.1-darwin-x86_64.tar.gz
</code></pre>
<pre><code class="language-sh">curl -L -O https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-8.1.1-linux-x86_64.tar.gz
tar xzvf filebeat-8.1.1-linux-x86_64.tar.gz
</code></pre>
<h3 id="step-2-connect-to-the-elastic-stack"><a class="header" href="#step-2-connect-to-the-elastic-stack">Step 2: Connect to the Elastic Stack</a></h3>
<pre><code class="language-yaml">output.elasticsearch:
  hosts: [&quot;https://myEShost:9200&quot;]
  username: &quot;filebeat_internal&quot;
  password: &quot;YOUR_PASSWORD&quot; 
  ssl:
    enabled: true
    ca_trusted_fingerprint: &quot;b9a10bbe64ee9826abeda6546fc988c8bf798b41957c33d05db736716513dc9c&quot; 
</code></pre>
<h3 id="step-3-collect-log-data"><a class="header" href="#step-3-collect-log-data">Step 3: Collect log data</a></h3>
<pre><code class="language-sh">filebeat modules list
</code></pre>
<pre><code>filebeat modules enable nginx
</code></pre>
<p>在<em>modules.d</em>下的模块配置中，启用所需的数据集并更改模块设置以匹配您的环境。<strong>Datasets are disabled by default.</strong></p>
<p>例如，日志位置是根据操作系统设置的。如果您的日志不在默认位置，请设置路径变量:</p>
<pre><code class="language-yaml">- module: nginx
  access:
    enabled: true
    var.paths: [&quot;/var/log/nginx/access.log*&quot;] 
</code></pre>
<p>To see the full list of variables for a module, see the documentation under <a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-modules.html">Modules</a>.</p>
<pre><code>./filebeat test config -e
</code></pre>
<p>Make sure your config files are in the path expected by Filebeat (see <a href="https://www.elastic.co/guide/en/beats/filebeat/current/directory-layout.html">Directory layout</a>), or use the <code>-c</code> flag to specify the path to the config file.</p>
<p>For more information about configuring Filebeat, also see:</p>
<ul>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/configuring-howto-filebeat.html">Configure Filebeat</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/libbeat/8.1/config-file-format.html">Config file format</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-reference-yml.html"><code>filebeat.reference.yml</code></a>: This reference configuration file shows all non-deprecated options. You’ll find it in the same location as <code>filebeat.yml</code>.</li>
</ul>
<h4 id="enable-and-configure-ecs-loggers-for-application-log-collection"><a class="header" href="#enable-and-configure-ecs-loggers-for-application-log-collection">Enable and configure ECS loggers for application log collection</a></h4>
<p>虽然Filebeat可用于摄取原始的纯文本应用程序日志，但我们建议您在摄取时结构化你的日志。这使您可以提取字段，例如日志级别和异常堆栈跟踪。</p>
<p>Elastic通过提供各种流行编程语言的应用程序日志格式化程序来简化此过程。这些插件将您的日志格式化为与ECS兼容的JSON，从而无需手动解析日志。</p>
<p>See <a href="https://www.elastic.co/guide/en/ecs-logging/overview/master/intro.html">ECS loggers</a> to get started.</p>
<h4 id="configure-filebeat-manually"><a class="header" href="#configure-filebeat-manually">Configure Filebeat manually</a></h4>
<p>see <a href="https://www.elastic.co/guide/en/beats/filebeat/current/configuration-filebeat-options.html">configure the input</a> manually.</p>
<h3 id="step-4-set-up-assets"><a class="header" href="#step-4-set-up-assets">Step 4: Set up assets</a></h3>
<p>Filebeat comes with predefined assets for parsing, indexing, and visualizing your data. To load these assets:</p>
<p>Filebeat带有预定义的assets，用于解析，索引和可视化数据。要加载这些assets:</p>
<pre><code class="language-sh">filebeat setup -e
</code></pre>
<p>This step loads the recommended <a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.1/index-templates.html">index template</a> for writing to Elasticsearch and deploys the sample dashboards for visualizing the data in Kibana.</p>
<p>This step does not load the ingest pipelines used to parse log lines. By default, ingest pipelines are set up automatically the first time you run the module and connect to Elasticsearch.</p>
<p>此步骤不会加载用于解析日志行的摄取管道。默认情况下，第一次运行模块并连接到Elasticsearch时会自动设置ingest管道。</p>
<p>需要连接到Elasticsearch (或Elasticsearch服务) 才能设置初始环境。如果您使用的是其他输出，例如Logstash，请参阅:</p>
<ul>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-template.html#load-template-manually">Load the index template manually</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/load-kibana-dashboards.html"><em>Load Kibana dashboards</em></a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/load-ingest-pipelines.html"><em>Load ingest pipelines</em></a></li>
</ul>
<h3 id="step-5-start-filebeat"><a class="header" href="#step-5-start-filebeat">Step 5: Start Filebeat</a></h3>
<pre><code class="language-sh">sudo chown root filebeat.yml 
sudo chown root modules.d/nginx.yml 
sudo ./filebeat -e
</code></pre>
<h3 id="step-6-view-your-data-in-kibana"><a class="header" href="#step-6-view-your-data-in-kibana">Step 6: View your data in Kibana</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-filebeat-works"><a class="header" href="#how-filebeat-works">How Filebeat works</a></h1>
<p>在本主题中，您将了解Filebeat的关键构建块以及它们如何协同工作。了解这些概念将有助于您就为特定用例配置Filebeat做出明智的决策。</p>
<p>Filebeat consists of two main components: <a href="https://www.elastic.co/guide/en/beats/filebeat/current/how-filebeat-works.html#input">inputs</a> and <a href="https://www.elastic.co/guide/en/beats/filebeat/current/how-filebeat-works.html#harvester">harvesters</a>. These components work together to tail files and send event data to the output that you specify.</p>
<h3 id="what-is-a-harvester"><a class="header" href="#what-is-a-harvester">What is a harvester?</a></h3>
<p>收割机负责读取单个文件的内容。</p>
<p>收割机一行一行地读取每个文件，并将内容发送到输出。每个文件启动一台收割机。</p>
<p>收割机负责打开和关闭文件，这意味着在收割机运行时文件描述符保持打开状态</p>
<p>If a file is removed or renamed while it’s being harvested, Filebeat continues to read the file.</p>
<p>如果文件在收割时被删除或重命名，Filebeat将继续读取该文件。这有一个副作用，即在收割机关闭之前保留磁盘上的空间。</p>
<p>默认情况下，Filebeat将文件保持打开状态，直到达到  <a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-log.html#filebeat-input-log-close-inactive"><code>close_inactive</code></a> </p>
<p>Closing a harvester has the following consequences:</p>
<ul>
<li>The file handler is closed, freeing up the underlying resources if the file was deleted while the harvester was still reading the file.</li>
<li>The harvesting of the file will only be started again after <a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-log.html#filebeat-input-log-scan-frequency"><code>scan_frequency</code></a> has elapsed.</li>
<li>If the file is moved or removed while the harvester is closed, harvesting of the file will not continue.</li>
</ul>
<p>To control when a harvester is closed, use the <a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-log.html#filebeat-input-log-close-options"><code>close_*</code></a> configuration options.</p>
<h3 id="what-is-an-input"><a class="header" href="#what-is-an-input">What is an input?</a></h3>
<p>input负责管理收割机并查找所有要读取的来源。</p>
<p>如果输入类型为log，则输入将查找驱动器上与定义的glob路径匹配的所有文件，并为每个文件启动一个收割机。每个input 都在其自己的Go例程中运行。</p>
<p>以下示例将Filebeat配置为从与指定的glob模式匹配的所有日志文件中收获行:</p>
<pre><code class="language-yaml">filebeat.inputs:
- type: log
  paths:
    - /var/log/*.log
    - /var/path2/*.log
</code></pre>
<p>Filebeat currently supports <a href="https://www.elastic.co/guide/en/beats/filebeat/current/configuration-filebeat-options.html#filebeat-input-types">several <code>input</code> types</a>. </p>
<p>每种输入类型可以多次定义。</p>
<p>Filebeat目前支持几种输入类型。每种输入类型可以多次定义。日志输入会检查每个文件，以查看是否需要启动收割机，是否已经在运行，或者是否可以忽略该文件 (请参阅<em>ignore_older</em>)。仅当自收割机关闭以来文件的大小发生变化时，才会拾取新行。</p>
<h3 id="how-does-filebeat-keep-the-state-of-files"><a class="header" href="#how-does-filebeat-keep-the-state-of-files">How does Filebeat keep the state of files?</a></h3>
<p>Filebeat保留每个文件的状态，并经常将状态刷新到注册表文件中的磁盘。状态用于记住收割机读取的最后一个偏移量，并确保发送所有日志行。如果无法访问输出 (例如Elasticsearch或Logstash)，则Filebeat会跟踪发送的最后一行，并在输出再次可用后继续读取文件。Filebeat运行时，每个输入的状态信息也保存在内存中。当Filebeat重新启动时，来自注册表文件的数据将用于重建状态，并且Filebeat在最后一个已知位置继续每个收割机。</p>
<p>For each input, Filebeat keeps a state of each file it finds. Because files can be renamed or moved, the filename and path are not enough to identify a file. For each file, Filebeat stores unique identifiers to detect whether a file was harvested previously.</p>
<p>对于每个输入，Filebeat都会保留找到的每个文件的状态。因为文件可以重命名或移动，所以文件名和路径不足以识别文件。对于每个文件，Filebeat存储唯一的标识符，以检测先前是否已收获文件。</p>
<p>如果您的用例涉及每天创建大量新文件，则可能会发现注册表文件变得太大。 See <a href="https://www.elastic.co/guide/en/beats/filebeat/current/reduce-registry-size.html">Registry file is too large</a> for details about configuration options that you can set to resolve this issue.</p>
<h3 id="how-does-filebeat-ensure-at-least-once-delivery"><a class="header" href="#how-does-filebeat-ensure-at-least-once-delivery">How does Filebeat ensure at-least-once delivery?</a></h3>
<p>Filebeat保证事件将至少一次传递到配置的输出，并且不会丢失数据。Filebeat能够实现此行为，因为它将每个事件的传递状态存储在注册表文件中。</p>
<p>在定义的输出被阻止并且尚未确认所有事件的情况下，Filebeat将继续尝试发送事件，直到输出确认已收到事件为止。</p>
<p>如果Filebeat在发送事件的过程中关闭，则它不会在关闭之前等待输出确认所有事件,</p>
<p>重新启动Filebeat时，将再次发送发送到输出但在Filebeat关闭之前未确认的任何事件,这样可以确保每个事件至少发送一次，但是最终可能导致将重复的事件发送到输出。可以配置  <a href="https://www.elastic.co/guide/en/beats/filebeat/current/configuration-general-options.html#shutdown-timeout"><code>shutdown_timeout</code></a> option. 在关闭时等待延时</p>
<p>Filebeat的至少一次传递保证有一个限制，涉及日志轮换和旧文件的删除。如果将日志文件写入磁盘并旋转速度快于Filebeat处理的速度，或者在输出不可用时删除了文件，则数据可能会丢失。在Linux上，由于inode重用，Filebeat也可以跳过行。， See <a href="https://www.elastic.co/guide/en/beats/filebeat/current/faq.html"><em>Common problems</em></a> for more details about the inode reuse issue.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="配置filebeat"><a class="header" href="#配置filebeat">配置FileBeat</a></h2>
<p>要配置Filebeat，请编辑配置文件。默认配置文件称为filebeat.yml。文件的位置因平台而异。s</p>
<p>To locate the file, see <a href="https://www.elastic.co/guide/en/beats/filebeat/current/directory-layout.html">Directory layout</a>.</p>
<p>还有一个名为filebeat.reference.yml的完整示例配置文件，它显示了所有非过时的的选项。</p>
<p>See the <a href="https://www.elastic.co/guide/en/beats/libbeat/8.1/config-file-format.html">Config File Format</a> for more about the structure of the config file.</p>
<p>The following topics describe how to configure Filebeat:</p>
<ul>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/configuration-filebeat-options.html"><em>Inputs</em></a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/configuration-filebeat-modules.html"><em>Modules</em></a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/configuration-general-options.html"><em>General settings</em></a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/configuration-path.html"><em>Project paths</em></a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-configuration-reloading.html"><em>Config file loading</em></a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/configuring-output.html"><em>Output</em></a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/configuration-ssl.html"><em>SSL</em></a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/ilm.html"><em>Index lifecycle management (ILM)</em></a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/configuration-template.html"><em>Elasticsearch index template</em></a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/setup-kibana-endpoint.html"><em>Kibana endpoint</em></a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/configuration-dashboards.html"><em>Kibana dashboards</em></a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filtering-and-enhancing-data.html"><em>Processors</em></a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/configuration-autodiscover.html"><em>Autodiscover</em></a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/configuring-internal-queue.html"><em>Internal queue</em></a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/load-balancing.html"><em>Load balancing</em></a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/configuration-logging.html"><em>Logging</em></a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/http-endpoint.html"><em>HTTP endpoint</em></a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/regexp-support.html"><em>Regular expression support</em></a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/configuration-instrumentation.html"><em>Instrumentation</em></a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-reference-yml.html"><em>filebeat.reference.yml</em></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="configure-inputs"><a class="header" href="#configure-inputs">Configure inputs</a></h2>
<p><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-modules-overview.html">Filebeat modules</a> provide the fastest getting started experience for common log formats</p>
<p>To configure Filebeat manually (instead of using <a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-modules-overview.html">modules</a>), you specify a list of inputs in the <code>filebeat.inputs</code> section of the <code>filebeat.yml</code>. Inputs specify how Filebeat locates and processes input data.</p>
<p>The list is a <a href="http://yaml.org/">YAML</a> array, so each input begins with a dash (<code>-</code>). You can specify multiple inputs, and you can specify the same input type more than once. For example:</p>
<pre><code class="language-yaml">filebeat.inputs:
- type: log
  paths:
    - /var/log/system.log
    - /var/log/wifi.log
- type: log
  paths:
    - &quot;/var/log/apache2/*&quot;
  fields:
    apache: true
  fields_under_root: true
</code></pre>
<p>对于最基本的配置，定义具有单个路径的单个输入。例如:</p>
<pre><code class="language-yaml">filebeat.inputs:
- type: log
  enabled: true
  paths:
    - /var/log/*.log
</code></pre>
<p>The input in this example harvests all files in the path <code>/var/log/*.log</code>, which means that Filebeat will harvest all files in the directory <code>/var/log/</code> that end with <code>.log</code>. All patterns supported by <a href="https://golang.org/pkg/path/filepath/#Glob">Go Glob</a> are also supported here.</p>
<p>To fetch all files from a predefined level of subdirectories, use this pattern: <code>/var/log/*/*.log</code>. This fetches all <code>.log</code> files from the subfolders of <code>/var/log</code>. It does not fetch log files from the <code>/var/log</code> folder itself. Currently it is not possible to recursively fetch all files in all subdirectories of a directory.</p>
<h3 id="input-types"><a class="header" href="#input-types">Input types</a></h3>
<p>You can configure Filebeat to use the following inputs:</p>
<ul>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-aws-cloudwatch.html">AWS CloudWatch</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-aws-s3.html">AWS S3</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-azure-eventhub.html">Azure Event Hub</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-cloudfoundry.html">Cloud Foundry</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-container.html">Container</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-filestream.html">filestream</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-gcp-pubsub.html">GCP Pub/Sub</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-http_endpoint.html">HTTP Endpoint</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-httpjson.html">HTTP JSON</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-journald.html">journald</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-kafka.html">Kafka</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-log.html">Log</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-mqtt.html">MQTT</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-netflow.html">NetFlow</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-o365audit.html">Office 365 Management Activity API</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-redis.html">Redis</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-stdin.html">Stdin</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-syslog.html">Syslog</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-tcp.html">TCP</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-udp.html">UDP</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="filestream-input"><a class="header" href="#filestream-input">filestream input</a></h2>
<p>使用filestream输入从活动日志文件中读取行。它是新的，改进的替代the  <code>log</code> input.。它带有对现有输入的各种改进:</p>
<ol>
<li>Checking of <code>close_*</code> options happens out of band. Thus, if an output is blocked, Filebeat can close the reader and avoid keeping too many files open.</li>
<li>Detailed metrics are available for all files that match the <code>paths</code> configuration regardless of the <code>harvester_limit</code>. This way, you can keep track of all files, even ones that are not actively read.</li>
<li>The order of <code>parsers</code> is configurable. So it is possible to parse JSON lines and then aggregate the contents into a multiline event.</li>
<li>Some position updates and metadata changes no longer depend on the publishing pipeline. If the pipeline is blocked some changes are still applied to the registry.</li>
<li>Only the most recent updates are serialized to the registry. In contrast, the <code>log</code> input has to serialize the complete registry on each ACK from the outputs. This makes the registry updates much quicker with this input.</li>
<li>The input ensures that only offsets updates are written to the registry append only log. The <code>log</code> writes the complete file state.</li>
<li>Stale entries can be removed from the registry, even if there is no active input.</li>
</ol>
<p>To configure this input, specify a list of glob-based <a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-filestream.html#filestream-input-paths"><code>paths</code></a> that must be crawled to locate and fetch the log lines.</p>
<p>Example configuration:</p>
<pre><code class="language-yaml">filebeat.inputs:
- type: filestream
  paths:
    - /var/log/messages
    - /var/log/*.log
</code></pre>
<p>You can apply additional <a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-filestream.html#filebeat-input-filestream-options">configuration settings</a> (such as <code>fields</code>, <code>include_lines</code>, <code>exclude_lines</code> and so on) to the lines harvested from these files. </p>
<p>The options that you specify are applied to all the files harvested by this input.</p>
<p>To apply different configuration settings to different files, you need to define multiple input sections:</p>
<p>要将不同的配置设置应用于不同的文件，您需要定义多个 input sections:</p>
<pre><code class="language-yaml">filebeat.inputs:
- type: filestream 
  paths:
    - /var/log/system.log
    - /var/log/wifi.log
- type: filestream 
  paths:
    - &quot;/var/log/apache2/*&quot;
  fields:
    apache: true
</code></pre>
<h3 id="reading-files-on-network-shares-and-cloud-providers"><a class="header" href="#reading-files-on-network-shares-and-cloud-providers">Reading files on network shares and cloud providers</a></h3>
<p>但是，如果充分配置Filebeat，则可以减轻这些数据源的限制之一。</p>
<p>默认情况下，Filebeat根据文件的inode和设备id识别文件</p>
<p>但是，在网络共享和云提供商上，这些值可能会在文件的生命周期内更改。</p>
<p>如果发生这种情况，Filebeat认为该文件是新文件，并重新发送该文件的全部内容。</p>
<p>要解决此问题，您可以配置<em>file_identity</em>选项。除了默认的<em>inode_deviceid</em>之外，可能的值是<em>path</em>和<em>inode_marker</em>。</p>
<p>在运行中间更改<em>file_identity</em>方法可能会导致输出中重复的事件。</p>
<ul>
<li>选择路径指示Filebeat根据其路径识别文件</li>
<li>如果inode和设备id可能更改，这是避免重读文件的快速方法。</li>
<li>但是，请记住，如果文件被旋转 (重命名)，它们将被重新读取并重新提交。</li>
<li>如果<em>inode</em>保持不变，即使设备id已更改，也可以使用<em>inode_marker</em>选项，如果可能的话，您应该选择此方法，如果您的文件是轮转的，您必须配置一个可由Filebeat读取的标记文件，并在<em>inode_marker</em>的选项路径中设置路径。此文件的内容必须是设备唯一的，您可以将设备或挂载点的UUID放在存储输入的位置。下面的示例oneliner为选定的挂载点 '<em>/logs</em>' 生成一个隐藏的标记文件.请注意，您不应该在Windows上使用此选项，因为文件标识符可能会更加不稳定。</li>
</ul>
<pre><code class="language-sh">$ lsblk -o MOUNTPOINT,UUID | grep /logs | awk '{print $2}' &gt;&gt; /logs/.filebeat-marker
</code></pre>
<p>要将生成的文件设置为<em>file_identity</em>的标记，您应该通过以下方式配置输入:</p>
<pre><code class="language-yaml">filebeat.inputs:
- type: filestream
  paths:
    - /logs/*.log
  file_identity.inode_marker.path: /logs/.filebeat-marker
</code></pre>
<h3 id="reading-from-rotating-logs"><a class="header" href="#reading-from-rotating-logs">Reading from rotating logs</a></h3>
<p>When dealing with file rotation, avoid harvesting symlinks. Instead use the <a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-filestream.html#filestream-input-paths"><code>paths</code></a> setting to point to the original file, and specify a pattern that matches the file you want to harvest and all of its rotated files. Also make sure your log rotation strategy prevents lost or duplicate messages. For more information, see <a href="https://www.elastic.co/guide/en/beats/filebeat/current/file-log-rotation.html">Log rotation results in lost or duplicate events</a>.</p>
<p>Furthermore, to avoid duplicate of rotated log messages, do not use the <code>path</code> method for <code>file_identity</code>. Or exclude the rotated files with <code>exclude_files</code> option.</p>
<p>此外，为避免重复旋转的日志消息，请勿将path方法用于<em>file_identity</em>。或者排除带有exclude_files选项的旋转文件。</p>
<h3 id="prospector-options"><a class="header" href="#prospector-options">Prospector options</a></h3>
<blockquote>
<p>日志文件扫描程序</p>
</blockquote>
<p>The prospector is running a file system watcher which looks for files specified in the <code>paths</code> option. At the moment only simple file system scanning is supported.</p>
<h5 id="paths"><a class="header" href="#paths"><code>paths</code></a></h5>
<p>A list of glob-based paths that will be crawled and fetched. All patterns supported by <a href="https://golang.org/pkg/path/filepath/#Glob">Go Glob</a> are also supported here. For example, to fetch all files from a predefined level of subdirectories, the following pattern can be used: <code>/var/log/*/*.log</code>. This fetches all <code>.log</code> files from the subfolders of <code>/var/log</code>. It does not fetch log files from the <code>/var/log</code> folder itself. It is possible to recursively fetch all files in all subdirectories of a directory using the optional <a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-filestream.html#filestream-recursive-glob"><code>recursive_glob</code></a> settings.</p>
<p>Filebeat starts a harvester for each file that it finds under the specified paths. You can specify one path per line. Each line begins with a dash (-).</p>
<h3 id="scanner-options"><a class="header" href="#scanner-options">Scanner options</a></h3>
<p>The scanner watches the configured paths. It scans the file system periodically and returns the file system events to the Prospector.</p>
<h5 id="prospectorscannerrecursive_glob"><a class="header" href="#prospectorscannerrecursive_glob"><code>prospector.scanner.recursive_glob</code></a></h5>
<p>Enable expanding <code>**</code> into recursive glob patterns. With this feature enabled, the rightmost <code>**</code> in each path is expanded into a fixed number of glob patterns. For example: <code>/foo/**</code> expands to <code>/foo</code>, <code>/foo/*</code>, <code>/foo/*/*</code>, and so on. If enabled it expands a single <code>**</code> into a 8-level deep <code>*</code> pattern.</p>
<p>This feature is enabled by default. Set <code>prospector.scanner.recursive_glob</code> to false to disable it.</p>
<h5 id="prospectorscannerexclude_files"><a class="header" href="#prospectorscannerexclude_files"><code>prospector.scanner.exclude_files</code></a></h5>
<p>A list of regular expressions to match the files that you want Filebeat to ignore. By default no files are excluded.</p>
<p>The following example configures Filebeat to ignore all the files that have a <code>gz</code> extension:</p>
<pre><code class="language-yaml">filebeat.inputs:
- type: filestream
  ...
  prospector.scanner.exclude_files: ['\.gz$']
</code></pre>
<h4 id="prospectorscannerinclude_files"><a class="header" href="#prospectorscannerinclude_files"><code>prospector.scanner.include_files</code></a></h4>
<p>By default no files are excluded. This option is the counterpart of <code>prospector.scanner.exclude_files</code>.</p>
<p>The following example configures Filebeat to exclude files that are not under <code>/var/log</code>:</p>
<pre><code class="language-yaml">filebeat.inputs:
- type: filestream
  ...
  prospector.scanner.include_files: ['^/var/log/.*']
</code></pre>
<p>See <a href="https://www.elastic.co/guide/en/beats/filebeat/current/regexp-support.html"><em>Regular expression support</em></a> for a list of supported regexp patterns.</p>
<h4 id="prospectorscannersymlinks"><a class="header" href="#prospectorscannersymlinks"><code>prospector.scanner.symlinks</code></a></h4>
<p>The <code>symlinks</code> option allows Filebeat to harvest symlinks in addition to regular files. When harvesting symlinks, Filebeat opens and reads the original file even though it reports the path of the symlink.</p>
<p>符号链接选项允许Filebeat除了常规文件之外还收获符号链接。收获符号链接时，Filebeat会打开并读取原始文件，即使它报告符号链接的路径。</p>
<p>配置收割符号链接时，请确保排除原始路径。如果同时配置 符号链接跟 原始链接，Filebeat将检测到问题并仅处理找到的第一个文件。</p>
<p>但是，如果配置了两个不同的<em>input</em> (一个读取符号链接，另一个读取原始路径)，则将收集两个路径，从而导致Filebeat发送重复数据，并且输入会覆盖彼此的状态。</p>
<p>如果指向日志文件的符号链接在文件名中具有其他元数据，并且您希望在Logstash中处理元数据，则符号链接选项可能会很有用。例如，Kubernetes日志文件就是这种情况。</p>
<p>由于此选项可能会导致数据丢失，因此默认情况下将其禁用。</p>
<h4 id="prospectorscannerresend_on_touch"><a class="header" href="#prospectorscannerresend_on_touch"><code>prospector.scanner.resend_on_touch</code></a></h4>
<p>如果启用了此选项，则如果文件的大小未更改，但其修改时间已更改为比以前晚的时间，则将重新发送文件。默认情况下它是禁用的，以避免意外重新发送文件。</p>
<h5 id="prospectorscannercheck_interval"><a class="header" href="#prospectorscannercheck_interval"><code>prospector.scanner.check_interval</code></a></h5>
<p>Filebeat多久检查一次指定用于收割的路径中的新文件</p>
<p>例如，当指定 了  <code>/var/log/*</code>,  目录使用<em>check_interval</em>指定的频率扫描目录中的文件。</p>
<p>指定1s尽可能频繁地扫描目录，而不会导致Filebeat扫描太频繁,我们不建议将此值设置为 &lt;1s。</p>
<p>如果您需要近乎实时地发送日志行，请不要使用非常低的<em>check_interval</em>，而是调整<em>close.on_state_change.inactive</em>，以便文件处理程序保持打开状态并不断轮询文件。默认设置为10s</p>
<h5 id="ignore_older"><a class="header" href="#ignore_older"><code>ignore_older</code></a></h5>
<p>Filebeat忽略任何在指定时间跨度之前修改的文件</p>
<p>如果您长时间保存日志文件，配置<em>ignore_older</em>可能特别有用</p>
<p>例如，如果您想启动Filebeat，但只想发送上周的最新文件和文件，您可以配置此选项</p>
<p>您可以使用时间字符串，如2h (2小时) 和5m (5分钟),默认为0，这将禁用设置,注释掉配置与将其设置为0具有相同的效果。</p>
<p>您必须将<em>ignore_older</em>设置为大于<em>close.on_state_change.inactive</em>。</p>
<p>受此设置影响的文件分为两类:</p>
<ul>
<li>从未收获的文件</li>
<li>已收获但更新时间未超过 <em>ignore_older</em> 的文件</li>
</ul>
<p>对于以前从未见过的文件，偏移状态设置为文件末尾。如果状态已经存在，则偏移量不会更改。如果以后再次更新文件，则在设置的偏移位置继续读取。</p>
<p><em>ignore_older</em>设置依赖于文件的修改时间来确定文件是否被忽略。如果在将行写入文件时未更新文件的修改时间 (这可能发生在Windows上)，则<em>ignore_older</em>设置可能会导致Filebeat忽略文件，即使稍后添加了内容。</p>
<p>要从注册表文件中删除以前收集的文件的状态，请使用<em>clean_inactive</em>配置选项。</p>
<p>在文件被Filebeat忽略之前，必须关闭该文件。要确保在忽略文件时不再收集文件，必须将<em>ignore_older</em>设置为比<em>close.on_state_change.inactive</em>更长的持续时间。</p>
<p>如果当前正在收获的文件属于<em>ignore_older</em>，则收割机将首先完成读取该文件，并在<em>close.on_state_change.inactive</em>到达之后，该文件将被忽略。</p>
<h5 id="ignore_inactive"><a class="header" href="#ignore_inactive"><code>ignore_inactive</code></a></h5>
<p>If this option is enabled, Filebeat ignores every file that has not been updated since the selected time.</p>
<p>如果启用了此选项，则Filebeat会忽略自选定时间以来尚未更新的每个文件</p>
<p>Possible options are <code>since_first_start</code> and <code>since_last_start</code>.</p>
<p>可用的选项有<em>since_first_start</em>和<em>since_last_start</em>。</p>
<p>第一个选项忽略自Filebeat第一次启动以来尚未更新的每个文件。当Filebeat可能由于配置更改或故障而重新启动时，这很有用。</p>
<p>第二个选项告诉Filebeat从启动后更新的文件中读取。</p>
<p>受此设置影响的文件分为两类:</p>
<ul>
<li>从未收割的文件</li>
<li>自<em>ignore_inactive</em>以来已收割但未更新的文件。</li>
</ul>
<p>对于以前从未见过的文件，偏移状态设置为文件末尾。如果状态已经存在，则偏移量不会更改。如果以后再次更新文件，则在设置的偏移位置继续读取。</p>
<p>The setting relies on the modification time of the file to determine if a file is ignored. If the modification time of the file is not updated when lines are written to a file (which can happen on Windows), the setting may cause Filebeat to ignore files even though content was added at a later time.</p>
<p>To remove the state of previously harvested files from the registry file, use the <code>clean_inactive</code> configuration option.</p>
<h5 id="close"><a class="header" href="#close"><code>close.*</code></a></h5>
<p>close选项用于在指定时间之后 关闭 <em>harvester</em> ，关闭收割机意味着关闭文件处理程序。</p>
<p>如果在收割机关闭后，文件更新了，则在 <code>prospector.scanner.check_interval</code> 时间经过后，该文件将再次被拾取。</p>
<p>但是，如果在收割机关闭时移动或删除了文件，Filebeat将无法再次拾取文件，收割机未读取的任何数据都将丢失。</p>
<p>*close.on_state_change.*设置异步的应用于从文件中读取，这意味着如果Filebeat由于输出被阻止，全队列或其他问题而处于阻止状态，则无论如何都将关闭文件。</p>
<h5 id="closeon_state_changeinactive"><a class="header" href="#closeon_state_changeinactive"><code>close.on_state_change.inactive</code></a></h5>
<p>When this option is enabled, 如果在指定的持续时间内未采集文件，Filebeat会关闭文件句柄. </p>
<p>定义周期的计数器从收割机读取最后一个日志行开始。它不是基于文件的修改时间，如果关闭的文件再次更改，则将启动新的收割机，并且在 <code>prospector.scanner.check_interval</code> 时间间隔之后将再次被拾取</p>
<p>我们建议您将<em>close.on_state_change.inactive</em>设置为大于  日志文件最不频繁更新的值</p>
<p>例如，如果您的日志文件每隔几秒钟更新一次，则可以安全地将close.on_state_change.inactive设置为1m。</p>
<p>如果存在具有非常不同的更新速率的日志文件，则可以使用具有不同值的多个配置。</p>
<p>将<em>close.on_state_change.inactive</em>设置为较低的值意味着文件句柄更快关闭。</p>
<p>但是，这有一个副作用，即如果收割机关闭，则不会近乎实时地发送新的日志行。</p>
<p>关闭文件的时间戳不取决于文件的修改时间。相反，Filebeat使用内部时间戳，该时间戳反映了上次收获文件的时间。</p>
<p>例如，如果将<em>close.on_state_change.inactive</em>设置为5分钟，则5分钟的倒计时将在收割机读取文件的最后一行后开始</p>
<p>You can use time strings like 2h (2 hours) and 5m (5 minutes). The default is 5m.</p>
<h5 id="closeon_state_changerenamed"><a class="header" href="#closeon_state_changerenamed"><code>close.on_state_change.renamed</code></a></h5>
<p>Only use this option if you understand that data loss is a potential side effect.</p>
<p>仅当您了解数据丢失是潜在的副作用时，才使用此选项。</p>
<p>启用此选项后，文件重命名后，Filebeat会关闭文件处理程序。</p>
<p>例如，在轮转文件时会发生这种情况。默认情况下，收割机保持打开状态并继续读取文件，因为文件处理程序不依赖于文件名。</p>
<p>如果启用了 <code>close.on_state_change.renamed</code> 选项，重命名或者移动之后，不再与指定的文件模式匹配，，则不会再次拾取该文件。Filebeat不会读取完文件。</p>
<p>配置基于路径的<em>file_identity</em>时，请勿使用此选项。启用该选项没有意义，因为Filebeat无法使用路径名作为唯一标识符来检测重命名。</p>
<p>WINDOWS: 如果您的Windows日志轮换系统由于无法轮换文件而显示错误，则应启用此选项。</p>
<h5 id="closeon_state_changeremoved"><a class="header" href="#closeon_state_changeremoved"><code>close.on_state_change.removed</code></a></h5>
<p>通常，只有在 <em>close.on_state_change.inactive</em> 指定的持续时间内 <em>inactive</em>，文件才应被删除。</p>
<p>但是，如果文件被提前删除，并且您没有启用<em>close.on_state_change.removed</em>，Filebeat将文件保持打开状态，以确保收割机已完成。</p>
<p>如果此设置导致文件由于过早从磁盘中删除而无法完全读取，请禁用此选项。</p>
<p>If this setting results in files that are not completely read because they are removed from disk too early, disable this option.</p>
<p>默认情况下启用此选项。如果禁用此选项，则还必须禁用<em>clean.on_state_change.removed</em>。</p>
<p>WINDOWS: 如果您的Windows日志轮换系统由于无法轮换文件而显示错误，请确保启用此选项。</p>
<h5 id="closereaderon_eof"><a class="header" href="#closereaderon_eof"><code>close.reader.on_eof</code></a></h5>
<p>仅当您了解数据丢失是潜在的副作用时，才使用此选项。</p>
<p>启用此选项后，Filebeat会在到达文件末尾后立即关闭文件。当您的文件仅写入一次而不不时更新时，这很有用。例如，当您将每个日志事件写入新文件时，就会发生这种情况。默认情况下，此选项被禁用。</p>
<h5 id="closereaderafter_interval"><a class="header" href="#closereaderafter_interval"><code>close.reader.after_interval</code></a></h5>
<p>仅当您了解数据丢失是潜在的副作用时，才使用此选项。另一个副作用是，在超时到期之前，可能不会完全发送多行事件。</p>
<p>启用此选项后，Filebeat会为每个收割机提供预定义的寿命。</p>
<p>无论<em>reader</em>在文件中的位置如何，在<em>close.reader.after_interval</em>时间段过去后，读取都会停止</p>
<p>当您只想在文件上花费预定义的时间时，此选项对于较旧的日志文件很有用。</p>
<p>当<em>close.reader.after_interval</em>将在预定义的超时后关闭文件，如果文件仍在更新，Filebeat将根据定义的探矿者 <em>prospector.scanner.check_interval</em> 再次启动新的收割机。此收割机的<em>close.reader.after_interval</em>倒计时再次开始。</p>
<p>此选项在输出被阻止的情况下特别有用，这使得Filebeat即使对于从磁盘中删除的文件也保持打开的文件处理程序。将<em>close.reader.after_interval</em>设置为5m可确保定期关闭文件，以便操作系统可以将其释放。</p>
<p>If you set <code>close.reader.after_interval</code> to equal <code>ignore_older</code>, the file will not be picked up if it’s modified while the harvester is closed. </p>
<p>这种设置的组合通常会导致数据丢失，并且不发送完整的文件。</p>
<p>当您对包含多行事件的日志使用<em>close.reader.after_interval</em>时，收割机可能会在多行事件的中间停止，这意味着只发送部分事件。如果收割机再次启动并且文件仍然存在，则仅发送事件的第二部分。默认情况下，此选项设置为0，这意味着它被禁用。</p>
<h5 id="clean_"><a class="header" href="#clean_"><code>clean_*</code></a></h5>
<p><em>clean</em> 选项用于清理注册表文件中的状态条目。这些设置有助于减小注册表文件的大小，并可以防止潜在的inode重用问题。 <a href="https://www.elastic.co/guide/en/beats/filebeat/current/inode-reuse-issue.html">inode reuse issue</a>.</p>
<h5 id="clean_inactive"><a class="header" href="#clean_inactive"><code>clean_inactive</code></a></h5>
<p>仅当您了解数据丢失是潜在的副作用时，才使用此选项。</p>
<p>启用此选项后，Filebeat会在指定的不活动时间过去后删除文件的状态。</p>
<p>只有当文件已经被<em>Filebeat</em>忽略 (文件比<em>ignore_older</em>更旧) 时，才能删除状态。<em>clean_inactive</em>设置必须大于<em>ignore_older</em> <em>prospector.scanner.check_interval</em>，以确保在仍在收集文件时未删除任何状态。否则，该设置可能会导致Filebeat不断重新发送完整内容，因为<em>clean_inactive</em>会删除仍由Filebeat检测到的文件的状态。如果文件更新或再次出现，则从头开始读取文件。</p>
<p><em>clean_inactive</em>配置选项对于减小注册表文件的大小很有用，尤其是在每天生成大量新文件的情况下。</p>
<p>此配置选项对于防止Linux上inode重用导致的Filebeat问题也很有用,For more information, see <a href="https://www.elastic.co/guide/en/beats/filebeat/current/inode-reuse-issue.html">Inode reuse causes Filebeat to skip lines</a>.</p>
<p>每次重命名文件时，都会更新文件状态，并且<em>clean_inactive</em>的计数器再次从0开始。</p>
<p>在测试期间，您可能会注意到注册表包含应基于<em>clean_inactive</em>设置删除的状态条目。发生这种情况是因为Filebeat在再次打开注册表以读取其他文件之前不会删除条目。如果您正在测试<em>clean_inactive</em>设置，请确保将Filebeat配置为从多个文件中读取，否则文件状态将永远不会从注册表中删除。</p>
<h5 id="clean_removed"><a class="header" href="#clean_removed"><code>clean_removed</code></a></h5>
<p>启用此选项后，如果无法在磁盘上，以最后一个已知名称，找到文件，则Filebeat会从注册表中清除文件。这也意味着在收割机完成后重命名的文件将被删除。默认情况下启用此选项。</p>
<p>如果共享驱动器在短时间内消失并再次出现，则所有文件将从头开始再次读取，因为状态已从注册表文件中删除。在这种情况下，我们建议您禁用clean_removed选项。</p>
<p>如果共享驱动器在短时间内消失并再次出现，则所有文件将从头开始再次读取，因为状态已从注册表文件中删除。在这种情况下，我们建议您禁用<em>clean_removed</em>选项。</p>
<p>如果您还禁用了<em>close_removed</em>，则必须禁用此选项。</p>
<h5 id="backoff"><a class="header" href="#backoff"><code>backoff.*</code></a></h5>
<p><em>backoff</em>指定<em>Filebeat</em>如何积极地抓取打开文件以进行更新。在大多数情况下，您可以使用默认值。</p>
<h5 id="backoffinit"><a class="header" href="#backoffinit"><code>backoff.init</code></a></h5>
<p>The <code>backoff.init</code> option defines how long Filebeat waits for the first time before checking a file again after EOF is reached. The backoff intervals increase exponentially. The default is 2s. Thus, the file is checked after 2 seconds, then 4 seconds, then 8 seconds and so on until it reaches the limit defined in <code>backoff.max</code>. Every time a new line appears in the file, the <code>backoff.init</code> value is reset to the initial value.</p>
<p><em>backoff.init</em>选项定义<em>Filebeat</em>在到达EOF后再次检查文件之前第一次等待多长时间。退避间隔呈指数增长。默认值为2s。因此，在2秒，然后4秒，然后8秒等之后检查文件，直到达到在<em>backoff.max</em>中定义的限制。每次文件中出现新行时，<em>backoff.init</em>值都会重置为初始值。</p>
<h5 id="backoffmax"><a class="header" href="#backoffmax"><code>backoff.max</code></a></h5>
<p>达到EOF后，Filebeat在再次检查文件之前等待的最长时间。多次从检查文件中退出后，等待时间将永远不会超过backoff.max。因为读取新行最多需要10s，所以为backoff.max指定10s意味着，在最坏的情况下，如果Filebeat多次退避，则可以将新行添加到日志文件中。默认为10s。</p>
<p>要求: (<code>backoff.init &lt;= backoff.max &lt;= prospector.scanner.check_interval</code>). If <code>backoff.max</code> needs to be higher, it is recommended to close the file handler instead and let Filebeat pick up the file again.</p>
<h5 id="file_identity"><a class="header" href="#file_identity"><code>file_identity</code></a></h5>
<p>Different <code>file_identity</code> methods can be configured to suit the environment where you are collecting log messages.</p>
<p>可以配置不同的<em>file_identity</em>方法以适合您收集日志消息的环境。</p>
<p>Changing <code>file_identity</code> methods between runs may result in duplicated events in the output.</p>
<p><strong>native</strong></p>
<p>The default behaviour of Filebeat is to differentiate between files using their inodes and device ids.</p>
<pre><code class="language-yaml">file_identity.native: ~
</code></pre>
<p><strong>path</strong></p>
<p>要根据文件的路径识别文件，请使用此策略。</p>
<p>仅当您的日志文件轮转到超出输入范围或根本不轮转的文件夹时，才使用此策略。否则你最终会出现重复的事件。
此策略不支持重命名文件。如果输入文件被重命名，如果新路径与输入的设置匹配，Filebeat将再次读取它。</p>
<pre><code class="language-yaml">file_identity.path: ~
</code></pre>
<p><strong>inode_marker</strong></p>
<p>如果设备id不时更改，则必须使用此方法区分文件。Windows不支持此选项。</p>
<p>Set the location of the marker file the following way:</p>
<pre><code class="language-yaml">file_identity.inode_marker.path: /logs/.filebeat-marker
</code></pre>
<h3 id="log-rotation"><a class="header" href="#log-rotation">Log rotation</a></h3>
<p>由于日志文件不断写入，因此必须<em>rotate</em>并清除它们，以防止记录器应用程序填满磁盘。旋转是由外部应用程序完成的，因此，Filebeat需要如何与之合作的信息。</p>
<p>从<em>rotate</em>文件中读取时，请确保路径配置包括活动文件和所有rotated文件。</p>
<p>默认情况下，Filebeat能够通过以下策略正确跟踪文件:</p>
<ul>
<li>创建: rotation时，创建新的活动文件名称 </li>
<li>重命名: 旋转文件已重命名</li>
</ul>
<p>但是，在copytruncate策略的情况下，您应该为Filebeat提供其他配置。</p>
<p><strong>rotation.external.strategy.copytruncate</strong></p>
<p>This functionality is in technical preview and may be changed or removed in a future release. Elastic will apply best effort to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.</p>
<p>If the log rotating application copies the contents of the active file and then truncates the original file, use these options to help Filebeat to read files correctly.</p>
<p>Set the option <code>suffix_regex</code> so Filebeat can tell active and rotated files apart. There are two supported suffix types in the input: numberic and date.</p>
<h4 id="numeric-suffix"><a class="header" href="#numeric-suffix">Numeric suffix</a></h4>
<p>If your rotated files have an incrementing index appended to the end of the filename, e.g. active file <code>apache.log</code> and the rotated files are named <code>apache.log.1</code>, <code>apache.log.2</code>, etc, use the following configuration.</p>
<pre><code class="language-yaml">---
rotation.external.strategy.copytruncate:
  suffix_regex: \.\d$
---
</code></pre>
<h4 id="date-suffix"><a class="header" href="#date-suffix">Date suffix</a></h4>
<p>If the rotation date is appended to the end of the filename, e.g. active file <code>apache.log</code> and the rotated files are named <code>apache.log-20210526</code>, <code>apache.log-20210527</code>, etc. use the following configuration:</p>
<pre><code class="language-yaml">---
rotation.external.strategy.copytruncate:
  suffix_regex: \-\d{6}$
  dateformat: -20060102
---
</code></pre>
<h5 id="encoding"><a class="header" href="#encoding"><code>encoding</code></a></h5>
<p>The file encoding to use for reading data that contains international characters. See the encoding names <a href="http://www.w3.org/TR/encoding/">recommended by the W3C for use in HTML5</a>.</p>
<h3 id="exclude_lines"><a class="header" href="#exclude_lines"><code>exclude_lines</code></a></h3>
<p>正则表达式列表，以匹配您希望Filebeat排除的行。Filebeat删除列表中与正则表达式匹配的任何行。默认情况下，不会丢弃任何行。空行被忽略。</p>
<p>The following example configures Filebeat to drop any lines that start with <code>DBG</code>.</p>
<pre><code class="language-yaml">filebeat.inputs:
- type: filestream
  ...
  exclude_lines: ['^DBG']
</code></pre>
<p>See <a href="https://www.elastic.co/guide/en/beats/filebeat/current/regexp-support.html"><em>Regular expression support</em></a> for a list of supported regexp patterns.</p>
<h3 id="include_lines"><a class="header" href="#include_lines"><code>include_lines</code></a></h3>
<p>A list of regular expressions to match the lines that you want Filebeat to include. Filebeat exports only the lines that match a regular expression in the list. By default, all lines are exported. Empty lines are ignored.</p>
<p>正则表达式列表，以匹配您希望Filebeat包含的行。Filebeat仅导出与列表中的正则表达式匹配的行。默认情况下，所有行都被导出。空行被忽略。</p>
<p>The following example configures Filebeat to export any lines that start with <code>ERR</code> or <code>WARN</code>:</p>
<pre><code class="language-yaml">filebeat.inputs:
- type: filestream
  ...
  include_lines: ['^ERR', '^WARN']
</code></pre>
<p>如果同时定义了include_lines和exclude_lines，则Filebeat首先执行<em>include_lines</em>，然后执行<em>exclude_lines</em>。两个选项的定义顺序无关紧要。include_lines选项将始终在exclude_lines选项之前执行，即使exclude_lines出现在config文件中的include_lines之前。</p>
<p>The following example exports all log lines that contain <code>sometext</code>, except for lines that begin with <code>DBG</code> (debug messages):</p>
<pre><code class="language-yaml">filebeat.inputs:
- type: filestream
  ...
  include_lines: ['sometext']
  exclude_lines: ['^DBG']
</code></pre>
<h3 id="buffer_size"><a class="header" href="#buffer_size"><code>buffer_size</code></a></h3>
<p>The size in bytes of the buffer that each harvester uses when fetching a file. The default is 16384.</p>
<p>每个收割机在获取文件时使用的缓冲区的大小 (以字节为单位)。默认值为16384。</p>
<h3 id="message_max_bytes"><a class="header" href="#message_max_bytes"><code>message_max_bytes</code></a></h3>
<p>单个日志消息可以具有的最大字节数。<em>mesage_max_bytes</em>之后的所有字节都将被丢弃并且不发送。默认值为10mb (10485760)。</p>
<h3 id="parsers"><a class="header" href="#parsers"><code>parsers</code></a></h3>
<p>此选项期望日志行必须经过的解析器列表。</p>
<p>Available parsers:</p>
<ul>
<li><code>multiline</code></li>
<li><code>ndjson</code></li>
<li><code>container</code></li>
</ul>
<p>在此示例中，Filebeat正在读取由3行组成并封装在单行JSON对象中的多行消息。多行消息存储在密钥msg下。</p>
<pre><code class="language-yaml">filebeat.inputs:
- type: filestream
  ...
  parsers:
    - ndjson:
        keys_under_root: true
        message_key: msg
    - multiline:
        type: counter
        lines_count: 3
</code></pre>
<p>See the available parser settings in detail below.</p>
<h4 id="multiline"><a class="header" href="#multiline"><code>multiline</code></a></h4>
<p>控制Filebeat如何处理跨越多行的日志消息的选项。有关配置多行选项的更多信息， See <a href="https://www.elastic.co/guide/en/beats/filebeat/current/multiline-examples.html">Multiline messages</a> for more information</p>
<h4 id="ndjson"><a class="header" href="#ndjson"><code>ndjson</code></a></h4>
<p>这些选项使Filebeat可以解码结构化为JSON消息的日志。Filebeat逐条处理日志，因此仅当每个消息有一个JSON对象时，JSON解码才起作用。</p>
<p>解码发生在行过滤之前。如果您设置了message_key选项，则可以将JSON解码与过滤相结合。这在应用程序日志包装在JSON对象中的情况下会很有帮助，比如使用Docker时。</p>
<p>Example configuration:</p>
<pre><code class="language-yaml">- ndjson:
    keys_under_root: true
    add_error_key: true
    message_key: log
</code></pre>
<p><code>keys_under_root</code></p>
<p>默认情况下，解码后的JSON放在输出文档中的 “json” 键下。如果启用此设置，则将在输出文档中复制键。默认值为false。</p>
<p><code>overwrite_keys</code></p>
<p>If <code>keys_under_root</code> and this setting are enabled, then the values from the decoded JSON object overwrite the fields that Filebeat normally adds (type, source, offset, etc.) in case of conflicts.</p>
<p><code>expand_keys</code></p>
<p>If this setting is enabled, Filebeat will recursively de-dot keys in the decoded JSON, and expand them into a hierarchical object structure. For example, <code>{&quot;a.b.c&quot;: 123}</code> would be expanded into <code>{&quot;a&quot;:{&quot;b&quot;:{&quot;c&quot;:123}}}</code>. This setting should be enabled when the input is produced by an <a href="https://github.com/elastic/ecs-logging">ECS logger</a>.</p>
<p><code>add_error_key</code></p>
<p>If this setting is enabled, Filebeat adds an &quot;error.message&quot; and &quot;error.type: json&quot; key in case of JSON unmarshalling errors or when a <code>message_key</code> is defined in the configuration but cannot be used.</p>
<p><code>message_key</code></p>
<p>An optional configuration setting that specifies a JSON key on which to apply the line filtering and multiline settings. If specified the key must be at the top level in the JSON object and the value associated with the key must be a string, otherwise no filtering or multiline aggregation will occur.</p>
<p>一个可选的配置设置，它指定要在其上应用行过滤和多行设置的JSON键。如果指定了键，则键必须位于JSON对象的顶层，并且与键关联的值必须是字符串，否则将不会发生过滤或多行聚合。</p>
<p><code>document_id</code></p>
<p>Option configuration setting that specifies the JSON key to set the document id. If configured, the field will be removed from the original JSON document and stored in <code>@metadata._id</code></p>
<p><code>ignore_decoding_error</code></p>
<p>An optional configuration setting that specifies if JSON decoding errors should be logged or not. If set to true, errors will not be logged. The default is false.</p>
<h4 id="container-1"><a class="header" href="#container-1"><code>container</code></a></h4>
<p>Use the <code>container</code> parser to extract information from containers log files. It parses lines into common message lines, extracting timestamps too.</p>
<ul>
<li>
<p><code>stream</code></p>
<p>Reads from the specified streams only: <code>all</code>, <code>stdout</code> or <code>stderr</code>. The default is <code>all</code>.</p>
</li>
<li>
<p><code>format</code></p>
<p>Use the given format when parsing logs: <code>auto</code>, <code>docker</code> or <code>cri</code>. The default is <code>auto</code>, it will automatically detect the format. To disable autodetection set any of the other options.</p>
</li>
</ul>
<p>The following snippet configures Filebeat to read the <code>stdout</code> stream from all containers under the default Kubernetes logs path:</p>
<pre><code class="language-yaml">  paths:
    - &quot;/var/log/containers/*.log&quot;
  parsers:
    - container:
        stream: stdout
</code></pre>
<h3 id="common-options"><a class="header" href="#common-options">Common options</a></h3>
<p>所有输入都支持以下配置选项。</p>
<h4 id="enabled"><a class="header" href="#enabled"><code>enabled</code></a></h4>
<p>使用启用选项启用和禁用输入。默认情况下，enabled设置为true。</p>
<h4 id="tags"><a class="header" href="#tags"><code>tags</code></a></h4>
<p>Filebeat包含在每个已发布事件的 “标签” 字段中的标签列表。标签使在Kibana中选择特定事件或在Logstash中应用条件过滤变得容易。这些标签将附加到常规配置中指定的标签列表中。</p>
<p>Example:</p>
<pre><code class="language-yaml">filebeat.inputs:
- type: filestream
  . . .
  tags: [&quot;json&quot;]
</code></pre>
<h4 id="fields"><a class="header" href="#fields"><code>fields</code></a></h4>
<p>您可以指定用于向输出添加其他信息的可选字段。例如，您可以添加可用于过滤日志数据的字段</p>
<p>字段可以是标量值、数组、字典或这些的任何嵌套组合。</p>
<p>默认情况下，您在此处指定的字段将在输出文档中的 <code>fields</code>子字典下分组。</p>
<p>将自定义字段存储为顶级字段，将<em>fields_under_root</em>选项设置为true。如果在常规配置中声明了重复字段，则其值将被此处声明的值覆盖。</p>
<pre><code class="language-yaml">filebeat.inputs:
- type: filestream
  . . .
  fields:
    app_id: query_engine_12
</code></pre>
<h4 id="fields_under_root"><a class="header" href="#fields_under_root"><code>fields_under_root</code></a></h4>
<p>如果将此选项设置为true，则自定义字段将存储为输出文档中的顶级字段，而不是在fileds 子字典下分组。如果自定义字段名称与Filebeat添加的其他字段名称冲突，则自定义字段会覆盖其他字段。</p>
<h4 id="processors"><a class="header" href="#processors"><code>processors</code></a></h4>
<p>A list of processors to apply to the input data.</p>
<p>See <a href="https://www.elastic.co/guide/en/beats/filebeat/current/filtering-and-enhancing-data.html"><em>Processors</em></a> for information about specifying processors in your config.</p>
<h4 id="pipeline-1"><a class="header" href="#pipeline-1"><code>pipeline</code></a></h4>
<p>The ingest pipeline ID to set for the events generated by this input.</p>
<p>The pipeline ID can also be configured in the Elasticsearch output, but this option usually results in simpler configuration files. If the pipeline is configured both in the input and output, the option from the input is used.</p>
<h4 id="keep_null"><a class="header" href="#keep_null"><code>keep_null</code></a></h4>
<p>如果将此选项设置为true，则将在输出文档中发布具有null值的字段。默认情况下，keep_null设置为false。</p>
<h4 id="index"><a class="header" href="#index"><code>index</code></a></h4>
<p>If present, this formatted string overrides the index for events from this input (for elasticsearch outputs), or sets the <code>raw_index</code> field of the event’s metadata (for other outputs). This string can only refer to the agent name and version and the event timestamp; for access to dynamic fields, use <code>output.elasticsearch.index</code> or a processor.</p>
<p>如果存在，则此格式化字符串将覆盖此输入 (对于elasticsearch输出) 中的事件的索引，或设置事件元数据的<em>raw_index</em>字段 (对于其他输出)。此字符串只能引用代理名称和版本以及事件时间戳; 要访问动态字段，请使用<em>output.elasticsearch.index</em>或处理器。</p>
<p>Example value: <code>&quot;%{[agent.name]}-myindex-%{+yyyy.MM.dd}&quot;</code> might expand to <code>&quot;filebeat-myindex-2019.11.01&quot;</code>.</p>
<h4 id="publisher_pipelinedisable_host"><a class="header" href="#publisher_pipelinedisable_host"><code>publisher_pipeline.disable_host</code></a></h4>
<p>默认情况下，所有事件都包含<em>host.name</em>。可以将此选项设置为true，以禁用将此字段添加到所有事件。默认值为false。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="消息队列功能介绍"><a class="header" href="#消息队列功能介绍">消息队列功能介绍</a></h2>
<h3 id="应用解耦"><a class="header" href="#应用解耦">应用解耦</a></h3>
<h3 id="流量削峰"><a class="header" href="#流量削峰">流量削峰</a></h3>
<h3 id="动态扩容"><a class="header" href="#动态扩容">动态扩容</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h3 id="前言-4"><a class="header" href="#前言-4">前言</a></h3>
<p>RocketMQ的消息投递分分为两种：一种是<code>生产者</code>往MQ Broker中投递</p>
<p>另外一种则是MQ broker 往<code>消费者</code> 投递(这种<code>投递</code>的说法是从<strong>消息传递的角度阐述的</strong>，实际上底层是<code>消费者</code>从MQ broker 中Pull拉取的)</p>
<h3 id="rocketmq的消息模型"><a class="header" href="#rocketmq的消息模型">RocketMQ的消息模型</a></h3>
<p><img src="6.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RocketMQ/../../images/rocketmq-msg-structure.png" alt="" /></p>
<p>为了提高MQ的可用性和灵活性，一个Topic在实际存储的过程中，采用了多队列的方式</p>
<p>每个消息队列在使用中应当保证<strong>先入先出</strong>（FIFO,First In First Out）的方式进行消费</p>
<p>那么，基于这种模型，就会引申出两个问题：</p>
<p><strong>生产者</strong> 在发送相同Topic的消息时，消息体应当被放置到哪一个消息队列(MessageQueue)中?</p>
<p><strong>消费者</strong> 在消费消息时，应当从哪些消息队列中拉取消息?</p>
<h3 id="生产者producer投递消息的策略"><a class="header" href="#生产者producer投递消息的策略">生产者(Producer)投递消息的策略</a></h3>
<h4 id="默认投递方式基于queue队列轮询算法投递"><a class="header" href="#默认投递方式基于queue队列轮询算法投递">默认投递方式：基于<code>Queue队列</code>轮询算法投递</a></h4>
<p>默认情况下，采用了最简单的轮询算法，这种算法有个很好的特性就是，保证每一个<code>Queue队列</code>的消息投递数量尽可能均匀，算法如下所示：</p>
<pre><code class="language-java">/**
*  根据 TopicPublishInfo Topic发布信息对象中维护的index，每次选择队列时，都会递增
*  然后根据 index % queueSize 进行取余，达到轮询的效果
*
*/
public MessageQueue selectOneMessageQueue(final TopicPublishInfo tpInfo, final String lastBrokerName) {
        return tpInfo.selectOneMessageQueue(lastBrokerName);
}

/**
*  TopicPublishInfo Topic发布信息对象中
*/
public class TopicPublishInfo {
    //基于线程上下文的计数递增，用于轮询目的
    private volatile ThreadLocalIndex sendWhichQueue = new ThreadLocalIndex();
   

    public MessageQueue selectOneMessageQueue(final String lastBrokerName) {
        if (lastBrokerName == null) {
            return selectOneMessageQueue();
        } else {
            int index = this.sendWhichQueue.getAndIncrement();
            for (int i = 0; i &lt; this.messageQueueList.size(); i++) {
                //轮询计算
                int pos = Math.abs(index++) % this.messageQueueList.size();
                if (pos &lt; 0)
                    pos = 0;
                MessageQueue mq = this.messageQueueList.get(pos);
                if (!mq.getBrokerName().equals(lastBrokerName)) {
                    return mq;
                }
            }
            return selectOneMessageQueue();
        }
    }

    public MessageQueue selectOneMessageQueue() {
        int index = this.sendWhichQueue.getAndIncrement();
        int pos = Math.abs(index) % this.messageQueueList.size();
        if (pos &lt; 0)
            pos = 0;
        return this.messageQueueList.get(pos);
    }
}
</code></pre>
<h4 id="消息投递延迟最小"><a class="header" href="#消息投递延迟最小">消息投递延迟最小</a></h4>
<p>默认的投递方式比较简单，但是也暴露了一个问题，就是有些<code>Queue队列</code>可能由于自身数量积压等原因，可能在投递的过程比较长，对于这样的<code>Queue队列</code>会影响后续投递的效果。</p>
<p>基于这种现象，RocketMQ在每发送一个MQ消息后，都会统计一下消息投递的<code>时间延迟</code>，根据这个<code>时间延迟</code>，可以知道往哪些<code>Queue队列</code>投递的速度快</p>
<p>在这种场景下，会优先使用<code>消息投递延迟最小</code>的策略，如果没有生效，再使用<code>Queue队列轮询</code>的方式。</p>
<pre><code class="language-java">public class MQFaultStrategy {
    /**
     * 根据 TopicPublishInfo 内部维护的index,在每次操作时，都会递增，
     * 然后根据 index % queueList.size(),使用了轮询的基础算法
     *
     */
    public MessageQueue selectOneMessageQueue(final TopicPublishInfo tpInfo, final String lastBrokerName) {
        if (this.sendLatencyFaultEnable) {
            try {
                // 从queueid 为 0 开始，依次验证broker 是否有效，如果有效
                int index = tpInfo.getSendWhichQueue().getAndIncrement();
                for (int i = 0; i &lt; tpInfo.getMessageQueueList().size(); i++) {
                    //基于index和队列数量取余，确定位置
                    int pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();
                    if (pos &lt; 0)
                        pos = 0;
                    MessageQueue mq = tpInfo.getMessageQueueList().get(pos);
                    if (latencyFaultTolerance.isAvailable(mq.getBrokerName())) {
                        if (null == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))
                            return mq;
                    }
                }
                
                // 从延迟容错broker列表中挑选一个容错性最好的一个 broker
                final String notBestBroker = latencyFaultTolerance.pickOneAtLeast();
                int writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);
                if (writeQueueNums &gt; 0) {
                     // 取余挑选其中一个队列
                    final MessageQueue mq = tpInfo.selectOneMessageQueue();
                    if (notBestBroker != null) {
                        mq.setBrokerName(notBestBroker);
                        mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);
                    }
                    return mq;
                } else {
                    latencyFaultTolerance.remove(notBestBroker);
                }
            } catch (Exception e) {
                log.error(&quot;Error occurred when selecting message queue&quot;, e);
            }
          // 取余挑选其中一个队列
            return tpInfo.selectOneMessageQueue();
        }

        return tpInfo.selectOneMessageQueue(lastBrokerName);
    }
}
</code></pre>
<h4 id="顺序消息的投递方式"><a class="header" href="#顺序消息的投递方式">顺序消息的投递方式</a></h4>
<p><strong>上述两种投递方式属于对消息投递的时序性没有要求的场景，这种投递的速度和效率比较高。而在有些场景下，需要保证同类型消息投递和消费的顺序性。</strong></p>
<pre><code>这种情况下，我们希望消费者消费消息的顺序和我们发送是一致的，然而，有上述MQ的投递和消费机制，我们无法保证顺序是正确的，对于顺序异常的消息，消费者 即使有一定的状态容错，也不能完全处理好这么多种随机出现组合情况。
</code></pre>
<p>基于上述的情况，RockeMQ采用了这种实现方案：<strong>对于相同订单号的消息，通过一定的策略，将其放置在一个 queue队列中</strong>，然后消费者再采用一定的策略(一个线程独立处理一个queue,保证处理消息的顺序性)，能够保证消费的顺序性</p>
<h5 id="消息投递队列选择"><a class="header" href="#消息投递队列选择">消息投递队列选择</a></h5>
<p><code>生产者</code>是如何能将相同订单号的消息发送到同一个<code>queue队列</code>的：</p>
<p>默认实现：</p>
<table><thead><tr><th style="text-align: left">投递策略</th><th style="text-align: left">策略实现类</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">随机分配策略</td><td style="text-align: left">SelectMessageQueueByRandom</td><td style="text-align: left">使用了简单的随机数选择算法</td></tr>
<tr><td style="text-align: left">基于Hash分配策略</td><td style="text-align: left">SelectMessageQueueByHash</td><td style="text-align: left">根据附加参数的Hash值，按照消息队列列表的大小取余数，得到消息队列的index</td></tr>
<tr><td style="text-align: left">基于机器机房位置分配策略</td><td style="text-align: left">SelectMessageQueueByMachineRoom</td><td style="text-align: left">开源的版本没有具体的实现，基本的目的应该是机器的就近原则分配</td></tr>
</tbody></table>
<h3 id="如何为消费者分配queue队列"><a class="header" href="#如何为消费者分配queue队列">如何为消费者分配<code>queue队列</code></a></h3>
<p>RocketMQ对于消费者消费消息有两种形式：</p>
<ul>
<li><code>BROADCASTING</code>:广播式消费，这种模式下，一个消息会被通知到每一个<code>消费者</code></li>
<li><code>CLUSTERING</code>: 集群式消费，这种模式下，一个消息最多只会被投递到一个<code>消费者</code>上进行消费 模式如下：</li>
</ul>
<h4 id="基于queue队列的分配"><a class="header" href="#基于queue队列的分配"><strong>基于queue队列的分配</strong></a></h4>
<p>在RoketMQ底层，消息指定分配给消费者的实现，是通过<code>queue队列</code>分配给<code>消费者</code>的方式完成的：也就是说，<code>消息</code>分配的单位是消息所在的<code>queue队列</code></p>
<p>将<code>queue队列</code>指定给特定的<code>消费者</code>后，<code>queue队列</code>内的所有消息将会被指定到<code>消费者</code>进行消费。</p>
<p>RocketMQ定义了策略接口<code>AllocateMessageQueueStrategy</code>，对于给定的<code>消费者分组</code>,和<code>消息队列列表</code>、<code>消费者列表</code>，<code>当前消费者</code>应当被分配到哪些<code>queue队列</code></p>
<pre><code class="language-java">/**
 * 为消费者分配queue的策略算法接口
 */
public interface AllocateMessageQueueStrategy {

    /**
     * Allocating by consumer id
     *
     * @param consumerGroup 当前 consumer群组
     * @param currentCID 当前consumer id
     * @param mqAll 当前topic的所有queue实例引用
     * @param cidAll 当前 consumer群组下所有的consumer id set集合
     * @return 根据策略给当前consumer分配的queue列表
     */
    List&lt;MessageQueue&gt; allocate(
        final String consumerGroup,
        final String currentCID,
        final List&lt;MessageQueue&gt; mqAll,
        final List&lt;String&gt; cidAll
    );

    /**
     * 算法名称
     *
     * @return The strategy name
     */
    String getName();
}
</code></pre>
<h4 id="消费队列分配算法"><a class="header" href="#消费队列分配算法"><strong>消费队列分配算法</strong></a></h4>
<table><thead><tr><th style="text-align: left">算法名称</th><th style="text-align: left">含义</th></tr></thead><tbody>
<tr><td style="text-align: left">AllocateMessageQueueAveragely</td><td style="text-align: left">平均分配算法</td></tr>
<tr><td style="text-align: left">AllocateMessageQueueAveragelyByCircle</td><td style="text-align: left">基于环形平均分配算法</td></tr>
<tr><td style="text-align: left">AllocateMachineRoomNearby</td><td style="text-align: left">基于机房临近原则算法</td></tr>
<tr><td style="text-align: left">AllocateMessageQueueByMachineRoom</td><td style="text-align: left">基于机房分配算法</td></tr>
<tr><td style="text-align: left">AllocateMessageQueueConsistentHash</td><td style="text-align: left">基于一致性hash算法</td></tr>
<tr><td style="text-align: left">AllocateMessageQueueByConfig</td><td style="text-align: left">基于配置分配算法</td></tr>
</tbody></table>
<h4 id="顺序-平均分配算法"><a class="header" href="#顺序-平均分配算法">顺序-平均分配算法</a></h4>
<p><img src="6.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RocketMQ/../../images/rocketmq-order-allocation.png" alt="" /></p>
<p><strong>源码</strong></p>
<pre><code class="language-java">package org.apache.rocketmq.client.consumer.rebalance;
import java.util.ArrayList;
import java.util.List;
import org.apache.rocketmq.client.consumer.AllocateMessageQueueStrategy;
import org.apache.rocketmq.client.log.ClientLogger;
import org.apache.rocketmq.logging.InternalLogger;
import org.apache.rocketmq.common.message.MessageQueue;
/**
 * Average Hashing queue algorithm
 */
public class AllocateMessageQueueAveragely implements AllocateMessageQueueStrategy {
    private final InternalLogger log = ClientLogger.getLog();

    @Override
    public List&lt;MessageQueue&gt; allocate(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,
        List&lt;String&gt; cidAll) {
        if (currentCID == null || currentCID.length() &lt; 1) {
            throw new IllegalArgumentException(&quot;currentCID is empty&quot;);
        }
        if (mqAll == null || mqAll.isEmpty()) {
            throw new IllegalArgumentException(&quot;mqAll is null or mqAll empty&quot;);
        }
        if (cidAll == null || cidAll.isEmpty()) {
            throw new IllegalArgumentException(&quot;cidAll is null or cidAll empty&quot;);
        }

        List&lt;MessageQueue&gt; result = new ArrayList&lt;MessageQueue&gt;();
        if (!cidAll.contains(currentCID)) {
            log.info(&quot;[BUG] ConsumerGroup: {} The consumerId: {} not in cidAll: {}&quot;,
                consumerGroup,
                currentCID,
                cidAll);
            return result;
        }
				//当前消费者
        int index = cidAll.indexOf(currentCID);
        //获取多余的消费队列
        int mod = mqAll.size() % cidAll.size();
        //计算 当前消费者 应该所得的 消费队列的 个数
        int averageSize =
            mqAll.size() &lt;= cidAll.size() ? 1 : (mod &gt; 0 &amp;&amp; index &lt; mod ? mqAll.size() / cidAll.size()
                + 1 : mqAll.size() / cidAll.size());
        //计算 当前消费者所位于 消费队列 列表中的起点
        int startIndex = (mod &gt; 0 &amp;&amp; index &lt; mod) ? index * averageSize : index * averageSize + mod;
        //如果 消费者过多，mqAll.size() - startIndex可能会 为负数，这就可能导致 后续的消费者无法获取到队列
        int range = Math.min(averageSize, mqAll.size() - startIndex);
        for (int i = 0; i &lt; range; i++) {
            result.add(mqAll.get((startIndex + i) % mqAll.size()));
        }
        return result;
    }

    @Override
    public String getName() {
        return &quot;AVG&quot;;
    }
}
</code></pre>
<h4 id="环形平均算法"><a class="header" href="#环形平均算法">环形平均算法</a></h4>
<p><img src="6.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RocketMQ/../../images/rocketmq-consumerqueue-cycle-selector.png" alt="" /></p>
<p><strong>环形顺序分配</strong></p>
<p>这种算法最终分配的结果是： <code>consumer-1</code>: #0，#4，#8 <code>consumer-2</code>: #1,  #5, # 9 <code>consumer-3</code>: #2，#6 <code>consumer-4</code>: #3，#7</p>
<pre><code class="language-java">package org.apache.rocketmq.client.consumer.rebalance;
import java.util.ArrayList;
import java.util.List;
import org.apache.rocketmq.client.consumer.AllocateMessageQueueStrategy;
import org.apache.rocketmq.client.log.ClientLogger;
import org.apache.rocketmq.logging.InternalLogger;
import org.apache.rocketmq.common.message.MessageQueue;

/**
 * Cycle average Hashing queue algorithm
 */
public class AllocateMessageQueueAveragelyByCircle implements AllocateMessageQueueStrategy {
    private final InternalLogger log = ClientLogger.getLog();

    @Override
    public List&lt;MessageQueue&gt; allocate(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,
        List&lt;String&gt; cidAll) {
     		......	
        int index = cidAll.indexOf(currentCID);
        for (int i = index; i &lt; mqAll.size(); i++) {
            if (i % cidAll.size() == index) {
                result.add(mqAll.get(i));
            }
        }
        return result;
    }

    @Override
    public String getName() {
        return &quot;AVG_BY_CIRCLE&quot;;
    }
}
</code></pre>
<h4 id="基于机房临近原则算法"><a class="header" href="#基于机房临近原则算法">基于机房临近原则算法</a></h4>
<p><img src="6.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RocketMQ/../../images/rocketmq-messagequeue-machine-rom-nearby.png" alt="" /></p>
<p>对于跨机房的场景，会存在网络、稳定性和隔离心的原因，该算法会根据<code>queue</code>的部署机房位置和<code>消费者consumer</code>的位置，过滤出当前<code>消费者consumer</code>相同机房的<code>queue队列</code>，然后再结合上述的算法，如基于平均分配算法在<code>queue队列</code>子集的基础上再挑选。相关代码实现如下：</p>
<pre><code class="language-java">package org.apache.rocketmq.client.consumer.rebalance;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import org.apache.commons.lang3.StringUtils;
import org.apache.rocketmq.client.consumer.AllocateMessageQueueStrategy;
import org.apache.rocketmq.client.log.ClientLogger;
import org.apache.rocketmq.common.message.MessageQueue;
import org.apache.rocketmq.logging.InternalLogger;

/**
 * An allocate strategy proxy for based on machine room nearside priority. An actual allocate strategy can be
 * specified.
 *
 * If any consumer is alive in a machine room, the message queue of the broker which is deployed in the same machine
 * should only be allocated to those. Otherwise, those message queues can be shared along all consumers since there are
 * no alive consumer to monopolize them.
 */
public class AllocateMachineRoomNearby implements AllocateMessageQueueStrategy {
    private final InternalLogger log = ClientLogger.getLog();

    private final AllocateMessageQueueStrategy allocateMessageQueueStrategy;//actual allocate strategy
    private final MachineRoomResolver machineRoomResolver;

    public AllocateMachineRoomNearby(AllocateMessageQueueStrategy allocateMessageQueueStrategy,
        MachineRoomResolver machineRoomResolver) throws NullPointerException {
        if (allocateMessageQueueStrategy == null) {
            throw new NullPointerException(&quot;allocateMessageQueueStrategy is null&quot;);
        }

        if (machineRoomResolver == null) {
            throw new NullPointerException(&quot;machineRoomResolver is null&quot;);
        }

        this.allocateMessageQueueStrategy = allocateMessageQueueStrategy;
        this.machineRoomResolver = machineRoomResolver;
    }

    @Override
    public List&lt;MessageQueue&gt; allocate(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,
        List&lt;String&gt; cidAll) {
        ......
        //group mq by machine room: broker部署机房
        Map&lt;String/*machine room */, List&lt;MessageQueue&gt;&gt; mr2Mq = new TreeMap&lt;String, List&lt;MessageQueue&gt;&gt;();
        for (MessageQueue mq : mqAll) {
            String brokerMachineRoom = machineRoomResolver.brokerDeployIn(mq);
            if (StringUtils.isNoneEmpty(brokerMachineRoom)) {
                if (mr2Mq.get(brokerMachineRoom) == null) {
                    mr2Mq.put(brokerMachineRoom, new ArrayList&lt;MessageQueue&gt;());
                }
                mr2Mq.get(brokerMachineRoom).add(mq);
            } else {
                throw new IllegalArgumentException(&quot;Machine room is null for mq &quot; + mq);
            }
        }

        //group consumer by machine room，consumer部署机房
        Map&lt;String/*machine room */, List&lt;String/*clientId*/&gt;&gt; mr2c = new TreeMap&lt;String, List&lt;String&gt;&gt;();
        for (String cid : cidAll) {
            String consumerMachineRoom = machineRoomResolver.consumerDeployIn(cid);
            if (StringUtils.isNoneEmpty(consumerMachineRoom)) {
                if (mr2c.get(consumerMachineRoom) == null) {
                    mr2c.put(consumerMachineRoom, new ArrayList&lt;String&gt;());
                }
                mr2c.get(consumerMachineRoom).add(cid);
            } else {
                throw new IllegalArgumentException(&quot;Machine room is null for consumer id &quot; + cid);
            }
        }

        List&lt;MessageQueue&gt; allocateResults = new ArrayList&lt;MessageQueue&gt;();

        //1.allocate the mq that deploy in the same machine room with the current consumer
        String currentMachineRoom = machineRoomResolver.consumerDeployIn(currentCID);
        List&lt;MessageQueue&gt; mqInThisMachineRoom = mr2Mq.remove(currentMachineRoom);
        List&lt;String&gt; consumerInThisMachineRoom = mr2c.get(currentMachineRoom);
      	//当前存在 borker 与 consumer部署在同一机房，则使用其余分配算法继续分配
        if (mqInThisMachineRoom != null &amp;&amp; !mqInThisMachineRoom.isEmpty()) {
            allocateResults.addAll(allocateMessageQueueStrategy.allocate(consumerGroup, currentCID, mqInThisMachineRoom, consumerInThisMachineRoom));
        }

      	//broker没有对应的 consumer部署的 集群 共享所有的 message queue
        //2.allocate the rest mq to each machine room if there are no consumer alive in that machine room
        for (String machineRoom : mr2Mq.keySet()) {
            if (!mr2c.containsKey(machineRoom)) { // no alive consumer in the corresponding machine room, so all consumers share these queues
                allocateResults.addAll(allocateMessageQueueStrategy.allocate(consumerGroup, currentCID, mr2Mq.get(machineRoom), cidAll));
            }
        }

        return allocateResults;
    }

    @Override
    public String getName() {
        return &quot;MACHINE_ROOM_NEARBY&quot; + &quot;-&quot; + allocateMessageQueueStrategy.getName();
    }

    /**
     * A resolver object to determine which machine room do the message queues or clients are deployed in.
     *
     * AllocateMachineRoomNearby will use the results to group the message queues and clients by machine room.
     *
     * The result returned from the implemented method CANNOT be null.
     */
    public interface MachineRoomResolver {
        String brokerDeployIn(MessageQueue messageQueue);

        String consumerDeployIn(String clientID);
    }
}

</code></pre>
<h4 id="基于机房分配算法"><a class="header" href="#基于机房分配算法">基于机房分配算法</a></h4>
<pre><code>该算法适用于属于同一个机房内部的消息，去分配queue。这种方式非常明确，基于上面的机房临近分配算法的场景，这种更彻底，直接指定基于机房消费的策略。这种方式具有强约定性，比如broker名称按照机房的名称进行拼接，在算法中通过约定解析进行分配。
</code></pre>
<pre><code class="language-java">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.rocketmq.client.consumer.rebalance;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import org.apache.rocketmq.client.consumer.AllocateMessageQueueStrategy;
import org.apache.rocketmq.common.message.MessageQueue;

/**
 * Computer room Hashing queue algorithm, such as Alipay logic room
 */
public class AllocateMessageQueueByMachineRoom implements AllocateMessageQueueStrategy {
    private Set&lt;String&gt; consumeridcs;

    @Override
    public List&lt;MessageQueue&gt; allocate(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,
        List&lt;String&gt; cidAll) {
        List&lt;MessageQueue&gt; result = new ArrayList&lt;MessageQueue&gt;();
        int currentIndex = cidAll.indexOf(currentCID);
        if (currentIndex &lt; 0) {
            return result;
        }
        List&lt;MessageQueue&gt; premqAll = new ArrayList&lt;MessageQueue&gt;();
      	//挑选配置的 IDC
        for (MessageQueue mq : mqAll) {
            String[] temp = mq.getBrokerName().split(&quot;@&quot;);
            if (temp.length == 2 &amp;&amp; consumeridcs.contains(temp[0])) {
                premqAll.add(mq);
            }
        }

        int mod = premqAll.size() / cidAll.size();
        int rem = premqAll.size() % cidAll.size();
        int startIndex = mod * currentIndex;
        int endIndex = startIndex + mod;
      	//根据 mod rem 挑选队列
        for (int i = startIndex; i &lt; endIndex; i++) {
            result.add(premqAll.get(i));
        }
      	//如果 currentIndex在当前 rem的覆盖范围中
        if (rem &gt; currentIndex) {
            result.add(premqAll.get(currentIndex + mod * cidAll.size()));
        }
        return result;
    }

    @Override
    public String getName() {
        return &quot;MACHINE_ROOM&quot;;
    }

    public Set&lt;String&gt; getConsumeridcs() {
        return consumeridcs;
    }

    public void setConsumeridcs(Set&lt;String&gt; consumeridcs) {
        this.consumeridcs = consumeridcs;
    }
}
</code></pre>
<h4 id="基于一致性hash算法"><a class="header" href="#基于一致性hash算法">基于一致性hash算法</a></h4>
<p>使用这种算法，会将<code>consumer消费者</code>作为Node节点构造成一个hash环，然后<code>queue队列</code>通过这个hash环来决定被分配给哪个<code>consumer消费者</code>。</p>
<p><strong>什么是一致性hash 算法</strong> ? 一致性hash算法用于在分布式系统中，保证数据的一致性而提出的一种基于hash环实现的算法，：<a href="https://www.cnblogs.com/lpfuture/p/5796398.html">一致性哈希算法原理</a></p>
<p>代码实现原理：<a href="6.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RocketMQ/MQ%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html">MQ的一致性算法实现原理</a></p>
<pre><code class="language-java">package org.apache.rocketmq.client.consumer.rebalance;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import org.apache.rocketmq.client.consumer.AllocateMessageQueueStrategy;
import org.apache.rocketmq.client.log.ClientLogger;
import org.apache.rocketmq.common.consistenthash.ConsistentHashRouter;
import org.apache.rocketmq.common.consistenthash.HashFunction;
import org.apache.rocketmq.common.consistenthash.Node;
import org.apache.rocketmq.logging.InternalLogger;
import org.apache.rocketmq.common.message.MessageQueue;

/**
 * Consistent Hashing queue algorithm
 */
public class AllocateMessageQueueConsistentHash implements AllocateMessageQueueStrategy {
    private final InternalLogger log = ClientLogger.getLog();

    private final int virtualNodeCnt;
    private final HashFunction customHashFunction;

    public AllocateMessageQueueConsistentHash() {
        this(10);
    }

    public AllocateMessageQueueConsistentHash(int virtualNodeCnt) {
        this(virtualNodeCnt, null);
    }

    public AllocateMessageQueueConsistentHash(int virtualNodeCnt, HashFunction customHashFunction) {
        if (virtualNodeCnt &lt; 0) {
            throw new IllegalArgumentException(&quot;illegal virtualNodeCnt :&quot; + virtualNodeCnt);
        }
        this.virtualNodeCnt = virtualNodeCnt;
        this.customHashFunction = customHashFunction;
    }

    @Override
    public List&lt;MessageQueue&gt; allocate(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,
        List&lt;String&gt; cidAll) {

        Collection&lt;ClientNode&gt; cidNodes = new ArrayList&lt;ClientNode&gt;();
        for (String cid : cidAll) {
            cidNodes.add(new ClientNode(cid));
        }

        final ConsistentHashRouter&lt;ClientNode&gt; router; //for building hash ring
        if (customHashFunction != null) {
            router = new ConsistentHashRouter&lt;ClientNode&gt;(cidNodes, virtualNodeCnt, customHashFunction);
        } else {
            router = new ConsistentHashRouter&lt;ClientNode&gt;(cidNodes, virtualNodeCnt);
        }

        List&lt;MessageQueue&gt; results = new ArrayList&lt;MessageQueue&gt;();
        for (MessageQueue mq : mqAll) {
            ClientNode clientNode = router.routeNode(mq.toString());
            if (clientNode != null &amp;&amp; currentCID.equals(clientNode.getKey())) {
                results.add(mq);
            }
        }
        return results;
    }

    @Override
    public String getName() {
        return &quot;CONSISTENT_HASH&quot;;
    }

    private static class ClientNode implements Node {
        private final String clientID;

        public ClientNode(String clientID) {
            this.clientID = clientID;
        }

        @Override
        public String getKey() {
            return clientID;
        }
    }
}
</code></pre>
<h4 id="基于配置分配算法"><a class="header" href="#基于配置分配算法">基于配置分配算法</a></h4>
<pre><code>AllocateMessageQueueByConfig
</code></pre>
<h3 id="多个broker模式下同一个topic的分区是如何分配的"><a class="header" href="#多个broker模式下同一个topic的分区是如何分配的">多个broker模式下同一个Topic的分区是如何分配的</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h3 id="物理节点"><a class="header" href="#物理节点">物理节点</a></h3>
<pre><code class="language-java">package org.apache.rocketmq.common.consistenthash;

/**
 * Represent a node which should be mapped to a hash ring
 */
public interface Node {
    /**
     * @return the key which will be used for hash mapping
     */
    String getKey();
}

</code></pre>
<h3 id="虚拟节点"><a class="header" href="#虚拟节点">虚拟节点</a></h3>
<pre><code class="language-java">package org.apache.rocketmq.common.consistenthash;

public class VirtualNode&lt;T extends Node&gt; implements Node {
    final T physicalNode;
    final int replicaIndex;

    public VirtualNode(T physicalNode, int replicaIndex) {
        this.replicaIndex = replicaIndex;
        this.physicalNode = physicalNode;
    }

    @Override
    public String getKey() {
        return physicalNode.getKey() + &quot;-&quot; + replicaIndex;
    }

    public boolean isVirtualNodeOf(T pNode) {
        return physicalNode.getKey().equals(pNode.getKey());
    }

    public T getPhysicalNode() {
        return physicalNode;
    }
}

</code></pre>
<h3 id="mq节点"><a class="header" href="#mq节点">MQ节点</a></h3>
<pre><code class="language-java">private static class ClientNode implements Node {
  private final String clientID;

  public ClientNode(String clientID) {
    this.clientID = clientID;
  }

  @Override
  public String getKey() {
    return clientID;
  }
}
</code></pre>
<h3 id="环对象"><a class="header" href="#环对象">环对象</a></h3>
<p><strong>利用 sortedMap 实现的 Hash环</strong></p>
<pre><code class="language-java">private final SortedMap&lt;Long, VirtualNode&lt;T&gt;&gt; ring = new TreeMap&lt;Long, VirtualNode&lt;T&gt;&gt;();
</code></pre>
<h3 id="consistenthashrouter"><a class="header" href="#consistenthashrouter">ConsistentHashRouter</a></h3>
<h4 id="添加节点"><a class="header" href="#添加节点">添加节点</a></h4>
<pre><code class="language-java">//org.apache.rocketmq.common.consistenthash.ConsistentHashRouter#addNode

public void addNode(T pNode, int vNodeCount) {
  if (vNodeCount &lt; 0)
    throw new IllegalArgumentException(&quot;illegal virtual node counts :&quot; + vNodeCount);
  //先判断 是否之前有加入过环，如果有则 从上次的虚拟节点开始
  int existingReplicas = getExistingReplicas(pNode);
  for (int i = 0; i &lt; vNodeCount; i++) {
    VirtualNode&lt;T&gt; vNode = new VirtualNode&lt;T&gt;(pNode, i + existingReplicas);
    ring.put(hashFunction.hash(vNode.getKey()), vNode);
  }
}
</code></pre>
<h4 id="移除节点"><a class="header" href="#移除节点">移除节点</a></h4>
<p><strong>移除物理节点对应的所有虚拟节点</strong></p>
<pre><code class="language-java">public void removeNode(T pNode) {
  Iterator&lt;Long&gt; it = ring.keySet().iterator();
  while (it.hasNext()) {
    Long key = it.next();
    VirtualNode&lt;T&gt; virtualNode = ring.get(key);
    if (virtualNode.isVirtualNodeOf(pNode)) {
      it.remove();
    }
  }
}
</code></pre>
<h4 id="路由"><a class="header" href="#路由">路由</a></h4>
<pre><code class="language-java">public T routeNode(String objectKey) {
  if (ring.isEmpty()) {
    return null;
  }
  Long hashVal = hashFunction.hash(objectKey);
  SortedMap&lt;Long, VirtualNode&lt;T&gt;&gt; tailMap = ring.tailMap(hashVal);
  Long nodeHashVal = !tailMap.isEmpty() ? tailMap.firstKey() : ring.firstKey();
  return ring.get(nodeHashVal).getPhysicalNode();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技术架构"><a class="header" href="#技术架构">技术架构</a></h1>
<p><img src="6.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RocketMQ/../../images/rocketmq_architecture_1.png" alt="/images/rocketmq_architecture_1.png" /></p>
<p>RocketMQ架构上主要分为四部分，如上图所示:</p>
<ul>
<li><strong>Producer</strong>: 消息发布的角色，支持分布式集群方式部署,Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</li>
<li><strong>Consumer</strong> : 消息消费的角色，支持分布式集群方式部署，支持以push推，pull拉两种模式对消息进行消费，同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制，可以满足大多数用户的需求。</li>
<li><strong>NameServer</strong>:NameServer是一个非常简单的Topic路由注册中心，其角色类似Dubbo中的zookeeper，支持Broker的动态注册与发现。主要包括两个功能：
<ul>
<li>Broker管理，NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据，供心跳检测机制，检查Broker是否还存活</li>
<li>路由信息管理，每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。然后Producer和Conumser通过NameServer就可以知道整个Broker集群的路由信息，从而进行消息的投递和消费</li>
</ul>
</li>
</ul>
<p>​		NameServer通常也是集群的方式部署，各实例间相互不进行信息通讯，Broker是向每一台NameServer注册		自己的路由信息，所以每一个NameServer实例上面都保存一份完整的路由信息</p>
<p>​		当某个NameServer因某种原因下线了，Broker仍然可以向其它NameServer同步其路由信息，Producer,Consumer仍然可以动态感知Broker的路由的信息</p>
<ul>
<li><strong>BrokerServer</strong>：Broker主要负责消息的存储、投递和查询以及服务高可用保证，为了实现这些功能，Broker包含了以下几个重要子模块。
<ol>
<li>Remoting Module：整个Broker的实体，负责处理来自clients端的请求。</li>
<li>Client Manager：负责管理客户端(Producer/Consumer)和维护Consumer的Topic订阅信息</li>
<li>Store Service：提供方便简单的API接口处理消息存储到物理硬盘和查询功能。</li>
<li>HA Service：高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能。</li>
<li>Index Service：根据特定的Message key对投递到Broker的消息进行索引服务，以提供消息的快速查询。</li>
</ol>
</li>
</ul>
<p><img src="6.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RocketMQ/../../images/rocketmq_architecture_2.png" alt="" /></p>
<h1 id="部署架构"><a class="header" href="#部署架构">部署架构</a></h1>
<h2 id="部署结构图"><a class="header" href="#部署结构图">部署结构图</a></h2>
<p><img src="6.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RocketMQ/../../images/rocketmq_architecture_3.png" alt="" /></p>
<h2 id="rocketmq-网络部署特点"><a class="header" href="#rocketmq-网络部署特点">RocketMQ 网络部署特点</a></h2>
<ul>
<li>
<p>NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</p>
</li>
<li>
<p>Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master</p>
<ul>
<li>Master与Slave 的对应关系通过指定相同的BrokerName，不同的BrokerId 来定义，BrokerId为0表示Master，非0表示Slave</li>
<li>Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer</li>
<li>注意：当前RocketMQ版本在部署架构上支持一Master多Slave，但只有BrokerId=1的从服务器才会参与消息的读负载。</li>
</ul>
</li>
<li>
<p>Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic 服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。</p>
</li>
<li>
<p>Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，消费者在向Master拉取消息时，Master服务器会根据拉取偏移量与最大偏移量的距离（判断是否读老消息，产生读I/O），以及从服务器是否可读等因素建议下一次是从Master还是Slave拉取。</p>
</li>
</ul>
<p>结合部署架构图，描述集群工作流程：</p>
<ol>
<li>启动NameServer，NameServer起来后监听端口，等待Broker、Producer、Consumer连上来，相当于一个路由控制中心。</li>
<li>Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。心跳包中包含当前Broker信息(IP+端口等)以及存储所有Topic信息。注册成功后，NameServer集群中就有Topic跟Broker的映射关系。</li>
<li>收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。</li>
<li>Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。</li>
<li>Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。</li>
</ol>
<h1 id="设计design"><a class="header" href="#设计design">设计(design)</a></h1>
<h2 id="消息存储"><a class="header" href="#消息存储">消息存储</a></h2>
<p>消息存储是RocketMQ中最为复杂和最为重要的一部分，本节将分别从</p>
<ul>
<li>RocketMQ的消息存储整体架构</li>
<li>PageCache与Mmap内存映射</li>
<li>RocketMQ中两种不同的刷盘方式</li>
</ul>
<p>三方面来分别展开叙述。</p>
<h3 id="消息存储整体架构"><a class="header" href="#消息存储整体架构">消息存储整体架构</a></h3>
<p>消息存储架构图中主要有下面三个跟消息存储相关的文件构成。</p>
<h4 id="commitlog"><a class="header" href="#commitlog">CommitLog</a></h4>
<blockquote>
<p>消息主体以及元数据的存储主体</p>
</blockquote>
<p>存储Producer端写入的消息主体内容,消息内容不是定长的</p>
<ul>
<li>单个文件大小默认1G</li>
<li>文件名长度为20位，左边补零，剩余为起始偏移量</li>
</ul>
<p><strong>示例</strong></p>
<p>比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。<strong>消息主要是顺序写入日志文件，当文件满了，写入下一个文件</strong>；</p>
<h4 id="consumequeue"><a class="header" href="#consumequeue">ConsumeQueue</a></h4>
<blockquote>
<p>消息消费队列，引入的目的主要是提高消息消费的性能</p>
</blockquote>
<p><strong>设计目的</strong></p>
<p>由于RocketMQ是基于主题topic的订阅模式，消息消费是针对主题进行的，如果要遍历commitlog文件中根据topic检索消息是非常低效的</p>
<p>ConsumeQueue（逻辑消费队列）作为消费消息的索引</p>
<ul>
<li>保存了指定Topic下的队列消息在CommitLog中的起始物理偏移量offset，消息大小size和消息Tag的HashCode值</li>
<li>consumequeue文件可以看成是基于topic的commitlog索引文件</li>
<li>故consumequeue文件夹的组织方式如下：
<ul>
<li>topic/queue/file三层组织结构，具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}</li>
<li>同样consumequeue文件采取定长设计，每一个条目共20个字节，分别为8字节的commitlog物理偏移量、4字节的消息长度、8字节tag hashcode，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个ConsumeQueue文件大小约5.72M；</li>
</ul>
</li>
</ul>
<h4 id="indexfile"><a class="header" href="#indexfile">IndexFile</a></h4>
<blockquote>
<p>IndexFile（索引文件）提供了一种可以通过key或时间区间来查询消息的方法</p>
</blockquote>
<ul>
<li>Index文件的存储位置是：$HOME \store\index${fileName}</li>
<li>文件名fileName是以创建时的时间戳命名的</li>
<li>固定的单个IndexFile文件大小约为400M</li>
<li>一个IndexFile可以保存 2000W个索引，</li>
<li>IndexFile的底层存储设计为在文件系统中实现HashMap结构，故rocketmq的索引文件其底层实现为hash索引</li>
</ul>
<p><strong>混合存储结构</strong></p>
<p>在上面的RocketMQ的消息存储整体架构图中可以看出，RocketMQ采用的是混合型的存储结构，</p>
<p>为Broker单个实例下所有的队列共用一个日志数据文件（即为CommitLog）来存储。RocketMQ的混合型存储结构(<strong>多个Topic的消息实体内容都存储于一个CommitLog中</strong>)</p>
<p><strong>消息刷盘</strong></p>
<p>针对Producer和Consumer分别采用了数据和索引部分相分离的存储结构，Producer发送消息至Broker端，然后Broker端使用同步或者异步的方式对消息刷盘持久化，保存至CommitLog中。只要消息被刷盘持久化至磁盘文件CommitLog中，那么Producer发送的消息就不会丢失。正因为如此，Consumer也就肯定有机会去消费这条消息。</p>
<p><strong>等待拉取</strong></p>
<p>当无法拉取到消息后，可以等下一次消息拉取，同时服务端也支持长轮询模式，如果一个消息拉取请求未拉取到消息，Broker允许等待30s的时间，只要这段时间内有新消息到达，将直接返回给消费端。这里，RocketMQ的具体做法是，使用Broker端的后台服务线程—ReputMessageService不停地分发请求并异步构建ConsumeQueue（逻辑消费队列）和IndexFile（索引文件）数据。</p>
<h3 id="页缓存与内存映射"><a class="header" href="#页缓存与内存映射">页缓存与内存映射</a></h3>
<p>页缓存（PageCache)是OS对文件的缓存，用于加速对文件的读写</p>
<p><strong>os对文件缓存</strong></p>
<p>一般来说，程序对文件进行顺序读写的速度几乎接近于内存的读写速度，主要原因就是由于OS使用PageCache机制对读写访问操作进行了性能优化，将一部分的内存用作PageCache</p>
<p><strong>对于数据的写入</strong>，OS会先写入至Cache内，随后通过异步的方式由pdflush内核线程将Cache内的数据刷盘至物理磁盘上</p>
<p><strong>对于数据的读取</strong>，如果一次读取文件时出现未命中PageCache的情况，OS从物理磁盘上访问读取文件的同时，会顺序对其他相邻块的数据文件进行预读取。</p>
<p><strong>ConsumeQueue队列读取</strong></p>
<p>在RocketMQ中，ConsumeQueue逻辑消费队列存储的数据较少，并且是顺序读取，在page cache机制的预读取作用下，Consume Queue文件的读性能几乎接近读内存，即使在有消息堆积情况下也不会影响性能</p>
<p><strong>CommitLog的随机读取</strong></p>
<p>而对于CommitLog消息存储的日志数据文件来说，读取消息内容时候会产生较多的随机访问读取，严重影响性能。如果选择合适的系统IO调度算法，比如设置调度算法为“Deadline”（此时块存储采用SSD的话），随机读的性能也会有所提升。</p>
<p><strong>内存映射文件</strong></p>
<p>另外，RocketMQ主要通过MappedByteBuffer对文件进行读写操作。其中，利用了NIO中的FileChannel模型将磁盘上的物理文件直接映射到用户态的内存地址中（这种Mmap的方式减少了传统IO将磁盘文件数据在操作系统内核地址空间的缓冲区和用户应用程序地址空间的缓冲区之间来回进行拷贝的性能开销），将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率（正因为需要使用内存映射机制，故RocketMQ的文件存储都使用定长结构来存储，方便一次将整个文件映射至内存）。</p>
<h3 id="消息刷盘"><a class="header" href="#消息刷盘">消息刷盘</a></h3>
<p>(1) 同步刷盘：如上图所示，只有在消息真正持久化至磁盘后RocketMQ的Broker端才会<strong>真正返回给Producer端一个成功的ACK响应</strong>。<strong>同步刷盘对MQ消息可靠性来说是一种不错的保障，但是性能上会有较大影响，一般适用于金融业务应用该模式较多</strong>。</p>
<p>(2) 异步刷盘：能够充分利用OS的PageCache的优势，只要消息写入PageCache即可将成功的ACK返回给Producer端。消息刷盘采用后台异步线程提交的方式进行，降低了读写延迟，提高了MQ的性能和吞吐量。</p>
<h2 id="通信机制"><a class="header" href="#通信机制">通信机制</a></h2>
<p>RocketMQ消息队列集群主要包括NameServer、Broker(Master/Slave)、Producer、Consumer4个角色，基本通讯流程如下：</p>
<ul>
<li>Broker启动后需要完成一次将自己注册至NameServer的操作；随后每隔30s时间定时向NameServer上报Topic路由信息。</li>
<li>消息生产者Producer作为客户端发送消息时候，需要根据消息的Topic从本地缓存的TopicPublishInfoTable获取路由信息。如果没有则更新路由信息会从NameServer上重新拉取，<strong>同时Producer会默认每隔30s向NameServer拉取一次路由信息。</strong></li>
<li>消息生产者Producer根据2）中获取的路由信息选择一个队列（MessageQueue）进行消息发送；Broker作为消息的接收者接收消息并落盘存储。</li>
<li>消息消费者Consumer根据2）中获取的路由信息，并再完成客户端的负载均衡后，选择其中的某一个或者某几个消息队列来拉取消息并进行消费。</li>
</ul>
<p>从上面1）~3）中可以看出在消息生产者, Broker和NameServer之间都会发生通信（这里只说了MQ的部分通信），因此如何设计一个良好的网络通信模块在MQ中至关重要，它将决定RocketMQ集群整体的消息传输能力与最终的性能。</p>
<p>rocketmq-remoting 模块是 RocketMQ消息队列中负责网络通信的模块，它几乎被其他所有需要网络通信的模块（诸如rocketmq-client、rocketmq-broker、rocketmq-namesrv）所依赖和引用。为了实现客户端与服务器之间高效的数据请求与接收，RocketMQ消息队列自定义了通信协议并在Netty的基础之上扩展了通信模块。</p>
<h3 id="remoting通信类结构"><a class="header" href="#remoting通信类结构">Remoting通信类结构</a></h3>
<h3 id="协议设计与编解码"><a class="header" href="#协议设计与编解码">协议设计与编解码</a></h3>
<p>在Client和Server之间完成一次消息发送时，需要对发送的消息进行一个协议约定，因此就有必要自定义RocketMQ的消息协议。同时，为了高效地在网络中传输消息和对收到的消息读取，就需要对消息进行编解码。在RocketMQ中，RemotingCommand这个类在消息传输过程中对所有数据内容的封装，不但包含了所有的数据结构，还包含了编码解码操作。</p>
<table><thead><tr><th>Header字段</th><th>类型</th><th>Request说明</th><th>Response说明</th></tr></thead><tbody>
<tr><td>code</td><td>int</td><td>请求操作码，应答方根据不同的请求码进行不同的业务处理</td><td>应答响应码。0表示成功，非0则表示各种错误</td></tr>
<tr><td>language</td><td>LanguageCode</td><td>请求方实现的语言</td><td>应答方实现的语言</td></tr>
<tr><td>version</td><td>int</td><td>请求方程序的版本</td><td>应答方程序的版本</td></tr>
<tr><td>opaque</td><td>int</td><td>相当于requestId，在同一个连接上的不同请求标识码，与响应消息中的相对应</td><td>应答不做修改直接返回</td></tr>
<tr><td>flag</td><td>int</td><td>区分是普通RPC还是onewayRPC的标志</td><td>区分是普通RPC还是onewayRPC的标志</td></tr>
<tr><td>remark</td><td>String</td><td>传输自定义文本信息</td><td>传输自定义文本信息</td></tr>
<tr><td>extFields</td><td>HashMap&lt;String, String&gt;</td><td>请求自定义扩展信息</td><td>响应自定义扩展信息</td></tr>
</tbody></table>
<p>可见传输内容主要可以分为以下4部分：</p>
<p>(1) 消息长度：总长度，四个字节存储，占用一个int类型；</p>
<p>(2) 序列化类型&amp;消息头长度：同样占用一个int类型，第一个字节表示序列化类型，后面三个字节表示消息头长度；</p>
<p>(3) 消息头数据：经过序列化后的消息头数据；</p>
<p>(4) 消息主体数据：消息主体的二进制字节数据内容；</p>
<h3 id="消息的通信方式和流程"><a class="header" href="#消息的通信方式和流程">消息的通信方式和流程</a></h3>
<p>在RocketMQ消息队列中支持通信的方式主要有同步(sync)、异步(async)、单向(oneway) 三种。其中“单向”通信模式相对简单，一般用在发送心跳包场景下，无需关注其Response。这里，主要介绍RocketMQ的异步通信流程。</p>
<h3 id="reactor多线程设计"><a class="header" href="#reactor多线程设计">Reactor多线程设计</a></h3>
<p>RocketMQ的RPC通信采用Netty组件作为底层通信库，同样也遵循了Reactor多线程模型，同时又在这之上做了一些扩展和优化。</p>
<p>上面的框图中可以大致了解RocketMQ中NettyRemotingServer的Reactor 多线程模型。一个 Reactor 主线程（eventLoopGroupBoss，即为上面的1）负责监听 TCP网络连接请求，建立好连接，创建SocketChannel，并注册到selector上。RocketMQ的源码中会自动根据OS的类型选择NIO和Epoll，也可以通过参数配置）,然后监听真正的网络数据。拿到网络数据后，再丢给Worker线程池（eventLoopGroupSelector，即为上面的“N”，源码中默认设置为3），在真正执行业务逻辑之前需要进行SSL验证、编解码、空闲检查、网络连接管理，这些工作交给defaultEventExecutorGroup（即为上面的“M1”，源码中默认设置为8）去做。而处理业务操作放在业务线程池中执行，根据 RomotingCommand 的业务请求码code去processorTable这个本地缓存变量中找到对应的 processor，然后封装成task任务后，提交给对应的业务processor处理线程池来执行（sendMessageExecutor，以发送消息为例，即为上面的 “M2”）。从入口到业务逻辑的几个步骤中线程池一直再增加，这跟每一步逻辑复杂性相关，越复杂，需要的并发通道越宽。</p>
<table><thead><tr><th>线程数</th><th>线程名</th><th>线程具体说明</th></tr></thead><tbody>
<tr><td>1</td><td>NettyBoss_%d</td><td>Reactor 主线程</td></tr>
<tr><td>N</td><td>NettyServerEPOLLSelector_%d_%d</td><td>Reactor 线程池</td></tr>
<tr><td>M1</td><td>NettyServerCodecThread_%d</td><td>Worker线程池</td></tr>
<tr><td>M2</td><td>RemotingExecutorThread_%d</td><td>业务processor处理线程池</td></tr>
</tbody></table>
<h2 id="消息过滤"><a class="header" href="#消息过滤">消息过滤</a></h2>
<p><strong>基于Tag的过滤</strong></p>
<p>RocketMQ分布式消息队列的消息过滤方式有别于其它MQ中间件，是在Consumer端订阅消息时再做消息过滤的。RocketMQ这么做是在于其Producer端写入消息和Consumer端订阅消息采用分离存储的机制来实现的，Consumer端订阅消息是需要通过ConsumeQueue这个消息消费的逻辑队列拿到一个索引，然后再从CommitLog里面读取真正的消息实体内容，所以说到底也是还绕不开其存储结构。其ConsumeQueue的存储结构如下，可以看到其中有8个字节存储的Message Tag的哈希值，基于Tag的消息过滤正是基于这个字段值的。</p>
<h3 id="两种过滤方式"><a class="header" href="#两种过滤方式"><strong>两种过滤方式</strong></a></h3>
<p>主要支持如下2种的过滤方式</p>
<p>(1) Tag过滤方式：Consumer端在订阅消息时除了指定Topic还可以指定TAG，如果一个消息有多个TAG，可以用||分隔。其中，Consumer端会将这个订阅请求构建成一个 SubscriptionData，发送一个Pull消息的请求给Broker端。Broker端从RocketMQ的文件存储层—Store读取数据之前，会用这些数据先构建一个MessageFilter，然后传给Store。Store从 ConsumeQueue读取到一条记录后，会用它记录的消息tag hash值去做过滤，由于在服务端只是根据hashcode进行判断，无法精确对tag原始字符串进行过滤，故在消息消费端拉取到消息后，还需要对消息的原始tag字符串进行比对，如果不同，则丢弃该消息，不进行消息消费。</p>
<p>(2) SQL92的过滤方式：这种方式的大致做法和上面的Tag过滤方式一样，只是在Store层的具体过滤过程不太一样，真正的 SQL expression 的构建和执行由rocketmq-filter模块负责的。每次过滤都去执行SQL表达式会影响效率，所以RocketMQ使用了BloomFilter避免了每次都去执行。SQL92的表达式上下文为消息的属性。</p>
<h2 id="负载均衡"><a class="header" href="#负载均衡">负载均衡</a></h2>
<p><strong>RocketMQ中的负载均衡都在Client端完成</strong>，具体来说的话，主要可以分为</p>
<ul>
<li>Producer端发送消息时候的负载均衡和</li>
<li>Consumer端订阅消息的负载均衡。</li>
</ul>
<h3 id="producer的负载均衡"><a class="header" href="#producer的负载均衡">Producer的负载均衡</a></h3>
<p><strong>随机递增取模</strong></p>
<p>Producer端在发送消息的时候，会先根据Topic找到指定的TopicPublishInfo，在获取了TopicPublishInfo路由信息后，RocketMQ的客户端在默认方式下selectOneMessageQueue()方法会从TopicPublishInfo中的messageQueueList中选择一个队列（MessageQueue）进行发送消息。具体的容错策略均在MQFaultStrategy这个类中定义。这里有一个sendLatencyFaultEnable开关变量，如果开启，在随机递增取模的基础上，再过滤掉not available的Broker代理。</p>
<p><strong>避让机制</strong></p>
<p>所谓的&quot;latencyFaultTolerance&quot;，是指对之前失败的，按一定的时间做退避。例如，如果上次请求的latency超过550Lms，就退避3000Lms；超过1000L，就退避60000L；如果关闭，采用随机递增取模的方式选择一个队列（MessageQueue）来发送消息，latencyFaultTolerance机制是实现消息发送高可用的核心关键所在。</p>
<h3 id="consumer的负载均衡"><a class="header" href="#consumer的负载均衡">Consumer的负载均衡</a></h3>
<p>在RocketMQ中，Consumer端的两种消费模式（Push/Pull）都是基于拉模式来获取消息的，而在Push模式只是对pull模式的一种封装，其本质实现为消息拉取线程在从服务器拉取到一批消息后，然后提交到消息消费线程池后，又“马不停蹄”的继续向服务器再次尝试拉取消息。如果未拉取到消息，则延迟一下又继续拉取。在两种基于拉模式的消费方式（Push/Pull）中，均需要Consumer端在知道从Broker端的哪一个消息队列—队列中去获取消息。因此，有必要在Consumer端来做负载均衡，即Broker端中多个MessageQueue分配给同一个ConsumerGroup中的哪些Consumer消费。</p>
<h4 id="consumer端的心跳包发送"><a class="header" href="#consumer端的心跳包发送">Consumer端的心跳包发送</a></h4>
<p>在Consumer启动后，它就会通过定时任务不断地向RocketMQ集群中的所有Broker实例发送心跳包（其中包含了，消息消费分组名称、订阅关系集合、消息通信模式和客户端id的值等信息）</p>
<p>Broker端在收到Consumer的心跳消息后，会将它维护在ConsumerManager的本地缓存变量—consumerTable，同时并将封装后的客户端网络通道信息保存在本地缓存变量—channelInfoTable中，为之后做Consumer端的负载均衡提供可以依据的元数据信息。</p>
<h4 id="consumer端实现负载均衡的核心类rebalanceimpl"><a class="header" href="#consumer端实现负载均衡的核心类rebalanceimpl">Consumer端实现负载均衡的核心类—RebalanceImpl</a></h4>
<p><strong>RebalanceService实现负载均衡</strong></p>
<p>在Consumer实例的启动流程中的启动MQClientInstance实例部分，会完成负载均衡服务线程—RebalanceService的启动（每隔20s执行一次）。通过查看源码可以发现，RebalanceService线程的run()方法最终调用的是RebalanceImpl类的rebalanceByTopic()方法，该方法是实现Consumer端负载均衡的核心。这里，rebalanceByTopic()方法会根据消费者通信类型为“广播模式”还是“集群模式”做不同的逻辑处理。这里主要来看下集群模式下的主要处理流程：</p>
<p><strong>集群模式的处理逻辑</strong></p>
<ul>
<li>
<p>从rebalanceImpl实例的本地缓存变量—topicSubscribeInfoTable中，获取该Topic主题下的消息消费队列集合（mqSet）；</p>
</li>
<li>
<p>根据topic和consumerGroup为参数调用mQClientFactory.findConsumerIdList()方法向Broker端发送获取<strong>该消费组下消费者Id列表</strong>的RPC通信请求（<strong>Broker端基于前面Consumer端上报的心跳包数据而构建的consumerTable做出响应返回，业务请求码：GET_CONSUMER_LIST_BY_GROUP</strong>）</p>
</li>
<li>
<p>先对Topic下的消息消费队列、消费者Id排序，然后用消息队列分配策略算法（默认为：消息队列的平均分配算法），计算出待拉取的消息队列。</p>
<p>​	这里的平均分配算法，类似于分页的算法，将所有MessageQueue排好序类似于记录，将所有消费端Consumer排好序类似页数，并求出每一页需要包含的平均size和每个页面记录的范围range，最后遍历整个range而计算出当前Consumer端应该分配到的记录（这里即为：MessageQueue）。</p>
</li>
<li>
<p>然后，调用updateProcessQueueTableInRebalance()方法，具体的做法是，先将分配到的消息队列集合（mqSet）与processQueueTable做一个过滤比对。</p>
</li>
</ul>
<p><img src="6.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RocketMQ/../../images/rocketmq_design_9.png" alt="" /></p>
<p>上图中processQueueTable标注的红色部分，表示与分配到的消息队列集合mqSet互不包含。将这些队列设置Dropped属性为true，然后查看这些队列是否可以移除出processQueueTable缓存变量，这里具体执行removeUnnecessaryMessageQueue()方法，即每隔1s 查看是否可以获取当前消费处理队列的锁，拿到的话返回true。如果等待1s后，仍然拿不到当前消费处理队列的锁则返回false。如果返回true，则从processQueueTable缓存变量中移除对应的Entry；</p>
<p>上图中processQueueTable的绿色部分，表示与分配到的消息队列集合mqSet的交集。判断该ProcessQueue是否已经过期了，在Pull模式的不用管，如果是Push模式的，设置Dropped属性为true，并且调用removeUnnecessaryMessageQueue()方法，像上面一样尝试移除Entry；</p>
<p><strong>拉取消息队列</strong></p>
<p>最后，为过滤后的消息队列集合（mqSet）中的每个MessageQueue创建一个ProcessQueue对象并存入RebalanceImpl的processQueueTable队列中（其中调用RebalanceImpl实例的computePullFromWhere(MessageQueue mq)方法获取该MessageQueue对象的下一个进度消费值offset，随后填充至接下来要创建的pullRequest对象属性中），并创建拉取请求对象—pullRequest添加到拉取列表—pullRequestList中，最后执行dispatchPullRequest()方法，将Pull消息的请求对象PullRequest依次放入PullMessageService服务线程的阻塞队列pullRequestQueue中，待该服务线程取出后向Broker端发起Pull消息的请求。其中，可以重点对比下，RebalancePushImpl和RebalancePullImpl两个实现类的dispatchPullRequest()方法不同，RebalancePullImpl类里面的该方法为空，这样子也就回答了上一篇中最后的那道思考题了。</p>
<p><strong>消息消费队列在同一消费组不同消费者之间的负载均衡</strong>，其核心设计理念是在一个消息消费队列在同一时间只允许被同一消费组内的一个消费者消费，一个消息消费者能同时消费多个消息队列。</p>
<h2 id="事务消息"><a class="header" href="#事务消息">事务消息</a></h2>
<p>Apache RocketMQ在4.3.0版中已经支持分布式事务消息，</p>
<ul>
<li>这里RocketMQ采用了2PC的思想来实现了提交事务消息，</li>
<li>同时增加一个补偿逻辑来处理二阶段超时或者失败的消息，</li>
</ul>
<p>如下图所示</p>
<p><img src="6.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RocketMQ/../../images/rocketmq_design_10.png" alt="" /></p>
<h3 id="rocketmq事务消息流程概要"><a class="header" href="#rocketmq事务消息流程概要">RocketMQ事务消息流程概要</a></h3>
<h4 id="事务消息发送及提交"><a class="header" href="#事务消息发送及提交">事务消息发送及提交</a></h4>
<ol>
<li>发送消息（half消息）。</li>
<li>服务端响应消息写入结果。</li>
<li>根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。</li>
<li>根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）</li>
</ol>
<h4 id="补偿流程"><a class="header" href="#补偿流程">补偿流程</a></h4>
<ul>
<li>对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”</li>
<li>Producer收到回查消息，检查回查消息对应的本地事务的状态</li>
<li>根据本地事务状态，重新Commit或者Rollback</li>
</ul>
<p>其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p>
<h3 id="rocketmq事务消息设计"><a class="header" href="#rocketmq事务消息设计">RocketMQ事务消息设计</a></h3>
<h4 id="事务消息在一阶段对用户不可见"><a class="header" href="#事务消息在一阶段对用户不可见">事务消息在一阶段对用户不可见</a></h4>
<p>RocketMQ事务消息的做法是：如果消息是half消息，</p>
<ul>
<li>将备份原消息的主题与消息消费队列，</li>
<li>然后改变主题为RMQ_SYS_TRANS_HALF_TOPIC</li>
</ul>
<p>由于消费组未订阅该主题，故消费端无法消费half类型的消息</p>
<ul>
<li>然后RocketMQ会开启一个定时任务，从Topic为RMQ_SYS_TRANS_HALF_TOPIC中拉取消息进行消费，根据生产者组获取一个服务提供者发送<strong>回查事务状态请求</strong>，根据事务状态来决定是提交或回滚消息。</li>
</ul>
<p><strong>消息对应结构</strong></p>
<p><img src="6.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RocketMQ/../../images/rocketmq_design_11.png" alt="" /></p>
<p><strong>总结</strong></p>
<p>RocketMQ的具体实现策略是：写入的如果事务消息，对消息的Topic和Queue等属性进行替换，同时将原来的Topic和Queue信息存储到消息的属性中，正因为消息主题被替换，故消息并不会转发到该原主题的消息消费队列，消费者无法感知消息的存在，不会消费。其<strong>实改变消息主题是RocketMQ的常用“套路”，回想一下延时消息的实现机制。</strong></p>
<h4 id="commit和rollback操作以及op消息的引入"><a class="header" href="#commit和rollback操作以及op消息的引入">Commit和Rollback操作以及Op消息的引入</a></h4>
<p><strong>二阶段的可见</strong></p>
<p>在完成一阶段写入一条对用户不可见的消息后，二阶段如果是Commit操作，则需要让消息对用户可见；如果是Rollback则需要撤销一阶段的消息。先说Rollback的情况。对于Rollback，本身一阶段的消息对用户是不可见的，其实不需要真正撤销消息（实际上RocketMQ也无法去真正的删除一条消息，因为是顺序写文件的）。但是区别于这条消息没有确定状态（Pending状态，事务悬而未决），需要一个操作来标识这条消息的最终状态。</p>
<p><strong>Op消息</strong></p>
<p>RocketMQ事务消息方案中引入了Op消息的概念，用Op消息标识事务消息已经确定的状态（Commit或者Rollback）。如果一条事务消息没有对应的Op消息，说明这个事务的状态还无法确定（可能是二阶段失败了）。引入Op消息后，事务消息无论是Commit或者Rollback都会记录一个Op操作。<strong>Commit相对于Rollback只是在写入Op消息前创建Half消息的索引。</strong></p>
<h4 id="op消息的存储和对应关系"><a class="header" href="#op消息的存储和对应关系">Op消息的存储和对应关系</a></h4>
<p>RocketMQ将Op消息写入到全局一个特定的Topic中通过源码中的方法—TransactionalMessageUtil.buildOpTopic()；这个Topic是一个内部的Topic（像Half消息的Topic一样），不会被用户消费。<strong>Op消息的内容为对应的Half消息的存储的Offset</strong>，这样通过Op消息能索引到Half消息进行后续的回查操作。</p>
<p><strong>Op消息存储对应图</strong></p>
<p><img src="6.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RocketMQ/../../images/rocketmq_design_12.png" alt="" /></p>
<h4 id="half消息的索引构建"><a class="header" href="#half消息的索引构建">Half消息的索引构建</a></h4>
<p>在执行二阶段Commit操作时，需要构建出Half消息的索引。一阶段的Half消息由于是写到一个特殊的Topic，</p>
<ol>
<li>
<p>所以二阶段构建索引时需要读取出Half消息</p>
</li>
<li>
<p>并将Topic和Queue替换成真正的目标的Topic和Queue，</p>
</li>
<li>
<p>之后通过一次普通消息的写入操作来生成一条对用户可见的消息。</p>
</li>
</ol>
<p>所以RocketMQ事务消息二阶段其实是利用了一阶段存储的消息的内容，在二阶段时恢复出一条完整的普通消息，然后走一遍消息写入流程。</p>
<h4 id="如何处理二阶段失败的消息"><a class="header" href="#如何处理二阶段失败的消息">如何处理二阶段失败的消息？</a></h4>
<p>如果在RocketMQ事务消息的二阶段过程中失败了，例如在做Commit操作时，出现网络问题导致Commit失败，那么需要通过一定的策略使这条消息最终被Commit。</p>
<p><strong>回查机制</strong></p>
<p>RocketMQ采用了一种补偿机制，称为“回查”</p>
<p>Broker端对未确定状态的消息发起回查，将消息发送到对应的Producer端（同一个Group的Producer），由Producer根据消息来检查本地事务的状态，进而执行Commit或者Rollback。Broker端通过对比Half消息和Op消息进行事务消息的回查并且推进CheckPoint（记录那些事务消息的状态是确定的）。</p>
<p><strong>查询上限</strong></p>
<p>值得注意的是，rocketmq并不会无休止的的信息事务状态回查，默认回查15次，如果15次回查还是无法得知事务状态，rocketmq默认回滚该消息。</p>
<h2 id="消息查询"><a class="header" href="#消息查询">消息查询</a></h2>
<p>RocketMQ支持按照下面两种维度</p>
<ul>
<li>按照Message Id查询消息</li>
<li>按照Message Key查询消息</li>
</ul>
<h3 id="按照messageid查询消息"><a class="header" href="#按照messageid查询消息">按照MessageId查询消息</a></h3>
<p><strong>16位MessageId标识</strong></p>
<p>RocketMQ中的MessageId的长度总共有16字节，其中包含了消息存储主机地址（IP地址和端口），消息Commit Log offset。</p>
<p><strong>RocketMQ中具体做法是</strong></p>
<p>Client端从MessageId中解析出Broker的地址（IP地址和端口）和Commit Log的偏移地址后封装成一个RPC请求后通过Remoting通信层发送（业务请求码：VIEW_MESSAGE_BY_ID）。Broker端走的是QueryMessageProcessor，读取消息的过程用其中的 commitLog offset 和 size 去 commitLog 中找到真正的记录并解析成一个完整的消息返回。</p>
<h3 id="按照message-key查询消息"><a class="header" href="#按照message-key查询消息">按照Message Key查询消息</a></h3>
<p>“按照Message Key查询消息”，主要是基于RocketMQ的IndexFile索引文件来实现的。</p>
<p>RocketMQ的索引文件逻辑结构，类似JDK中HashMap的实现。索引文件的具体结构如下：</p>
<p><img src="6.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RocketMQ/../../images/rocketmq_design_13.png" alt="" /></p>
<p>IndexFile索引文件为用户提供通过“按照Message Key查询消息”的消息索引查询服务</p>
<p><strong>索引文件</strong></p>
<p>IndexFile文件的存储位置是：HOME\store\indexHOME\store\index{fileName}，文件名fileName是以创建时的时间戳命名的，文件大小是固定的，等于40+500W<em>4+2000W</em>20= 420000040个字节大小</p>
<p><strong>索引的Key</strong></p>
<p>如果消息的properties中设置了UNIQ_KEY这个属性，就用 topic + “#” + UNIQ_KEY的value作为 key 来做写入操作。如果消息设置了KEYS属性（多个KEY以空格分隔），也会用 topic + “#” + KEY 来做索引。</p>
<p><strong>索引字段</strong></p>
<p>其中的索引数据包含了Key Hash/CommitLog Offset/Timestamp/NextIndex offset 这四个字段，一共20 Byte</p>
<p><strong>hash冲突</strong></p>
<p>NextIndex offset 即前面读出来的 slotValue，如果有 hash冲突，就可以用这个字段将所有冲突的索引用链表的方式串起来了</p>
<p><strong>timestamp</strong></p>
<p>Timestamp记录的是消息storeTimestamp之间的差，并不是一个绝对的时间</p>
<p><strong>按照Message Key查询消息</strong></p>
<p>RocketMQ的具体做法是，主要通过Broker端的QueryMessageProcessor业务处理器来查询，读取消息的过程就是用topic和key找到IndexFile索引文件中的一条记录，根据其中的commitLog offset从CommitLog文件中读取消息的实体内容。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基本样例"><a class="header" href="#基本样例">基本样例</a></h1>
<h2 id="依赖"><a class="header" href="#依赖">依赖</a></h2>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;
    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;
    &lt;version&gt;4.9.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code>compile 'org.apache.rocketmq:rocketmq-client:4.3.0'
</code></pre>
<p>1 基本样例</p>
<ul>
<li>
<p><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md#11-%E5%8A%A0%E5%85%A5%E4%BE%9D%E8%B5%96">1.1 加入依赖：</a></p>
</li>
<li>
<p>1.2 消息发送</p>
<ul>
<li><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md#1producer%E7%AB%AF%E5%8F%91%E9%80%81%E5%90%8C%E6%AD%A5%E6%B6%88%E6%81%AF">1、Producer端发送同步消息</a></li>
<li><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md#2%E5%8F%91%E9%80%81%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF">2、发送异步消息</a></li>
<li><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md#3%E5%8D%95%E5%90%91%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF">3、单向发送消息</a></li>
</ul>
</li>
<li>
<p><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md#13-%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF">1.3 消费消息</a></p>
</li>
<li>
<p>2 顺序消息样例</p>
<ul>
<li><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md#21-%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7">2.1 顺序消息生产</a></li>
<li><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md#22-%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF">2.2 顺序消费消息</a></li>
</ul>
</li>
<li>
<p>3 延时消息样例</p>
<ul>
<li><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md#31-%E5%90%AF%E5%8A%A8%E6%B6%88%E8%B4%B9%E8%80%85%E7%AD%89%E5%BE%85%E4%BC%A0%E5%85%A5%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF">3.1 启动消费者等待传入订阅消息</a></li>
<li><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md#32-%E5%8F%91%E9%80%81%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF">3.2 发送延时消息</a></li>
<li><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md#33-%E9%AA%8C%E8%AF%81">3.3 验证</a></li>
<li><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md#34-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">3.4 延时消息的使用场景</a></li>
<li><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md#35-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%E7%9A%84%E4%BD%BF%E7%94%A8%E9%99%90%E5%88%B6">3.5 延时消息的使用限制</a></li>
</ul>
</li>
<li>
<p>4 批量消息样例</p>
<ul>
<li><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md#41-%E5%8F%91%E9%80%81%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF">4.1 发送批量消息</a></li>
<li><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md#42-%E6%B6%88%E6%81%AF%E5%88%97%E8%A1%A8%E5%88%86%E5%89%B2">4.2 消息列表分割</a></li>
</ul>
</li>
<li>
<p>5 过滤消息样例</p>
<ul>
<li><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md#51-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">5.1 基本语法</a></li>
<li>5.2 使用样例
<ul>
<li><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md#1%E7%94%9F%E4%BA%A7%E8%80%85%E6%A0%B7%E4%BE%8B">1、生产者样例</a></li>
<li><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md#2%E6%B6%88%E8%B4%B9%E8%80%85%E6%A0%B7%E4%BE%8B">2、消费者样例</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p>6 消息事务样例</p>
<ul>
<li>6.1 发送事务消息样例
<ul>
<li><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md#1%E5%88%9B%E5%BB%BA%E4%BA%8B%E5%8A%A1%E6%80%A7%E7%94%9F%E4%BA%A7%E8%80%85">1、创建事务性生产者</a></li>
<li><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md#2%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%9B%91%E5%90%AC%E6%8E%A5%E5%8F%A3">2、实现事务的监听接口</a></li>
</ul>
</li>
<li><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md#62-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E4%BD%BF%E7%94%A8%E4%B8%8A%E7%9A%84%E9%99%90%E5%88%B6">6.2 事务消息使用上的限制</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概念和特性"><a class="header" href="#概念和特性">概念和特性</a></h1>
<h2 id="消息模型message-model"><a class="header" href="#消息模型message-model">消息模型（Message Model）</a></h2>
<p>RocketMQ主要由 Producer、Broker、Consumer 三部分组成，</p>
<ul>
<li>其中Producer 负责生产消息，</li>
<li>Consumer 负责消费消息，</li>
<li>Broker 负责存储消息。
<ul>
<li>Broker 在实际部署过程中对应一台服务器</li>
<li>每个 Broker 可以存储多个Topic的消息</li>
<li>每个Topic的消息也可以分片存储于不同的 Broker。</li>
</ul>
</li>
</ul>
<p>Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。</p>
<p>ConsumerGroup 由多个Consumer 实例构成。</p>
<h2 id="消息生产者producer"><a class="header" href="#消息生产者producer">消息生产者（Producer）</a></h2>
<p>负责生产消息，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到broker服务器。</p>
<p>RocketMQ提供多种发送方式，<strong>同步发送</strong>、<strong>异步发送</strong>、顺序发送、<strong>单向发送</strong>。同步和异步方式均需要Broker返回确认信息，单向发送不需要。</p>
<h2 id="消息消费者consumer"><a class="header" href="#消息消费者consumer">消息消费者（Consumer）</a></h2>
<p>负责消费消息，一般是后台系统负责异步消费。一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费、推动式消费。</p>
<h2 id="主题topic"><a class="header" href="#主题topic">主题（Topic）</a></h2>
<p>表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。</p>
<h2 id="代理服务器broker-server"><a class="header" href="#代理服务器broker-server">代理服务器（Broker Server）</a></h2>
<p>消息中转角色，负责存储消息、转发消息。代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。</p>
<h2 id="名字服务name-server"><a class="header" href="#名字服务name-server">名字服务（Name Server）</a></h2>
<p>名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。</p>
<h2 id="拉取式消费pull-consumer"><a class="header" href="#拉取式消费pull-consumer">拉取式消费（Pull Consumer）</a></h2>
<p>Consumer消费的一种类型，应用通常主动调用Consumer的拉消息方法从Broker服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。</p>
<h2 id="推动式消费push-consumer"><a class="header" href="#推动式消费push-consumer">推动式消费（Push Consumer）</a></h2>
<p>Consumer消费的一种类型，该模式下Broker收到数据后会主动推送给消费端，该消费模式一般实时性较高。</p>
<h2 id="生产者组producer-group"><a class="header" href="#生产者组producer-group">生产者组（Producer Group）</a></h2>
<p>同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p>
<h2 id="消费者组consumer-group"><a class="header" href="#消费者组consumer-group">消费者组（Consumer Group）</a></h2>
<p>同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的Topic。</p>
<p>RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</p>
<h2 id="集群消费clustering"><a class="header" href="#集群消费clustering">集群消费（Clustering）</a></h2>
<p>集群消费模式下,相同Consumer Group的每个Consumer实例平均分摊消息。</p>
<h2 id="广播消费broadcasting"><a class="header" href="#广播消费broadcasting">广播消费（Broadcasting）</a></h2>
<p>广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息。</p>
<h2 id="普通顺序消息normal-ordered-message"><a class="header" href="#普通顺序消息normal-ordered-message">普通顺序消息（Normal Ordered Message）</a></h2>
<p>普通顺序消费模式下，消费者通过同一个消息队列（ Topic 分区，称作 Message Queue） 收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。</p>
<h2 id="严格顺序消息strictly-ordered-message"><a class="header" href="#严格顺序消息strictly-ordered-message">严格顺序消息（Strictly Ordered Message）</a></h2>
<p>严格顺序消息模式下，消费者收到的所有消息均是有顺序的。</p>
<h2 id="消息message"><a class="header" href="#消息message">消息（Message）</a></h2>
<p>消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key。系统提供了通过Message ID和Key查询消息的功能。</p>
<h2 id="标签tag"><a class="header" href="#标签tag">标签（Tag）</a></h2>
<p>为消息设置的标志，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p>
<h1 id="特性features"><a class="header" href="#特性features">特性(features)</a></h1>
<h2 id="订阅与发布"><a class="header" href="#订阅与发布">订阅与发布</a></h2>
<p>消息的发布是指某个生产者向某个topic发送消息；消息的订阅是指某个消费者关注了某个topic中带有某些tag的消息，进而从该topic消费数据。</p>
<h2 id="消息顺序"><a class="header" href="#消息顺序">消息顺序</a></h2>
<p>消息有序 指的是：能按照发送的顺序来消费，例如：一个订单产生了三条消息分别是订单创建、订单付款、订单完成</p>
<p>消费时要按照这个顺序消费才能有意义，但是同时订单之间是可以并行消费的。RocketMQ可以严格的保证消息有序</p>
<p>顺序消息分为<strong>全局顺序消息</strong>与分<strong>区顺序消息</strong></p>
<ul>
<li>
<p>全局顺序是指某个Topic下的所有消息都要保证顺序</p>
<ul>
<li>全局顺序 对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序进行发布和消费。 适用场景：性能要求不高，所有的消息严格按照 FIFO 原则进行消息发布和消费的场景</li>
</ul>
</li>
<li>
<p>部分顺序消息只要保证每一组消息被顺序消费即可。</p>
<ul>
<li>分区顺序 对于指定的一个 Topic，所有消息根据 sharding key 进行区块分区。 同一个分区内的消息按照严格的 FIFO 顺序进行发布和消费</li>
<li>Sharding key 是顺序消息中用来区分不同分区的关键字段，和普通消息的 Key 是完全不同的概念</li>
<li>适用场景：性能要求高，以 sharding key 作为分区字段，在同一个区块中严格的按照 FIFO 原则进行消息发布和消费的场景。</li>
</ul>
</li>
</ul>
<h2 id="消息过滤-1"><a class="header" href="#消息过滤-1">消息过滤</a></h2>
<p>RocketMQ的消费者可以根据Tag进行消息过滤，也支持自定义属性过滤。</p>
<p>消息过滤目前是在Broker端实现的，</p>
<ul>
<li>优点是减少了对于Consumer无用消息的网络传输，</li>
<li>缺点是增加了Broker的负担、而且实现相对复杂。</li>
</ul>
<h2 id="消息可靠性"><a class="header" href="#消息可靠性">消息可靠性</a></h2>
<p>RocketMQ支持消息的高可靠，影响消息可靠性的几种情况：</p>
<ul>
<li>Broker非正常关闭</li>
<li>Broker异常Crash</li>
<li>OS Crash</li>
<li>机器掉电，但是能立即恢复供电情况</li>
<li>机器无法开机（可能是cpu、主板、内存等关键设备损坏）</li>
<li>磁盘设备损坏</li>
</ul>
<p>1)、2)、3)、4) 四种情况都属于硬件资源可立即恢复情况，RocketMQ在这四种情况下能保证消息不丢，或者丢失少量数据（依赖刷盘方式是同步还是异步）。</p>
<p>5)、6)属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失</p>
<p>RocketMQ在这两种情况下，通过异步复制，可保证99%的消息不丢，但是仍然会有极少量的消息可能丢失</p>
<p>通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与Money相关的应用。注：RocketMQ从3.0版本开始支持同步双写。</p>
<h2 id="至少一次"><a class="header" href="#至少一次">至少一次</a></h2>
<p>至少一次(At least Once)指每个消息必须投递一次。Consumer先Pull消息到本地，消费完成后，才向服务器返回ack，如果没有消费一定不会ack消息，所以RocketMQ可以很好的支持此特性。</p>
<h2 id="回溯消费"><a class="header" href="#回溯消费">回溯消费</a></h2>
<p>回溯消费是指Consumer已经消费成功的消息，由于业务上需求需要重新消费，要支持此功能，Broker在向Consumer投递成功消息后，消息仍然需要保留。并且重新消费一般是按照时间维度，例如由于Consumer系统故障，恢复后需要重新消费1小时前的数据，那么Broker要提供一种机制，可以按照时间维度来回退消费进度。RocketMQ支持按照时间回溯消费，时间维度精确到毫秒。</p>
<h2 id="事务消息-1"><a class="header" href="#事务消息-1">事务消息</a></h2>
<p>RocketMQ事务消息（Transactional Message）是指应用本地事务和发送消息操作可以被定义到全局事务中，要么同时成功，要么同时失败。RocketMQ的事务消息提供类似 X/Open XA 的分布事务功能，通过事务消息能达到分布式事务的最终一致。</p>
<h2 id="定时消息"><a class="header" href="#定时消息">定时消息</a></h2>
<p>定时消息（延迟队列）是指消息发送到broker后，不会立即被消费，等待特定时间投递给真正的topic</p>
<p>broker有配置项messageDelayLevel，默认值为“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”，18个level。</p>
<p>可以配置自定义messageDelayLevel</p>
<p>注意，messageDelayLevel是broker的属性，不属于某个topic,发消息时，设置delayLevel等级即可：msg.setDelayLevel(level)</p>
<p>level有以下三种情况：</p>
<ul>
<li>level == 0，消息为非延迟消息</li>
<li>1&lt;=level&lt;=maxLevel，消息延迟特定时间，例如level==1，延迟1s</li>
<li>level &gt; maxLevel，则level== maxLevel，例如level==20，延迟2h</li>
</ul>
<p><strong>原理</strong></p>
<ul>
<li>定时消息会暂存在名为SCHEDULE_TOPIC_XXXX的topic中</li>
<li>并根据delayTimeLevel存入特定的queue，queueId = delayTimeLevel – 1</li>
<li>即一个queue只存相同延迟的消息，保证具有相同发送延迟的消息能够顺序消费。</li>
<li>broker会调度地消费SCHEDULE_TOPIC_XXXX，将消息写入真实的topic。</li>
</ul>
<p>需要注意的是，定时消息会在第一次写入和调度写入真实topic时都会计数，因此发送数量、tps都会变高。</p>
<h2 id="消息重试"><a class="header" href="#消息重试">消息重试</a></h2>
<p>Consumer消费消息失败后，要提供一种重试机制，令消息再消费一次。Consumer消费消息失败通常可以认为有以下几种情况：</p>
<ul>
<li>由于消息本身的原因，例如反序列化失败，消息数据本身无法处理（例如话费充值，当前消息的手机号被注销，无法充值）等。这种错误通常需要跳过这条消息，再消费其它消息，而这条失败的消息即使立刻重试消费，99%也不成功，所以最好提供一种定时重试机制，即过10秒后再重试。</li>
<li>由于依赖的下游应用服务不可用，例如db连接不可用，外系统网络不可达等。遇到这种错误，即使跳过当前失败的消息，消费其他消息同样也会报错。这种情况建议应用sleep 30s，再消费下一条消息，这样可以减轻Broker重试消息的压力。</li>
</ul>
<p><strong>原理</strong></p>
<ul>
<li>RocketMQ会为每个消费组都设置一个Topic名称为“%RETRY%+consumerGroup”的重试队列（这里需要注意的是，这个Topic的重试队列是针对消费组，而不是针对每个Topic设置的）</li>
<li>用于暂时保存因为各种异常而导致Consumer端无法消费的消息</li>
<li>考虑到异常恢复起来需要一些时间，会为重试队列设置多个重试级别，每个重试级别都有与之对应的重新投递延时，重试次数越多投递延时就越大</li>
<li>RocketMQ对于重试消息的处理是先保存至Topic名称为“SCHEDULE_TOPIC_XXXX”的延迟队列中，后台定时任务按照对应的时间进行Delay后重新保存至“%RETRY%+consumerGroup”的重试队列中。</li>
</ul>
<h2 id="消息重投"><a class="header" href="#消息重投">消息重投</a></h2>
<p>生产者在发送消息时</p>
<ul>
<li>同步消息失败会重投</li>
<li>异步消息有重试</li>
<li>oneway没有任何保证</li>
</ul>
<p><strong>消息重复</strong></p>
<p>消息重投保证消息尽可能发送成功、不丢失，但可能会造成消息重复，消息重复在RocketMQ中是无法避免的问题</p>
<p>消息重复在一般情况下不会发生，当出现消息量大、网络抖动，消息重复就会是大概率事件。</p>
<p>另外，生产者主动重发、consumer负载变化也会导致重复消息。</p>
<p>如下方法可以设置消息重试策略：</p>
<ul>
<li>retryTimesWhenSendFailed:同步发送失败重投次数，默认为2，因此生产者会最多尝试发送retryTimesWhenSendFailed + 1次。不会选择上次失败的broker，尝试向其他broker发送，最大程度保证消息不丢。超过重投次数，抛出异常，由客户端保证消息不丢。当出现RemotingException、MQClientException和部分MQBrokerException时会重投。</li>
<li>retryTimesWhenSendAsyncFailed:异步发送失败重试次数，异步重试不会选择其他broker，仅在同一个broker上做重试，不保证消息不丢。</li>
<li>retryAnotherBrokerWhenNotStoreOK:消息刷盘（主或备）超时或slave不可用（返回状态非SEND_OK），是否尝试发送到其他broker，默认false。十分重要消息可以开启。</li>
</ul>
<h2 id="流量控制"><a class="header" href="#流量控制">流量控制</a></h2>
<h3 id="生产者流控"><a class="header" href="#生产者流控">生产者流控</a></h3>
<blockquote>
<p>因为broker处理能力达到瓶颈</p>
</blockquote>
<ul>
<li>commitLog文件被锁时间超过osPageCacheBusyTimeOutMills时，参数默认为1000ms，返回流控。</li>
<li>如果开启transientStorePoolEnable == true，且broker为异步刷盘的主机，且transientStorePool中资源不足，拒绝当前send请求，返回流控。</li>
<li>broker每隔10ms检查send请求队列头部请求的等待时间，如果超过waitTimeMillsInSendQueue，默认200ms，拒绝当前send请求，返回流控。</li>
<li>broker通过拒绝send 请求方式实现流量控制。</li>
</ul>
<p>生产者流控，不会尝试消息重投。</p>
<h3 id="消费者流控"><a class="header" href="#消费者流控">消费者流控</a></h3>
<ul>
<li>消费者本地缓存消息数超过pullThresholdForQueue时，默认1000。</li>
<li>消费者本地缓存消息大小超过pullThresholdSizeForQueue时，默认100MB。</li>
<li>消费者本地缓存消息跨度超过consumeConcurrentlyMaxSpan时，默认2000。</li>
</ul>
<p>消费者流控的结果是降低拉取频率。</p>
<h2 id="死信队列"><a class="header" href="#死信队列">死信队列</a></h2>
<p>死信队列用于处理无法被正常消费的消息。</p>
<p><strong>场景</strong></p>
<ol>
<li>当一条消息初次消费失败，消息队列会自动进行消息重试</li>
<li>达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息</li>
<li>此时，消息队列 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。</li>
<li>RocketMQ将这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），将存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）</li>
<li>在RocketMQ中，可以通过使用console控制台对死信队列中的消息进行重发来使得消费者实例再次进行消费。</li>
</ol>
<h1 id="启动与安装"><a class="header" href="#启动与安装">启动与安装</a></h1>
<h2 id="start-name-server"><a class="header" href="#start-name-server">Start Name Server</a></h2>
<pre><code class="language-sh"> &gt; nohup sh bin/mqnamesrv &amp;
  &gt; tail -f ~/logs/rocketmqlogs/namesrv.log
  The Name Server boot success...
</code></pre>
<h2 id="start-broker"><a class="header" href="#start-broker">Start Broker</a></h2>
<pre><code class="language-sh">  &gt; nohup sh bin/mqbroker -n localhost:9876 &amp;
  &gt; tail -f ~/logs/rocketmqlogs/broker.log 
  The broker[%s, 172.30.30.233:10911] boot success...
</code></pre>
<h2 id="send--receive-messages"><a class="header" href="#send--receive-messages">Send &amp; Receive Messages</a></h2>
<pre><code class="language-sh"> &gt; export NAMESRV_ADDR=localhost:9876
 &gt; sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer
 SendResult [sendStatus=SEND_OK, msgId= ...

 &gt; sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer
 ConsumeMessageThread_%d Receive New Messages: [MessageExt...
</code></pre>
<h2 id="shutdown-servers"><a class="header" href="#shutdown-servers">Shutdown Servers</a></h2>
<pre><code class="language-sh">&gt; sh bin/mqshutdown broker
The mqbroker(36695) is running...
Send shutdown request to mqbroker(36695) OK

&gt; sh bin/mqshutdown namesrv
The mqnamesrv(36664) is running...
Send shutdown request to mqnamesrv(36664) OK
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kafka是如何保证数据的可靠性"><a class="header" href="#kafka是如何保证数据的可靠性">Kafka是如何保证数据的可靠性?</a></h1>
<h2 id="副本机制"><a class="header" href="#副本机制">副本机制</a></h2>
<p>单个<em>topic</em>可以有多个 分区, 每个分区 都可以设置 副本数量,只有一个<em>leader</em>副本进行外部数据的写入,然后由leader将数据转发给各个副本,保证集群间数据的一致.</p>
<h2 id="acks参数"><a class="header" href="#acks参数"><em>acks</em>参数</a></h2>
<p>三种选项 不等待答复|等待<em>leader</em>答复|等待所有节点答复</p>
<h2 id="isr机制"><a class="header" href="#isr机制">ISR机制</a></h2>
<p><em>ISR</em>机制保证了leader写入数据成功并且至少有一个follower同步完成leader的数据，才会认为消息发送成功</p>
<p>每个partition中会维护着一个ISR列表包含leader，还有与它同步的follower</p>
<p>只要某个follower会同步leader的数据，那么肯定会在该列表中</p>
<p>如果某个follower因为自身发生问题，不能同步数据，那么会被认为“out of sync”，从ISR列表中删除</p>
<h1 id="kafka是如何保证数据的顺序性"><a class="header" href="#kafka是如何保证数据的顺序性">Kafka是如何保证数据的顺序性?</a></h1>
<p><em>Kafka</em>只能保证 单个topics 的 单个<em>partition</em>, 的数据顺序</p>
<p>因为在<em>partition</em> 内维护了 <em>offset</em></p>
<h1 id="kafka的消息处理消息交付语义"><a class="header" href="#kafka的消息处理消息交付语义">Kafka的消息处理/消息交付语义</a></h1>
<p>最多一次：消息可能丢失也可能被处理，但最多只会被处理一次。</p>
<p>至少一次：消息不会丢失，但可能被处理多次</p>
<p>精确一次：消息被处理且只会被处理一次</p>
<h1 id="kafka如何判断节点是否还活着"><a class="header" href="#kafka如何判断节点是否还活着">Kafka如何判断节点是否还活着</a></h1>
<ol>
<li>建立与zk的连接,在zk上建立一个连接节点</li>
<li>如果是<em>follower</em>节点 能及时的同步<em>leader</em>写操作,不能延时太久</li>
</ol>
<h1 id="pull模式与push模式的优缺点"><a class="header" href="#pull模式与push模式的优缺点"><em>PULL</em>模式与<em>PUSH</em>模式的优缺点</a></h1>
<p><em>push</em> </p>
<ul>
<li>由<em>broker</em>决定消息推送速率,当<em>broker</em>推送的速率远大于<em>consumer</em> 消费的效率,<em>consumer</em>会崩溃</li>
<li>但能够及时的推送</li>
</ul>
<p><em>pull</em></p>
<p><em>consumer</em>能根据自己的消费能力去决定</p>
<p>需要不断轮询</p>
<h1 id="topic-partition"><a class="header" href="#topic-partition"><em>TOPIC</em> partition</a></h1>
<h2 id="分配规则"><a class="header" href="#分配规则">分配规则</a></h2>
<p>接受 topic create 请求的 结点 为 0号分区,按照 集群ID 依次有序分配, 当<em>partitions</em>数量 &gt; <em>brokers</em>数量,会轮回再次分配</p>
<h2 id="命名规则"><a class="header" href="#命名规则">命名规则</a></h2>
<p><em>paritions</em>名称为:<em>topic-name-index</em>,  <em>index</em>分区索引编号，从0开始依次递增</p>
<h2 id="分区文件存储方式"><a class="header" href="#分区文件存储方式">分区文件存储方式</a></h2>
<ul>
<li>
<p>将大文件切割成 <em>segment file</em></p>
</li>
<li>
<p>segment file组成：由2大部分组成，分别为<em>segment data file</em>和<em>segment index file</em>,此2个文件一一对应，成对出现.</p>
</li>
<li>
<p>partition文件命名</p>
<ul>
<li>partion全局的第一个segment从0开始，</li>
<li>后续每个segment文件名为上一个segment文件最后一条消息的offset值</li>
<li>数值最大为64位long大小，19位数字字符长度，没有数字用0填充</li>
</ul>
</li>
<li>
<p><em>partition.log</em>文件 由 很多<em>message</em> 顺序存储</p>
<p><em>message</em>结构</p>
<p><img src="7.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_KafaKa/C:%5CUsers%5Cweisanju%5CDesktop%5C%E5%AE%9E%E7%94%A8%E5%9B%BE%5CkafkaMessage%E7%BB%93%E6%9E%84.png" alt="" /></p>
<p>参数说明</p>
<table><thead><tr><th style="text-align: left">关键字</th><th style="text-align: left">解释说明</th></tr></thead><tbody>
<tr><td style="text-align: left">8 byte offset</td><td style="text-align: left">在parition(分区)内的每条消息都有一个有序的id号，这个id号被称为偏移(offset),它可以唯一确定每条消息在parition(分区)内的位置。即offset表示partiion的第多少message</td></tr>
<tr><td style="text-align: left">4 byte message size</td><td style="text-align: left">message大小</td></tr>
<tr><td style="text-align: left">4 byte CRC32</td><td style="text-align: left">用crc32校验message</td></tr>
<tr><td style="text-align: left">1 byte “magic”</td><td style="text-align: left">表示本次发布Kafka服务程序协议版本号</td></tr>
<tr><td style="text-align: left">1 byte “attributes”</td><td style="text-align: left">表示为独立版本、或标识压缩类型、或编码类型。</td></tr>
<tr><td style="text-align: left">4 byte key length</td><td style="text-align: left">表示key的长度,当key为-1时，K byte key字段不填</td></tr>
<tr><td style="text-align: left">K byte key</td><td style="text-align: left">可选</td></tr>
<tr><td style="text-align: left">value bytes payload</td><td style="text-align: left">表示实际消息数据。</td></tr>
</tbody></table>
</li>
<li>
<p>索引文件</p>
<ul>
<li>稀疏索引存储方式</li>
<li>记录了 <em>message</em> 在 <em>log</em>文件中的 序号以及 对应的 字节偏移</li>
</ul>
</li>
<li>
<p>如何通过 <em>offset</em> 查找相应的 <em>message</em></p>
<ul>
<li>根据文件列表的 数字命名 二分查找 定位  相应的 <em>log</em>文件,与<em>index</em>文件</li>
<li>通过索引文件定位  该 <em>offset</em>下的 物理字节偏移</li>
<li>最后通过 去log文件中查找数据</li>
</ul>
</li>
</ul>
<h1 id="消息队列优点"><a class="header" href="#消息队列优点">消息队列优点</a></h1>
<p>解耦,冗余,扩展,灵活,峰值处理,可恢复性,顺序保证,异步通信</p>
<h1 id="kafka架构"><a class="header" href="#kafka架构">kafka架构</a></h1>
<ul>
<li>
<p>生产者</p>
</li>
<li>
<p>消费者</p>
<ul>
<li>消费者组 中的 多个客户端 不能重复消息</li>
<li>同一个Topic的同一个分区的数据</li>
</ul>
</li>
<li>
<p>集群</p>
<p>集群 -&gt; broker(节点) -&gt; TOPIC 主题 -&gt; 分区</p>
</li>
<li>
<p>zookeeper</p>
<pre><code>systemctl stop firewalld &amp;&amp; ./zookeeper/bin/zkServer.sh start &amp;&amp; ./zookeeper/bin/zkServer.sh status
</code></pre>
</li>
</ul>
<p>操作命令</p>
<pre><code>解压
tar -xf kafka_2.13-2.5.0.tgz

启动
bin/kafka-server-start.sh config/server.properties
--daemon  后台
创建topic
bin/kafka-topics.sh --create --zookeeper 192.168.3.8:2181 --partitions 2 --replication-factor 3 --topic second
Created topic first.

查看topic
bin/kafka-topics.sh --list --zookeeper 192.168.3.8:2181

生产者
bin/kafka-console-producer.sh --broker-list 192.168.3.8:9092 --topic second 

控制台消费者-消费
kafka_2.13-2.5.0/bin/kafka-console-consumer.sh --broker-list 192.168.3.8:9092  --topic second
从开始消费数据 --from-begining

新版本,offset维护在本地,
--bootstrap-server 192.168.3.7:9092

描述卡夫卡
bin/kafka-topics.sh --zookeeper 192.168.3.7:2181 --describe --topic first
partitionCount:2 分区2,relicationFactor:2 复本2
partition0,leader:0,replicas:0,2, ISR:0,2 ,分区0 有两块副本,broker0为使用分区,ISR为分区不可用时的副本使用顺序

</code></pre>
<h1 id="分区原则"><a class="header" href="#分区原则">分区原则</a></h1>
<ol>
<li>指定了分区 直接使用分区</li>
<li>未指定partition 但指定key,通过key 的valuehash分区</li>
<li>key未指定,轮询选出 一个partition</li>
</ol>
<h1 id="副本replication"><a class="header" href="#副本replication">副本(replication)</a></h1>
<h2 id="描述"><a class="header" href="#描述">描述</a></h2>
<ul>
<li>同一个分区的有多个副本</li>
<li>需要在 这几个副本中选出 <em>leader</em>, <em>producer</em>与<em>consumer</em> 只与<em>leader</em>交互 ,其他replication作为follower 从leader中复制数据</li>
<li>副本创建好之后,会有一个 可用序列, 决定了 <em>leader</em> 不可用时,下一个可用的副本<em>broker</em>节点</li>
<li><em>replication</em> 副本之间不可能在同一个 broker</li>
</ul>
<h2 id="副本之间的同步机制"><a class="header" href="#副本之间的同步机制">副本之间的同步机制</a></h2>
<p><em>ALL</em></p>
<p><em>producer</em>向<em>leader</em>写入 数据, 等待所有follower同步完成</p>
<p>1</p>
<p><em>producer</em> 本地写到日志中后 就立刻返回</p>
<p>0</p>
<p><em>producer</em> 不等待任何确认即返回,一般确认数为 -1</p>
<h1 id="javaapi"><a class="header" href="#javaapi">JavaAPI</a></h1>
<h2 id="生产者"><a class="header" href="#生产者">生产者</a></h2>
<ol>
<li>
<p>生产者配置信息</p>
<ul>
<li>
<p><em>bootstrap.servers</em>  :</p>
<p><em>Kafka</em>集群地址,<em>host:port,host:port</em></p>
</li>
<li>
<p><em>acks</em>:应答级别</p>
</li>
<li>
<p><em>retries</em>:重试次数</p>
</li>
<li>
<p>生产者提交数据的 阈值</p>
<ul>
<li><em>batch.size</em> :批量大小</li>
<li><em>linger.ms</em>:提交延时</li>
</ul>
</li>
<li>
<p><em>buffer.memory</em></p>
<ul>
<li>缓存区大小</li>
</ul>
</li>
<li>
<p><em>KV</em>的序列化类</p>
<ul>
<li>key.serializer*:</li>
</ul>
</li>
<li>
<p>位于<em>ProducerConfig</em></p>
</li>
</ul>
</li>
<li>
<p>实例化生产者</p>
<pre><code class="language-java">KafkaProducer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(p);
</code></pre>
</li>
<li>
<p>发送消息</p>
<pre><code class="language-java">  producer.send(new ProducerRecord&lt;String, String&gt;(&quot;first&quot;, i + &quot;&quot;),(metadata, exception) -&gt; {
                System.out.println(&quot;offset:&quot;+metadata.offset()+&quot;;partition:&quot;+metadata.partition());
            });
            producer.flush();
</code></pre>
</li>
</ol>
<p>自定义分区</p>
<ul>
<li>
<p>实现<em>Partitioner</em>接口</p>
</li>
<li>
<p>关键方法</p>
<p><em>public int partition</em></p>
<p><em>(String topic, Object key, byte[] keyBytes,</em> </p>
<p><em>Object value, byte[] valueBytes,</em> </p>
<p><em>Cluster cluster);</em></p>
<p>根据,<em>topic</em>,<em>key</em>,序列化的<em>keybytes</em>,值,序列化的值,集群配置等决定分区</p>
</li>
<li>
<p>默认方法<em>onNewBatch</em> </p>
<ul>
<li>创建新的批次时通知</li>
<li>API默认一个批次一个批次的推送消息过去</li>
</ul>
</li>
<li>
<p>配置属性 <em>PARTITIONER_CLASS_CONFIG</em> 批次类</p>
</li>
</ul>
<h2 id="消费者"><a class="header" href="#消费者">消费者</a></h2>
<p>属性</p>
<ul>
<li>
<p><em>bootstrap.servers</em> 集群</p>
</li>
<li>
<p>消费组ID <em>group.id</em></p>
</li>
<li>
<p><em>enable.auto.commit</em>  自动提交<em>offset</em></p>
</li>
<li>
<p><em>auto.commit.interval.ms</em> 提交延时</p>
</li>
<li>
<p><em>KV</em>反序列化 </p>
</li>
<li>
<p><em>AUTO_OFFSET_RESET_CONFIG</em></p>
<p><em>earliest</em> , <em>lastest</em>,每次连接到 Kafka集群 自动 <em>offset</em></p>
</li>
</ul>
<p>对象实例化</p>
<p><em>KafkaConsumer</em></p>
<p>订阅主题</p>
<p><em>subscribe</em></p>
<p>拉取消息</p>
<p><em>poll</em></p>
<p>直接定位<em>offset</em></p>
<p><em>seek</em></p>
<h2 id="消费者细化api"><a class="header" href="#消费者细化api">消费者细化API</a></h2>
<p>步骤</p>
<ol>
<li>
<p>根据指定分区 从主题元数据中找到 主副本</p>
<p><em>findLeader</em></p>
</li>
<li>
<p>获取分区最新消费进度</p>
<p><em>getLastOffset</em></p>
</li>
<li>
<p>从主副本拉去分区信息</p>
<p><em>run</em></p>
</li>
<li>
<p>识别主副本的变化 重试</p>
<p><em>findNewLeader</em></p>
</li>
</ol>
<h1 id=""><a class="header" href="#"></a></h1>
<h1 id="拦截器"><a class="header" href="#拦截器">拦截器</a></h1>
<p><em>ProducerInterceptor</em> </p>
<p>方法</p>
<p><em>configure</em></p>
<p>获取配置信息和初始化数据时调用</p>
<p><em>onsend(ProducerRecord)</em></p>
<p>发送前,序列化前 调用</p>
<p><em>onAcknowledement(RecordMetaData,Exception)</em></p>
<p>在<em>producer</em>的回调 之前调用</p>
<p><em>close</em> </p>
<p>关闭 </p>
<p>设置拦截器</p>
<p><em>Interceptor_classes_config</em></p>
<h2 id="kafka-eos-语义"><a class="header" href="#kafka-eos-语义">Kafka EOS 语义</a></h2>
<p><em>exactly once semantics</em></p>
<p>精确一次处理语义</p>
<h2 id="kafka-幂等性-idempotent"><a class="header" href="#kafka-幂等性-idempotent"><strong>Kafka 幂等性</strong> <em>Idempotent</em></a></h2>
<ul>
<li><em>Kafka</em>的幂等性实现 引入了 <em>PID(producerID)</em> 和 sequenceNumber</li>
<li><em>pid</em>:对于用户透明,每个<em>producer</em>在初始化的时候会被分配一个唯一的<em>PID</em></li>
<li><em>sequenceNumber</em> ,对于每一个PID,该<em>producer</em>发送到每个<em>partition</em>的数据都有对应的序列号,这些序列号时从0开始单调递增,broker只接收序号大于其缓存中 1 的,否则就丢弃</li>
<li>涉及的参数是 <em>enable.idempotence</em> = true</li>
<li>只能保证同个 <em>producer</em> 单会话,单个<em>partition</em> 的exactlyOnce语义</li>
</ul>
<h1 id="kafka事务"><a class="header" href="#kafka事务">Kafka事务</a></h1>
<ul>
<li>正是因为 Kafka幂等性不提供跨多个partition和 跨会话场景下的保证能够原子的处理多个<em>partition</em> 的写入操作</li>
</ul>
<h2 id="使用事务api注意事项"><a class="header" href="#使用事务api注意事项">使用事务API注意事项</a></h2>
<ul>
<li>需要消费者的自动模式设置为 false</li>
<li>不能手动执行<em>consumer#commitSync</em>或者<em>consumer#commitAsyc</em></li>
<li>生产者配置 <em>transactional</em>.<em>id</em> 属性</li>
<li>生产者不需要再配置 <em>enable.idempotence</em>，因为如果配置了<em>transaction.id</em>，则此时 <em>enable.idempotence</em> 会被设置为<em>true</em></li>
<li>消费者需要配置 <em>isolation.level</em> 属性，有两个可选值：&quot;<em>read_committed</em>&quot;，&quot;<em>read_uncommitted</em>&quot;，默认&quot;<em>read_uncommitted</em>&quot;</li>
</ul>
<h2 id="事务api"><a class="header" href="#事务api">事务API</a></h2>
<p>为producer提供了</p>
<p><em>initTransactions</em></p>
<p><em>beginTransaction</em></p>
<p><em>sendOffsetsToTransaction</em></p>
<p><em>commitTransaction</em></p>
<p><em>abortTransaction</em> </p>
<pre><code> Properties props = new Properties();
        props.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);
        props.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);
        props.put(&quot;client.id&quot;, &quot;ProducerTranscationnalExample&quot;);
        props.put(&quot;bootstrap.servers&quot;, &quot;192.168.3.7:9092&quot;);
        props.put(&quot;transactional.id&quot;, &quot;test-transactional&quot;);
        props.put(&quot;acks&quot;, &quot;all&quot;);

        KafkaProducer producer = new KafkaProducer(props);

        producer.initTransactions();

        try {

            String msg = &quot;matt test&quot;;
            producer.beginTransaction();
            producer.send(new ProducerRecord(&quot;first&quot;, &quot;1&quot;, msg.toString()));
            producer.send(new ProducerRecord(&quot;first&quot;, &quot;1&quot;, msg.toString()));
            producer.send(new ProducerRecord(&quot;first&quot;, &quot;1&quot;, msg.toString()));
            if(1 == 1)
            throw  new ProducerFencedException(&quot;自定义异常&quot;);

            producer.commitTransaction();
        } catch (ProducerFencedException e1) {

            e1.printStackTrace();
            producer.close();
        } catch (KafkaException e2) {
            e2.printStackTrace();
            producer.abortTransaction();

        }

        producer.close();
</code></pre>
<h2 id="事务具体实现"><a class="header" href="#事务具体实现">事务具体实现</a></h2>
<p>寻找TC</p>
<ul>
<li>
<p>Transaction Coordinator 运行在 Kafka 服务端，下面简称 TC 服务。</p>
</li>
<li>
<p>Kafka 有个特殊的事务 topic，名称为*__transaction_state*  负责持久化事务消息，有50个分区，每个分区负责一部分事务。事务划分是根据 <em>transaction id</em>，计算出该事务属于哪个分区。这个分区的 leader 所在的机器，负责这个事务的TC 服务地址</p>
</li>
<li>
<p>Producer 会首先从 Kafka 集群中选择任意一台机器，然后向其发送请求，获取 TC 服务的地址</p>
</li>
</ul>
<p>初始化事务</p>
<ul>
<li>Producer 在使用事务功能，必须先自定义一个唯一的 <em>transaction</em> id。有了 <em>transaction</em> id，即使客户端挂掉了，它重启后也能继续处理未完成的事务。</li>
<li>Kafka 实现事务需要依靠幂等性，而幂等性需要指定 producer id 。所以Producer在启动事务之前，需要向 TC 服务申请 producer id。TC 服务在分配 producer id 后，会将它持久化到事务 topic。</li>
</ul>
<p>发送消息</p>
<ul>
<li>
<p>Producer 在接收到 producer id 后，就可以正常的发送消息了。不过发送消息之前，需要先将这些消息的分区地址，上传到 TC 服务，TC 服务会将这些分区地址持久化到事务 topic</p>
</li>
<li>
<p>然后 Producer 才会真正的发送消息，这些消息与普通消息不同，它们会有一个字段，表示自身是事务消息。</p>
</li>
</ul>
<p>发送提交请求</p>
<ul>
<li>TC 服务收到事务提交请求后，会先将提交信息先持久化到事务 topic</li>
<li>持久化成功后，服务端就立即发送成功响应给 Producer</li>
<li>TC服务找到该事务涉及到的所有分区，为每 个分区生成提交请求，存到队列里等待发送</li>
</ul>
<p>发送事务结果信息给分区</p>
<ul>
<li>后台线程会不停的从队列里，拉取请求并且发送到分区。当一个分区收到事务结果消息后，会将结果保存到分区里，并且返回成功响应到 TC服务。当 TC 服务收到所有分区的成功响应后，会持久化一条事务完成的消息到事务 topic。至此，一个完整的事务流程就完成了</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-3"><a class="header" href="#简介-3">简介</a></h1>
<p>是一个高性能的key-value数据库</p>
<p>Redis支持数据的持久化</p>
<p>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储</p>
<p>Redis支持数据的备份，即master-slave模式的数据备份</p>
<h1 id="安装-1"><a class="header" href="#安装-1">安装</a></h1>
<p><a href="https://github.com/dmajkic/redis/downloads%E3%80%82">下载地址</a></p>
<p>运行命令:<code>redis-server.exe redis.conf</code></p>
<p><code>redis-cli.exe -h 127.0.0.1 -p 6379</code></p>
<pre><code class="language-shell">curl -O  http://download.redis.io/releases/redis-6.0.6.tar.gz
yum  -y  install  centos-release-scl
yum  -y  install  devtoolset-9-gcc  devtoolset-9-gcc-c++  devtoolset-9-binutils
scl enable devtoolset-9 bash
echo &quot;source /opt/rh/devtoolset-9/enable&quot; &gt;&gt;/etc/profile
tar -xf redis-6.0.6.tar.gz
cd redis-6.0.6
make

make  install  PREFIX=/usr/local/redis-6.0.6
cp redis.conf sentinel.conf   /usr/local/redis-6.0.6/
</code></pre>
<h1 id="文件目录"><a class="header" href="#文件目录">文件目录</a></h1>
<table><thead><tr><th>文件名</th><th>说明</th></tr></thead><tbody>
<tr><td>redis-server</td><td>服务</td></tr>
<tr><td>redis-cli</td><td>命令行客户端</td></tr>
<tr><td>redis-benchmark</td><td>性能测试工具</td></tr>
<tr><td>redis-check-aof</td><td>AOF 文件修复工具</td></tr>
<tr><td>redis-check-dump</td><td>RDB 文件检查工具</td></tr>
<tr><td>redis-sentinel</td><td>Sentinel 服务器（v2.8 后）</td></tr>
</tbody></table>
<h1 id="多数据库支持"><a class="header" href="#多数据库支持">多数据库支持</a></h1>
<p>Redis 默认支持 16 个数据库，不可以自定义数据库名，只能根据编号命名，默认从 0 开始。</p>
<p>不支持为每一个数据库设置密码，一个客户端要么能访问所有库，要么没权限访问。</p>
<h1 id="redis-安全"><a class="header" href="#redis-安全">Redis 安全</a></h1>
<ul>
<li><code>CONFIG get requirepass</code></li>
<li>设置密码:<code>CONFIG set requirepass &quot;xjq&quot;</code></li>
<li>验证密码:<code>AUTH &lt;password&gt;</code></li>
</ul>
<h1 id="redis-性能测试"><a class="header" href="#redis-性能测试">Redis 性能测试</a></h1>
<p><code>redis-benchmark [option] [option value]</code></p>
<table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>1</td><td><strong>-h</strong></td><td>指定服务器主机名</td><td>127.0.0.1</td></tr>
<tr><td>2</td><td><strong>-p</strong></td><td>指定服务器端口</td><td>6379</td></tr>
<tr><td>3</td><td><strong>-s</strong></td><td>指定服务器 socket</td><td></td></tr>
<tr><td>4</td><td><strong>-c</strong></td><td>指定并发连接数</td><td>50</td></tr>
<tr><td>5</td><td><strong>-n</strong></td><td>指定请求数</td><td>10000</td></tr>
<tr><td>6</td><td><strong>-d</strong></td><td>以字节的形式指定 SET/GET 值的数据大小</td><td>2</td></tr>
<tr><td>7</td><td><strong>-k</strong></td><td>1=keep alive 0=reconnect</td><td>1</td></tr>
<tr><td>8</td><td><strong>-r</strong></td><td>SET/GET/INCR 使用随机 key, SADD 使用随机值</td><td></td></tr>
<tr><td>9</td><td><strong>-P</strong></td><td>通过管道传输 <numreq> 请求</td><td>1</td></tr>
<tr><td>10</td><td><strong>-q</strong></td><td>强制退出 redis。仅显示 query/sec 值</td><td></td></tr>
<tr><td>11</td><td><strong>--csv</strong></td><td>以 CSV 格式输出</td><td></td></tr>
<tr><td>12</td><td><strong>-l</strong></td><td>生成循环，永久执行测试</td><td></td></tr>
<tr><td>13</td><td><strong>-t</strong></td><td>仅运行以逗号分隔的测试命令列表。</td><td></td></tr>
<tr><td>14</td><td><strong>-I</strong></td><td>Idle 模式。仅打开 N 个 idle 连接并等待。</td><td></td></tr>
</tbody></table>
<h1 id="客户端命令"><a class="header" href="#客户端命令">客户端命令</a></h1>
<table><thead><tr><th style="text-align: left">S.N.</th><th style="text-align: left">命令</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">1</td><td style="text-align: left"><strong>CLIENT LIST</strong></td><td style="text-align: left">返回连接到 redis 服务的客户端列表</td></tr>
<tr><td style="text-align: left">2</td><td style="text-align: left"><strong>CLIENT SETNAME</strong></td><td style="text-align: left">设置当前连接的名称</td></tr>
<tr><td style="text-align: left">3</td><td style="text-align: left"><strong>CLIENT GETNAME</strong></td><td style="text-align: left">获取通过 CLIENT SETNAME 命令设置的服务名称</td></tr>
<tr><td style="text-align: left">4</td><td style="text-align: left"><strong>CLIENT PAUSE</strong></td><td style="text-align: left">挂起客户端连接，指定挂起的时间以毫秒计</td></tr>
<tr><td style="text-align: left">5</td><td style="text-align: left"><strong>CLIENT KILL</strong></td><td style="text-align: left">关闭客户端连接</td></tr>
</tbody></table>
<h1 id="脚本"><a class="header" href="#脚本">脚本</a></h1>
<p>Lua 语言（Open Rest，Nginx 也可以使用 lua 语言，有机会学习了解一下）</p>
<p><strong>这里不详细记录 Lua 语法，不过有一点思考，既然 Nginx 也可以使用 Lua，那么可以就有一种场景，Nginx 通过 lua 访问 Redis 读取数据，并且用 lua 渲染模板，达到页面直出，这样应该效率很高。</strong></p>
<h1 id="事务"><a class="header" href="#事务">事务</a></h1>
<p><em>Redis 事务可以保证一个事务内的命令依次执行而不被其他命令插入。</em></p>
<p>Redis 事务的异常处理，首先需要先明确什么原因导致执行出错。</p>
<p>1）语法错，一旦前面有错，后面不会执行；</p>
<p>2）运行错，一旦有错，后续的命令会继续执行；</p>
<p><em>Redis 的事务没有关系数据库事务提供的回滚（rollback）[1]功能。为此开发者必须在事务执行出错后自己收拾剩下的摊子（将数据库复原回事务执行前的状态等）。</em></p>
<h1 id="持久化"><a class="header" href="#持久化">持久化</a></h1>
<ul>
<li>RDB （通过快照完成，当达到某种约定条件后自动生成一份备份并存储在硬盘上），<strong>快照原理</strong></li>
<li>AOF （存储非临时数据，每执行一条都会追加存储在硬盘，有一些性能影响）默认关闭，通过 <code>appendonly yes</code> 开启</li>
</ul>
<p>允许同时开启 RDB 和 AOF 两种模式。</p>
<h1 id="集群"><a class="header" href="#集群">集群</a></h1>
<p>Redis 支持集群，可以通过主从数据库来来规避单点数据库故障导致的问题。主数据库负责读写（读写分离也可以），当写操作导致数据变化时自动将数据同步给从库，从库只读，并只接受主库同步数据。</p>
<p>配置文件，通过 slaveof 主库地址 主库端口 来完成主从复制的配置。</p>
<blockquote>
<p>通过复制可以实现读写分离，以提高服务器负载能力。</p>
</blockquote>
<p>关键字记录，Redis 支持<strong>哨兵</strong>，一主多从，需要自动监控 Redis 运行情况，作用：1)监控主从数据库运行正常；2)主数据库故障自动将从数据库转换成主数据库；细节待补充一篇琢磨透彻一点的分析文。</p>
<h1 id="java使用redis"><a class="header" href="#java使用redis">Java使用redis</a></h1>
<h2 id="单链接"><a class="header" href="#单链接">单链接</a></h2>
<pre><code class="language-java">    Jedis jedis = new Jedis(&quot;localhost&quot;, 6379, 100000);
    jedis.auth(&quot;xjq&quot;);

    int i = 0;
    try {
        long start = System.currentTimeMillis();// 开始毫秒数
        while (true) {
            long end = System.currentTimeMillis();
            if (end - start &gt;= 1000) {// 当大于等于1000毫秒（相当于1秒）时，结束操作
                break;
            }
            i++;
            jedis.set(&quot;test&quot; + i, i + &quot;&quot;);
        }
    } finally {// 关闭连接
        jedis.close();
    }
    // 打印1秒内对Redis的操作次数
    System.out.println(&quot;redis每秒操作：&quot; + i + &quot;次&quot;);
}
</code></pre>
<h2 id="连接池"><a class="header" href="#连接池">连接池</a></h2>
<pre><code class="language-java">        JedisPoolConfig poolConfig = new JedisPoolConfig();
// 最大空闲数
        poolConfig.setMaxIdle(50);
// 最大连接数
        poolConfig.setMaxTotal(100);
// 最大等待毫秒数
        poolConfig.setMaxWaitMillis(20000);
// 使用配置创建连接池
        JedisPool pool = new JedisPool(poolConfig, &quot;localhost&quot;);
// 从连接池中获取单个连接
        Jedis jedis = pool.getResource();
// 如果需要密码
        jedis.auth(&quot;xjq&quot;);

        System.out.println(jedis.get(&quot;xjq&quot;));
</code></pre>
<h2 id="在-spring-中使用-redis"><a class="header" href="#在-spring-中使用-redis">在 Spring 中使用 Redis</a></h2>
<pre><code class="language-java">    @Bean
    public RedisTemplate redisTemplate(){
        RedisStandaloneConfiguration configuration = new RedisStandaloneConfiguration();
        configuration.setHostName(&quot;127.0.0.1&quot;);
        configuration.setPort(6379);
        configuration.setPassword(&quot;xjq&quot;);
        JedisConnectionFactory jedisConnectionFactory = new JedisConnectionFactory(configuration);
        RedisTemplate&lt;Object, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();
        redisTemplate.setConnectionFactory(jedisConnectionFactory);
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(new StringRedisSerializer() );
        return redisTemplate;
    }
</code></pre>
<pre><code class="language-java">private static void spring_test() {
    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MyConfig.class);
    applicationContext.register(MyConfig.class);

    RedisTemplate bean = applicationContext.getBean(RedisTemplate.class);
    bean.opsForValue().set(&quot;xjq&quot;,&quot;sxxx&quot;);
}
</code></pre>
<h2 id="springbooter配置"><a class="header" href="#springbooter配置">springBooter配置</a></h2>
<pre><code class="language-java">@Bean
public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory){
    RedisTemplate&lt;String, String&gt; redisTemplate = new RedisTemplate&lt;&gt;();
    redisTemplate.setKeySerializer(new StringRedisSerializer());
    redisTemplate.setConnectionFactory(redisConnectionFactory);
    redisTemplate.setValueSerializer(new StringRedisSerializer());
    return redisTemplate;
}
</code></pre>
<pre><code>spring:
  redis:
    password: xjq
    host: localhost
    port: 6379


  main:
    web-application-type: none
</code></pre>
<p><a href="https://github.com/yuzh233/redis-learning">redis学习</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="何为位图bitmap"><a class="header" href="#何为位图bitmap">何为位图（bitmap）</a></h1>
<p>位图不是特殊的数据结构，它本身是一个普通字符串，即 byte 数组。一个 byte 使用 8 个二进制位存储。redis 提供一系列操作二进制位的指令操作，这些操作称为「位图操作」。</p>
<ul>
<li>
<p>使用 getbit、setbit 可以直接对 value 的位进行操作，在处理数亿级别的<strong>业务标示位存储</strong>时能够节约很大的空间。</p>
</li>
<li>
<p>redis 中一个 String 类型的 value 能存储最大的值是 512MB、那么能存储大约 <strong>40亿</strong> 个bit。</p>
</li>
</ul>
<h1 id="基本使用"><a class="header" href="#基本使用">基本使用</a></h1>
<p>零存零取 setbit / getbit</p>
<p>我们可以使用 bitset 指令以「位存储」的方式存储一个 <code>he</code> 字符串，注意上面获取的是无符号表示，存储的时候需要添加第一位为符号位。</p>
<pre><code>127.0.0.1:6379&gt; setbit he 0 0 # 添加符号位
(integer) 0
127.0.0.1:6379&gt; setbit he 1 1
(integer) 0
127.0.0.1:6379&gt; setbit he 2 1
(integer) 0
127.0.0.1:6379&gt; setbit he 3 0
(integer) 0
127.0.0.1:6379&gt; setbit he 4 1
(integer) 0
127.0.0.1:6379&gt; setbit he 5 0
(integer) 0
127.0.0.1:6379&gt; setbit he 6 0
(integer) 0
127.0.0.1:6379&gt; setbit he 7 0
(integer) 0
127.0.0.1:6379&gt; get he # “整取”
&quot;h&quot; # 设置了第一个字符
127.0.0.1:6379&gt; setbit he 8 0 # 添加符号位
(integer) 0
127.0.0.1:6379&gt; setbit he 9 1
(integer) 0
127.0.0.1:6379&gt; setbit he 10 1
(integer) 0
127.0.0.1:6379&gt; setbit he 11 0
(integer) 0
127.0.0.1:6379&gt; setbit he 12 0
(integer) 0
127.0.0.1:6379&gt; setbit he 13 1
(integer) 0
127.0.0.1:6379&gt; setbit he 14 0
(integer) 0
127.0.0.1:6379&gt; setbit he 15 1
(integer) 0
127.0.0.1:6379&gt; get he # “整取”
&quot;he&quot; # 设置了两个字符
127.0.0.1:6379&gt; getbit he 14 # “零取”
(integer) 0
</code></pre>
<h2 id="统计和查找-bitcount--bitpos"><a class="header" href="#统计和查找-bitcount--bitpos">统计和查找 bitcount / bitpos</a></h2>
<ul>
<li>bitcount key [start end]：统计指定范围内 1 出现的次数；</li>
<li>bitpos key bit [start] [end]：统计指定范围内 0 或 1 第一次出现的位置。</li>
</ul>
<p>需要注意的是，这里的索引值是以 byte 为单位的，不是以 bit 为单位。即是以字节为范围查找的，如果需要以位范围查找必须是 8 的倍数。</p>
<p><img src="8.%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6_Redis//images/redis_bit_map_example.png" alt="" /></p>
<h2 id="批量操作-bitfield"><a class="header" href="#批量操作-bitfield">批量操作 bitfield</a></h2>
<p>bitfield 有三个子指令 set、get、incrby。他们可以对执行片段进行读写自增，最多处理 64 个连续位。</p>
<h1 id="使用场景"><a class="header" href="#使用场景">使用场景</a></h1>
<p>bitmap 非常合适存储标识字段，因为位存储的就是 0 和 1。假设存储一个 1 的标识字段，用 String 类型存储需要 1 个字节，八个位。如果直接用位存储则能存储 8 个标识字段。在大数据量的标示位存储下，bit 能节省很大空间。</p>
<h2 id="场景1统计用户某个时间段的登陆次数"><a class="header" href="#场景1统计用户某个时间段的登陆次数">【场景1】统计用户某个时间段的登陆次数</a></h2>
<pre><code>key：时间段，如 1月
offset：用户ID，必须是整数
value：是否上线标识位
</code></pre>
<p>前面以时间为主体，或者还可以以用户为主体，具体设计方式取决于取数据的方式。</p>
<pre><code>key：用户ID
offset：日期，如 200214
value：是否上线标识位
</code></pre>
<p>【场景2】存储用户一年的签到次数</p>
<pre><code>key：用户ID
offset：天数，1 代表今年的第一天，一年就只占用了 365 个位
value：是否签到标识
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="何为分布式锁"><a class="header" href="#何为分布式锁">何为分布式锁</a></h1>
<p>使用分布式锁，是为了解决并发情况下相同代码块被多个线程同时执行带来的数据错乱问题。使用分布式锁以保证同一个代码块只有一个线程被执行。</p>
<p>这个代码块的执行是一个原子操作，操作一开始就会一直运行到结束，不能被线程调度机制打断，不能发生线程上线文切换。</p>
<h1 id="redis-分布式锁的奥义"><a class="header" href="#redis-分布式锁的奥义">Redis 分布式锁的奥义</a></h1>
<p>分布式锁本质上要实现的目标是在 redis 中占一个「坑」，当别的线程也要来占坑时，发现坑里已经有一根 “大萝卜”了，就只能放弃或重试。</p>
<p>占坑一般使用 setnx 指令，此操作只能允许一个线程来占坑，先来先占，用完来再调用 del 指令来释放 “坑”。</p>
<pre><code>127.0.0.1:6379&gt; setnx lock-test 1
(integer) 1
// TODO do something...
127.0.0.1:6379&gt; del locl-test
(integer) 0
</code></pre>
<h2 id="问题1"><a class="header" href="#问题1">问题1</a></h2>
<p>如果逻辑执行到中间出现异常了或机器宕机，那么就导致 del 指令没有被执行，锁就永远得不到释放。我们可以通过拿到锁后给锁加一个过期时间，这样保证如果出现异常了锁也会自动释放。</p>
<pre><code>127.0.0.1:6379&gt; set lock:test 1
OK
127.0.0.1:6379&gt; expire lock:test 10
(integer) 1
// TODO do something...
127.0.0.1:6379&gt; del lock:test
(integer) 0
</code></pre>
<h2 id="问题2"><a class="header" href="#问题2">问题2</a></h2>
<ul>
<li>如果 set 指令和 expire 指定执行中间，服务器宕机了，expire 得不到执行，锁得不到释放，那么也会出现死锁。这是因为 set 和 expire 是两条指令，不是一个原子操作。</li>
<li>好在 redis2.8 后，可以通过给 set 指令添加拓展参数使得 setnx 和 expire 可以一起执行。</li>
</ul>
<pre><code>127.0.0.1:6379&gt; set lock:codehole 1 ex 30 nx # 相当于 setnx lock:codehole 1 &amp; expire lock:codehole 30
OK
127.0.0.1:6379&gt; set lock:codehole 1 ex 30 nx # 已存在，setex 失败。
(nil)
127.0.0.1:6379&gt; del lock:codehole
(integer) 1
</code></pre>
<h2 id="超时问题"><a class="header" href="#超时问题">超时问题</a></h2>
<p><strong>如果加锁的代码块执行时间太久，锁自动释放了。</strong></p>
<p>加锁的代码块还没执行完毕第二个线程提前拿到了锁，会导致原来加锁的代码块得不到严格的串行执行。</p>
<p>要规避这种问题，应该尽量避免加锁代码块用于执行时间过长的任务，合理配置锁的过期时间。</p>
<p><strong>超时还会导致另一个问题，当前线程可能会释放另一个线程的锁。</strong></p>
<p>线程A由于执行时间过长锁被自动释放，线程B拿到锁还没执行完，线程A代码块执行完后调用 del 指令释放锁，然而此时释放的却是线程B的锁。</p>
<p>要规避这种问题，<strong>我们可以设置 set 指令的 value 参数为一个随机数（或当前线程名），删除时传入这个随机数，这样用来避免当前线程的锁被其他线程释放</strong>。</p>
<p>伪代码如下，其中 if 分支判断和 del 操作不是原子操作，如果进入 if 分支后系统挂了锁就不会执行 del 指令了。（不过当前锁已过期了，但是保证了当前线程不会释放其他线程的锁。）</p>
<pre><code class="language-java">String ramdonValue = &quot;1&quot;;
String value = jedis.get(&quot;key&quot;);
if (ramdonValue.equals(value)) {
    jedis.del(&quot;key&quot;);
}
</code></pre>
<p>虽然在 if 分支挂掉不会误释放其他线程的锁，但是还有更优雅的方式：即使用 lua 脚本，lua 脚本中的语句会被当作一个原子操作来执行。</p>
<pre><code class="language-java">String luaScript = &quot;if redis.call('get', KEYS[1]) == ARGV[1] &quot; +
                    &quot;then&quot; +
                    &quot;   return redis.call('del', KEYS[1])&quot; +
                    &quot;else &quot; +
                    &quot;   return 0 &quot; +
                    &quot;end&quot;;
Object value = jedis.eval(luaScript, Collections.singletonList(&quot;lock:test&quot;), Collections.singletonList(&quot;randomValue&quot;));
System.out.println(value);
</code></pre>
<p>这种方案只是相对安全一点，如果真的超时了，其他线程就会乘虚而入。</p>
<p>一种解决方案是给当前线程添加一个守护线程，间断的给当前锁「续命」，如果系统宕机，守护线程会随着主线程的死亡而死亡，一段时间后锁被自动释放。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="问题描述"><a class="header" href="#问题描述">问题描述</a></h1>
<p>Shiro 并没有直接提供 Redis 存储 Session 组件，所以使用 Github 一个开源组件 <a href="https://github.com/alexxiyang/shiro-redis">shiro-redis</a></p>
<p>由于 Shiro 框架需要定期验证 Session 是否有效，于是 Shiro 底层将会调用 <code>SessionDAO#getActiveSessions</code> 获取所有的 Session 信息。</p>
<p>底层使用用<code>keys</code> 命令查找 Redis 所有存储的 <code>Session</code> key，效率较慢</p>
<pre><code class="language-java">public Set&lt;byte[]&gt; keys(byte[] pattern){
    checkAndInit();
    Set&lt;byte[]&gt; keys = null;
    Jedis jedis = jedisPool.getResource();
    try{
        keys = jedis.keys(pattern);
    }finally{
        jedis.close();
    }
    return keys;
}
</code></pre>
<p>在最新版本中，<code>shiro-redis</code> 采用 <code>scan</code>命令代替 <code>keys</code>,从而修复这个问题。</p>
<pre><code class="language-java">public Set&lt;byte[]&gt; keys(byte[] pattern) {
    Set&lt;byte[]&gt; keys = null;
    Jedis jedis = jedisPool.getResource();

    try{
        keys = new HashSet&lt;byte[]&gt;();
        ScanParams params = new ScanParams();
        params.count(count);
        params.match(pattern);
        byte[] cursor = ScanParams.SCAN_POINTER_START_BINARY;
        ScanResult&lt;byte[]&gt; scanResult;
        do{
            scanResult = jedis.scan(cursor,params);
            keys.addAll(scanResult.getResult());
            cursor = scanResult.getCursorAsBytes();
        }while(scanResult.getStringCursor().compareTo(ScanParams.SCAN_POINTER_START) &gt; 0);
    }finally{
        jedis.close();
    }
    return keys;

}
</code></pre>
<p>为什么<code>keys</code> 指令会导致其他命令执行变慢？</p>
<p>为什么<code>Keys</code> 指令查询会这么慢？</p>
<p>为什么<code>Scan</code> 指令就没有问题？</p>
<h1 id="redis-执行命令的原理"><a class="header" href="#redis-执行命令的原理">Redis 执行命令的原理</a></h1>
<p><img src="8.%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6_Redis//images/redis-execute-cmd.jpg" alt="" /></p>
<p>由于 Redis 单线程执行命令，只能顺序从队列取出任务开始执行。</p>
<p>只要 3 这个过程执行命令速度过慢，队列其他任务不得不进行等待，这对外部客户端看来，Redis 好像就被阻塞一样，一直得不到响应。</p>
<h1 id="keys-原理"><a class="header" href="#keys-原理">KEYS 原理</a></h1>
<p>Redis 底层使用字典这种结构，这个结构与 Java HashMap 底层比较类似。</p>
<p><code>keys</code>命令需要返回所有的符合给定模式 <code>pattern</code> 的 Redis 中键，为了实现这个目的，Redis 不得不遍历字典中 <code>ht[0]</code>哈希表底层数组，这个时间复杂度为 <strong>O(N)</strong>（N 为 Redis 中 key 所有的数量）。</p>
<h1 id="scan-原理"><a class="header" href="#scan-原理">SCAN 原理</a></h1>
<p>最后我们来看下第三个问题，为什么<code>scan</code> 指令就没有问题？</p>
<p>这是因为 <code>scan</code>命令采用一种黑科技-<strong>基于游标的迭代器</strong>。</p>
<p>每次调用 <code>scan</code> 命令，Redis 都会向用户返回一个新的游标以及一定数量的 key。下次再想继续获取剩余的 key，需要将这个游标传入 scan 命令， 以此来延续之前的迭代过程。</p>
<p>简单来讲，<code>scan</code> 命令使用分页查询 redis 。</p>
<p>下面是一个 scan 命令的迭代过程示例：</p>
<p><code>scan</code> 命令使用游标这种方式，巧妙将一次全量查询拆分成多次，降低查询复杂度。</p>
<p>虽然 <code>scan</code> 命令时间复杂度与 <code>keys</code>一样，都是 <strong>O(N)</strong>，但是由于 <code>scan</code> 命令只需要返回少量的 key，所以执行速度会很快。</p>
<p>最后，虽然<code>scan</code> 命令解决 <code>keys</code>不足，但是同时也引入其他一些缺陷：</p>
<ul>
<li>同一个元素可能会被返回多次，这就需要我们应用程序增加处理重复元素功能。</li>
<li>如果一个元素在迭代过程增加到 redis，或者说在迭代过程被删除，那个这个元素会被返回，也可能不会。</li>
</ul>
<p>除了 <code>scan</code>以外，redis 还有其他几个用于增量迭代命令：</p>
<ul>
<li><code>sscan</code>:用于迭代当前数据库中的数据库键，用于解决 <code>smembers</code> 可能产生阻塞问题</li>
<li><code>hscan</code>命令用于迭代哈希键中的键值对，用于解决 <code>hgetall</code> 可能产生阻塞问题。</li>
<li><code>zscan</code>:命令用于迭代有序集合中的元素（包括元素成员和元素分值），用于产生 <code>zrange</code> 可能产生阻塞问题。</li>
</ul>
<h1 id="总结"><a class="header" href="#总结">总结</a></h1>
<p>Redis 使用单线程执行操作命令，所有客户端发送过来命令，Redis 都会现放入队列，然后从队列中顺序取出执行相应的命令。</p>
<p>所以不要在生产执行 <code>keys</code>、<code>smembers</code>、<code>hgetall</code>、<code>zrange</code>这类可能造成阻塞的指令，如果真需要执行，可以使用相应的<code>scan</code> 命令渐进式遍历，可以有效防止阻塞问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli工具的类型"><a class="header" href="#cli工具的类型">CLI工具的类型</a></h1>
<table><thead><tr><th>可执行文件</th><th>作用</th></tr></thead><tbody>
<tr><td>redis-server</td><td>Redis Srver相关</td></tr>
<tr><td>redis-cli</td><td>Redis命令行工具</td></tr>
<tr><td>redis-benchmark</td><td>基准测试工具</td></tr>
<tr><td>redis-check-aof</td><td>AOF持久化文件检测工具和修复工具</td></tr>
<tr><td>redis-check-rdb</td><td>RDB持久化文件检测工具和修复工具</td></tr>
<tr><td>redis-sentinel</td><td>Redis哨兵系统</td></tr>
</tbody></table>
<h1 id="redis-cli"><a class="header" href="#redis-cli">redis-cli</a></h1>
<p><strong>命令方式</strong></p>
<pre><code># 直接得到命令的返回结果,显示在屏幕上。
redis-cli -h {host} -p {port} {command}
</code></pre>
<p><strong>交互式命令行方式</strong></p>
<pre><code>redis-cli -h {host} -p {port} 
</code></pre>
<p><strong>命令</strong></p>
<table><thead><tr><th>选项</th><th>说明</th><th></th></tr></thead><tbody>
<tr><td>time</td><td>返回当前服务器时间</td><td></td></tr>
<tr><td>eval</td><td>运行lua脚本</td><td></td></tr>
<tr><td>evalsha</td><td>根据给定的 sha1 校验码，执行缓存在服务器中的脚本。</td><td></td></tr>
<tr><td>script exists</td><td>查看指定的脚本是否已经被保存在缓存当中</td><td></td></tr>
<tr><td>script flush</td><td>从脚本缓存中移除所有脚本</td><td></td></tr>
<tr><td>script kill</td><td>杀死当前正在运行的 Lua 脚本</td><td></td></tr>
<tr><td>script load</td><td>将脚本添加到脚本缓存中,并不立即执行这个脚本</td><td></td></tr>
<tr><td>dbsize</td><td>返回当前数据库的 key 的数量</td><td></td></tr>
<tr><td>client list</td><td>返回所有连接到服务器的客户端信息和统计数据</td><td></td></tr>
<tr><td>select</td><td>切换到指定的库</td><td></td></tr>
<tr><td>quit</td><td>关闭连接</td><td></td></tr>
<tr><td>auth</td><td>密码认证</td><td></td></tr>
<tr><td>echo</td><td>打印字符串</td><td></td></tr>
<tr><td>ping</td><td>查看服务是否运行,如果Redis存活会返回pong</td><td></td></tr>
<tr><td>client kill ip:port</td><td>关闭地址为 <code>ip:port</code> 的客户端</td><td></td></tr>
<tr><td>save</td><td>将数据同步保存到磁盘</td><td></td></tr>
<tr><td>bgsave</td><td>将数据异步保存到磁盘</td><td></td></tr>
<tr><td>lastsave</td><td>返回上次成功将数据保存到磁盘的Unix时戳</td><td></td></tr>
<tr><td>shundown</td><td>异步保存数据到硬盘，并关闭服务器</td><td></td></tr>
<tr><td>info</td><td>提供服务器的信息和统计</td><td></td></tr>
<tr><td>config resetstat</td><td>重置info命令中的某些统计数据</td><td></td></tr>
<tr><td>config get</td><td>获取配置文件信息,<code>CONFIG GET *</code>获取所有配置信息</td><td></td></tr>
<tr><td>config set</td><td>动态地调整 Redis 服务器的配置而无须重启</td><td></td></tr>
<tr><td>config rewrite</td><td>Redis 服务器时所指定的 <code>redis.conf</code> 文件进行改写</td><td></td></tr>
<tr><td>monitor</td><td>实时监控收到的所有请求</td><td></td></tr>
<tr><td>slaveof</td><td>将当前服务器转变为指定服务器的从属服务器(slave server)</td><td></td></tr>
<tr><td>role</td><td>返回主从实例所属的角色</td><td></td></tr>
<tr><td>BGREWRITEAOF</td><td>异步执行一个 AOF（AppendOnly File） 文件重写操作</td><td></td></tr>
<tr><td>CLIENT GETNAME</td><td>获取连接的名称</td><td></td></tr>
<tr><td>CLIENT SETNAME</td><td>设置当前连接的名称</td><td></td></tr>
<tr><td>CLIENT PAUSE</td><td>阻塞客户端命令一段时间（以毫秒计）</td><td></td></tr>
<tr><td>CLUSTER SLOTS</td><td>获取集群节点的映射数组</td><td></td></tr>
<tr><td>COMMAND</td><td>获取 Redis 命令详情数组</td><td></td></tr>
<tr><td>COMMAND COUNT</td><td>获取 Redis 命令总数</td><td></td></tr>
<tr><td>COMMAND GETKEYS</td><td>获取给定命令的所有键</td><td></td></tr>
<tr><td>COMMAND INFO</td><td>获取指定 Redis 命令描述的数组</td><td></td></tr>
<tr><td>DEBUG OBJECT</td><td>获取 key 的调试信息</td><td></td></tr>
<tr><td>DEBUG SEGFAULT</td><td>让 Redis 服务崩溃</td><td></td></tr>
<tr><td>FLUSHALL</td><td>删除所有数据库的所有key</td><td></td></tr>
<tr><td>FLUSHDB</td><td>删除当前数据库的所有key</td><td></td></tr>
<tr><td>SLOWLOG</td><td>管理 redis 的慢日志</td><td></td></tr>
<tr><td>SYNC</td><td>用于复制功能(replication)的内部命令</td><td></td></tr>
<tr><td>memory purge</td><td>重整内存碎片,主动释放已删除的内存,会阻塞主线程 4.0以上版本</td><td></td></tr>
</tbody></table>
<h1 id="redis-sever"><a class="header" href="#redis-sever">redis-sever</a></h1>
<p>**语法格式：**redis-server [参数]</p>
<p><strong>常用参数：</strong></p>
<table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody>
<tr><td>--port</td><td>配置端口</td></tr>
<tr><td>--slaveof</td><td>将当前服务器转变为指定服务器的从属服务器</td></tr>
<tr><td>--loglevel</td><td>配置日志级别</td></tr>
<tr><td>--sentinel</td><td>以哨兵模式运行</td></tr>
<tr><td>--masterauth</td><td>如果主库设置了主从密码, 从库需要用该参数指定主从密码</td></tr>
<tr><td>-a</td><td>指定密码</td></tr>
</tbody></table>
<h1 id="客户端选项redis-cli"><a class="header" href="#客户端选项redis-cli">客户端选项<code>redis-cli</code></a></h1>
<table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>选项</td><td>说明</td><td>案例</td></tr>
<tr><td>-h</td><td>指定Redis server地址</td><td></td></tr>
<tr><td>-p</td><td>指定Redis server端口号</td><td></td></tr>
<tr><td>-s</td><td>指定服务器套接字(覆盖主机名和端口)。</td><td></td></tr>
<tr><td>-a</td><td>指定密码</td><td></td></tr>
<tr><td>-u</td><td>url格式的地址</td><td></td></tr>
<tr><td>-r</td><td>将命令重复执行N次</td><td></td></tr>
<tr><td>-i</td><td>每隔N秒执行一次命令，必须与-r一起使用。</td><td></td></tr>
<tr><td>-n</td><td>选择库号</td><td></td></tr>
<tr><td>-x</td><td>代表从标准输入读取数据作为该命令的最后一个参数。</td><td></td></tr>
<tr><td>-d</td><td>原始格式中的多块分隔符(默认值:\n)。</td><td></td></tr>
<tr><td>-c</td><td>连接cluster集群结点时用的，此选项可防止moved和ask异常。</td><td></td></tr>
<tr><td>--csv</td><td>将数据导出为CSV格式的文件</td><td></td></tr>
<tr><td>--scan</td><td>获取服务器所有的键</td><td></td></tr>
<tr><td>--pattern</td><td>指定scan获取的key的pattern,正则表达式用于scan命令后过滤.</td><td></td></tr>
<tr><td>--slave</td><td>当前客户端模拟成当前redis节点的从节点，可用来获取指定redis节点的更新操作</td><td></td></tr>
<tr><td>--rdb</td><td>导出rdb文件，保存导到指定的位置</td><td></td></tr>
<tr><td>--pipe</td><td>将命令封装成redis通信协议定义的数据格式，批量发送给redis执行。</td><td></td></tr>
<tr><td>--pipe-timeout</td><td>设置管道超时时间</td><td></td></tr>
<tr><td>--bigkeys</td><td>统计bigkey的分布，使用scan命令对redis的键进行采样，从中找到内存占用比较大的键</td><td></td></tr>
<tr><td>--hotkeys</td><td>找出server中热点key</td><td></td></tr>
<tr><td>--stat</td><td>实时获取redis的统计信息。istat和info相比可以看到一些增加的数据,如:每秒请求数</td><td></td></tr>
<tr><td>--raw</td><td>显示格式化的效果</td><td></td></tr>
<tr><td>--no-raw</td><td>要求返回原始格式</td><td></td></tr>
<tr><td>--eval</td><td>用于执行lua脚本</td><td></td></tr>
<tr><td>--latency</td><td>持续采样服务器延迟</td><td></td></tr>
<tr><td>--latency-history</td><td>持续采样服务器延迟并每隔(15秒)输出一个记录; 可以使用-i 更改间隔时间</td><td></td></tr>
<tr><td>--latency-dist</td><td>使用彩色终端显示一系列延时特征</td><td></td></tr>
<tr><td>--intrinsic-latency</td><td>固有延迟,由于操作系统或虚拟机/容器带来的延迟,需要在redis-server的本器上进行测量.</td><td></td></tr>
<tr><td>--ldb</td><td>与--eval一起使用可以启用Redis Lua调试器</td><td></td></tr>
<tr><td>--ldb-sync-mode</td><td>比如--ldb，但是使用了同步Lua调试器, 此模式将阻塞服务器并更改脚本</td><td></td></tr>
<tr><td>--lru-test</td><td></td><td></td></tr>
</tbody></table>
<h1 id="redis-cli-stat"><a class="header" href="#redis-cli-stat"><code>redis-cli stat</code></a></h1>
<table><thead><tr><th>选项</th><th>说明</th><th>案例</th></tr></thead><tbody>
<tr><td>keys</td><td>server中key的数量</td><td></td></tr>
<tr><td>mem</td><td>键值对的总内存量</td><td></td></tr>
<tr><td>clients</td><td>当前连接的总clients数量</td><td></td></tr>
<tr><td>blocked</td><td>正在等待执行阻塞命令（BLPOP、BRPOP、BRPOPLPUSH 等等）的客户端数量</td><td></td></tr>
<tr><td>requests</td><td>服务器请求总次数 (+1) 截止上次请求增加次数</td><td></td></tr>
<tr><td>connections</td><td>服务器连接次数</td><td></td></tr>
</tbody></table>
<h1 id="性能测试工具redis-benchmark"><a class="header" href="#性能测试工具redis-benchmark">性能测试工具<code>redis-benchmark</code></a></h1>
<p><code>redis-benchmark</code>命令不属于<code>redis-cli</code>而是在Redis的其他工具,默认在Redis目录下</p>
<table><thead><tr><th>选项</th><th>说明</th><th>案例</th></tr></thead><tbody>
<tr><td>-h</td><td>指定服务器主机名</td><td></td></tr>
<tr><td>-p</td><td>指定服务器端口</td><td></td></tr>
<tr><td>-s</td><td>指定服务器 socket</td><td></td></tr>
<tr><td>-c</td><td>指定并发连接数</td><td></td></tr>
<tr><td>-n</td><td>指定请求数</td><td></td></tr>
<tr><td>-d</td><td>以字节的形式指定 SET/GET 值的数据大小</td><td></td></tr>
<tr><td>-k</td><td>1=keep alive 0=reconnect</td><td></td></tr>
<tr><td>-r</td><td>SET/GET/INCR 使用随机 key, SADD 使用随机值</td><td></td></tr>
<tr><td>-P</td><td>通过管道传输 <numreq> 请求</td><td></td></tr>
<tr><td>-q</td><td>强制退出 redis。仅显示 query/sec 值</td><td></td></tr>
<tr><td>--csv</td><td>以 CSV 格式输出</td><td></td></tr>
<tr><td>-l</td><td>生成循环，永久执行测试</td><td></td></tr>
<tr><td>-t</td><td>仅运行以逗号分隔的测试命令列表。</td><td></td></tr>
<tr><td>-I</td><td>Idle 模式。仅打开 N 个 idle 连接并等待。</td><td></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前言-5"><a class="header" href="#前言-5">前言</a></h1>
<p><strong>启用服务</strong></p>
<pre><code class="language-shell">./redis-server /root/redis-5.0.7/etc/redis.conf 
</code></pre>
<p><strong>关闭服务</strong></p>
<pre><code>redis-cli -p 6379 shutdown 
</code></pre>
<h1 id="redis参数配置解析"><a class="header" href="#redis参数配置解析">Redis参数配置解析</a></h1>
<h2 id="服务端配置"><a class="header" href="#服务端配置">服务端配置</a></h2>
<pre><code># redis进程是否以守护进程的方式运行，yes为是，no为否(不以守护进程的方式运行会占用一个终端)。 
daemonize no 
# 绑定的主机地址 
bind 127.0.0.1 
# redis进程的端口号 
port 6379 
#是否开启保护模式，默认开启。要是配置里没有指定bind和密码。开启该参数后，redis只会本地进行访问，拒绝外部访问。要是开启了密码和bind，可以开启。否则最好关闭设置为no。 
protected-mode yes
# 指定redis进程的PID文件存放位置 
pidfile /var/run/redis.pid
</code></pre>
<h2 id="客户端配置"><a class="header" href="#客户端配置"><strong>客户端配置</strong></a></h2>
<pre><code># 客户端闲置多长时间后关闭连接，默认此参数为0即关闭此功能 
timeout 300 
# 设置同一时间最大客户连接数，默认无限制。redis可以同时连接的客户端数为redis程序可以打开的最大文件描述符，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回 max number of clients reached 错误信息 
maxclients 128 
# 设置redis连接密码，如果配置了连接密码，客户端在连接redis是需要通过AUTH&lt;password&gt;命令提供密码，默认关闭 
requirepass footbared 
# 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key。当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区 
maxmemory&lt;bytes&gt; 
# 选择数据库，默认为0可以使用select &lt;dbid&gt;命令在连接上指定数据库id 
databases 16 
</code></pre>
<h2 id="日志"><a class="header" href="#日志">日志</a></h2>
<pre><code># redis日志级别，可用的级别有debug.verbose.notice.warning 
loglevel verbose 
# log文件输出位置，如果进程以守护进程的方式运行，此处又将输出文件设置为stdout的话，就会将日志信息输出到/dev/null里面去了 
logfile stdout 
</code></pre>
<h2 id="持久化-1"><a class="header" href="#持久化-1">持久化</a></h2>
<pre><code># 指定在多少时间内刷新次数达到多少的时候会将数据同步到数据文件 
save &lt;seconds&gt; &lt;changes&gt; 
# 指定存储至本地数据库时是否压缩文件，默认为yes即启用存储 
rdbcompression yes 
# 指定本地数据库文件名 
dbfilename dump.db 
# 指定本地数据问就按存放位置 
dir ./ 
# 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no。 
appendonly no 
# 指定跟新日志文件名默认为appendonly.aof 
appendfilename appendonly.aof 
# 指定更新日志的条件，有三个可选参数 - no：表示等操作系统进行数据缓存同步到磁盘(快)，always：表示每次更新操作后手动调用fsync()将数据写到磁盘(慢，安全)， everysec：表示每秒同步一次(折衷，默认值)； 
appendfsync everysec 
</code></pre>
<h2 id="集群配置"><a class="header" href="#集群配置">集群配置</a></h2>
<pre><code># 指定当本机为slave服务时，设置master服务的IP地址及端口，在redis启动的时候他会自动跟master进行数据同步 
replicaof &lt;masterip&gt; &lt;masterport&gt; 
# 当master设置了密码保护时，slave服务连接master的密码 
masterauth &lt;master-password&gt; 
</code></pre>
<h1 id="主从同步原理"><a class="header" href="#主从同步原理">主从同步原理</a></h1>
<h2 id="全量同步"><a class="header" href="#全量同步"><strong>全量同步</strong></a></h2>
<p>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下： </p>
<ul>
<li>从服务器连接主服务器，发送SYNC命令； </li>
<li>主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令； </li>
<li>主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； </li>
<li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； </li>
<li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； </li>
<li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令； </li>
</ul>
<pre><code class="language-mermaid">sequenceDiagram
participant a as 主服务器 
participant b as 从服务器
b -&gt;&gt;+ a:从服务器连接主服务器，发送sync指令
a -&gt;&gt;- a:执行 BGSAVE 生成快照，记录在此期间的写命令
a -&gt;&gt;+ b:发送快照
b -&gt;&gt;- b:写入快照
a -&gt;&gt;+ b:发送缓存的写命令
b -&gt;&gt;- b:执行写命令
</code></pre>
<p>完成上面几个步骤后就完成了从服务器数据初始化的所有操作，从服务器此时可以接收来自用户的读请求。</p>
<h2 id="增量同步"><a class="header" href="#增量同步"><strong>增量同步</strong></a></h2>
<p>Redis增量复制是指Slave初始化后开始正常工作时 <strong>主服务器发生的写操作同步到从服务器</strong>的过程。 </p>
<p>增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</p>
<p><strong>Redis主从同步策略</strong></p>
<p>主从刚刚连接的时候，进行全量同步；</p>
<p>全同步结束后，进行增量同步。</p>
<p>当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p>
<p><strong>注意点</strong></p>
<p>如果多个Slave断线了，需要重启的时候，因为只要Slave启动，就会发送sync请求和主机全量同步，当多个同时出现的时候，可能会导致Master IO剧增宕机。</p>
<h1 id="redis-sentinel哨兵"><a class="header" href="#redis-sentinel哨兵"><strong>Redis Sentinel（哨兵）</strong></a></h1>
<h2 id="简介-4"><a class="header" href="#简介-4">简介</a></h2>
<p>Redis的主从复制下，一旦主节点由于故障不能提供服务，需要人工将从节点晋升为主节点，同时还要通知应用方更新主节点地址，对于很多应用场景这种故障处理的方法是无法接受的。但是Redis从2.8开始正式提供了Redis Sentinel（哨兵）架构来解决这个问题。</p>
<p>​    Redis Sentinel是一个分布式架构，其中包含若干个Sentinel节点和Redis数据节点，每个Sentinel节点会对数据节点和其余Sentinel节点进行监控，当它发现节点不可达时，会对节点做下线标识。如果被标识的是主节点，它还会和其他Sentinel节点进行“协商”，当大多数Sentinel节点都认为主节点不可达时，它们会选举出一个Sentinel节点来完成自动故障转移的工作，同时会将这个变化通知给Redis应用方。整个过程完全是自动的，不需要人工来介入，所以这套方案很有效地解决了Redis的高可用问题。</p>
<h2 id="实现原理"><a class="header" href="#实现原理">实现原理</a></h2>
<p><strong>三个定时监控任务</strong></p>
<ul>
<li>
<p><strong>获取最新拓扑结构</strong></p>
<p>每隔10秒，每个Sentinel节点会向主节点和从节点发送info命令获取最新的拓扑结构。</p>
</li>
<li>
<p><strong>主节点判断</strong></p>
<p>每隔2秒，每个Sentinel节点会向Redis数据节点的__sentinel__:hello频道上发送该Sentinel节点对于主节点的判断以及当前Sentinel节点的信息，同时每个Sentinel节点也会订阅该频道，来了解其他Sentinel节点以及它们对主节点的判断。</p>
</li>
<li>
<p><strong>心跳检测</strong></p>
<p>每隔一秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，来确认这些节点当前是否可达。</p>
</li>
</ul>
<p><strong>主观下线</strong></p>
<p>因为每隔一秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，当这些节点超过down-after-milliseconds没有进行有效回复，Sentinel节点就会对该节点做失败判定，这个行为叫做主观下线。</p>
<p><strong>客观下线</strong></p>
<p>当Sentinel主观下线的节点是主节点时，该Sentinel节点会向其他Sentinel节点询问对主节点的判断，当超过<code>&lt;quorum&gt;</code>个数，那么意味着大部分的Sentinel节点都对这个主节点的下线做了同意的判定，于是该Sentinel节点认为主节点确实有问题，这时该Sentinel节点会做出客观下线的决定。</p>
<p><strong>领导者Sentinel节点选举</strong></p>
<p>Raft算法：假设s1(sentinel-1)最先完成客观下线，它会向其余Sentinel节点发送命令，请求成为领导者；收到命令的Sentinel节点如果没有同意过其他Sentinel节点的请求，那么就会同意s1的请求，否则拒绝；如果s1发现自己的票数已经大于等于某个值，那么它将成为领导者。</p>
<p><strong>故障转移</strong></p>
<p>1）领导者Sentinel节点在从节点列表中选出一个节点作为新的主节点</p>
<p>2）上一步的选取规则是与主节点复制相似度最高的从节点</p>
<p>3）领导者Sentinel节点让剩余的从节点成为新的主节点的从节点</p>
<p>4）Sentinel节点集合会将原来的主节点更新为从节点，并保持着对其关注，当其恢复后命令它去复制新的主节点</p>
<h1 id="主从哨兵"><a class="header" href="#主从哨兵">主从+哨兵</a></h1>
<h2 id="主从结构哨兵sentinel"><a class="header" href="#主从结构哨兵sentinel">主从结构+哨兵(sentinel)</a></h2>
<p><img src="8.%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6_Redis//images/redis-cluster-structure.jpeg" alt="" /></p>
<p>一个主节点(master)可拥有多个从节点(slave)，从节点实现对主节点的复制，保证数据同步。</p>
<p>而哨兵(sentinel)则对各节点进行监控，主要包括主节点存活检测、主从运行情况检测等，一旦主节点宕机，哨兵可自动进行故障转移 (failover)、主从切换。接下来就开始搭建这样一个集群，首先是主从结构，然后是哨兵模式，接着往下看。</p>
<h2 id="redis-主从配置及数据同步"><a class="header" href="#redis-主从配置及数据同步"><strong>Redis 主从配置及数据同步</strong></a></h2>
<pre><code>主
192.168.1.210 6379
从
192.168.1.210 6380
192.168.1.210 6381
192.168.1.210 6382
</code></pre>
<pre><code>bind：0.0.0.0 
port：6379 
protected-mode：no 
daemonize：yes 
logfile：./redis.log 
requirepass：pwdtest@2019 
masterauth：pwdtest@2019 
replicaof 192.168.231.130 6379
</code></pre>
<h2 id="redis-哨兵模式搭建"><a class="header" href="#redis-哨兵模式搭建"><strong>Redis 哨兵模式搭建</strong></a></h2>
<h3 id="哨兵模式详解"><a class="header" href="#哨兵模式详解"><strong>哨兵模式详解</strong></a></h3>
<p>Sentinel 使用的算法核心是 Raft 算法，主要用途就是用于分布式系统，系统容错，以及Leader选举，每个Sentinel都需要定期的执行以下任务：</p>
<ul>
<li>每个 Sentinel 会自动发现其他 Sentinel 和从服务器，它以每秒钟一次的频率向它所知的主服务器、从服务器以及其他 Sentinel 实例发送一个 PING 命令。</li>
<li>如果一个实例(instance)距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 那么这个实例会被 Sentinel 标记为主观下线。 有效回复可以是： +PONG 、 -LOADING 或者 -MASTERDOWN 。</li>
<li>如果一个主服务器被标记为主观下线， 那么正在监视这个主服务器的所有Sentinel要以每秒一次的频率确认主服务器的确进入了主观下线状态。</li>
<li>如果一个主服务器被标记为主观下线， 并且有足够数量的Sentinel(至少要达到配置文件指定的数量)在指定的时间范围内同意这一判断， 那么这个主服务器被标记为客观下线。</li>
<li>在一般情况下， 每个Sentinel会以每 10 秒一次的频率向它已知的所有主服务器和从服务器发送 INFO 命令。 当一个主服务器被Sentinel标记为客观下线时，Sentinel向下线主服务器的所有从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</li>
<li>当没有足够数量的Sentinel同意主服务器已经下线， 主服务器的客观下线状态就会被移除。 当主服务器重新向Sentinel的 PING 命令返回有效回复时， 主服务器的主关下线状态就会被移除。</li>
</ul>
<p><img src="8.%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6_Redis//images/redis-cluster-sentinel.jpeg" alt="" /></p>
<h3 id="哨兵配置"><a class="header" href="#哨兵配置">哨兵配置</a></h3>
<p><strong>基本信息配置</strong></p>
<pre><code># 哨兵sentinel实例运行的端口，默认26379   
port 26379 
# 哨兵sentinel的工作目录 
dir ./
# 是否开启保护模式，默认开启。 
protected-mode:no 
# 是否设置为后台启动。 
daemonize:yes 
 
# 哨兵sentinel的日志文件 
logfile:./sentinel.log 
</code></pre>
<p><strong>哨兵配置</strong></p>
<ul>
<li>监控 的master结点</li>
<li>访问结点的密码</li>
<li>下线间隔</li>
<li>主备切换时 对新 master进行同步</li>
<li>故障转移的超时时间</li>
</ul>
<pre><code># 哨兵sentinel监控的redis主节点的  
## ip：主机ip地址 
## port：哨兵端口号 
## master-name：可以自己命名的主节点名字（只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。） 
## quorum：当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了   
# sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;   
sentinel monitor mymaster 127.0.0.1 6379 2 
 
# 当在Redis实例中开启了requirepass，所有连接Redis实例的客户端都要提供密码。 
# sentinel auth-pass &lt;master-name&gt; &lt;password&gt;   
sentinel auth-pass mymaster 123456   
 
# 指定主节点应答哨兵sentinel的最大时间间隔，超过这个时间，哨兵主观上认为主节点下线，默认30秒   
# sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt; 
sentinel down-after-milliseconds mymaster 30000   
 
# 指定了在发生failover主备切换时，最多可以有多少个slave同时对新的master进行同步。这个数字越小，完成failover所需的时间就越长；反之，但是如果这个数字越大，就意味着越多的slave因为replication而不可用。可以通过将这个值设为1，来保证每次只有一个slave，处于不能处理命令请求的状态。 
# sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt; 
sentinel parallel-syncs mymaster 1   
 
# 故障转移的超时时间failover-timeout，默认三分钟，可以用在以下这些方面： 
## 1. 同一个sentinel对同一个master两次failover之间的间隔时间。   
## 2. 当一个slave从一个错误的master那里同步数据时开始，直到slave被纠正为从正确的master那里同步数据时结束。   
## 3. 当想要取消一个正在进行的failover时所需要的时间。 
## 4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来同步数据了 
# sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;   
sentinel failover-timeout mymaster 180000 
 
# 当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本。一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。 
# 对于脚本的运行结果有以下规则：   
## 1. 若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10。 
## 2. 若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。   
## 3. 如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。 
# sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;   
sentinel notification-script mymaster /var/redis/notify.sh 
 
# 这个脚本应该是通用的，能被多次调用，不是针对性的。 
# sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt; 
sentinel client-reconfig-script mymaster /var/redis/reconfig.sh 
</code></pre>
<pre><code>redis-cli -p 26379 
info sentinel 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命令"><a class="header" href="#命令">命令</a></h1>
<h2 id="发布"><a class="header" href="#发布">发布</a></h2>
<pre><code class="language-shell">publish channel message
</code></pre>
<h2 id="订阅"><a class="header" href="#订阅">订阅</a></h2>
<pre><code>subscribe channel [channel ...]
</code></pre>
<p>使用订阅命令，需要主要几点：</p>
<ul>
<li>
<p>客户端执行订阅指令之后，就会进入订阅状态，之后就只能接收 <strong>subscribe</strong>、<strong>psubscribe</strong>、<strong>unsubscribe</strong>、<strong>punsubscribe</strong> 这四个命令。</p>
</li>
<li>
<p>第二，新订阅的客户端，是<strong>无法收到这个频道之前的消息</strong>，这是因为 Redis 并不会对发布的消息持久化的。</p>
</li>
</ul>
<h2 id="模式匹配的订阅方式"><a class="header" href="#模式匹配的订阅方式">模式匹配的订阅方式</a></h2>
<pre><code>psubscribe pay.*
punsubscribe pay.*
</code></pre>
<h1 id="基于-jedis-开发发布订阅"><a class="header" href="#基于-jedis-开发发布订阅">基于 Jedis 开发发布/订阅</a></h1>
<p><strong>发布</strong></p>
<pre><code class="language-java">HostAndPort hostAndPort1 = new HostAndPort(&quot;192.168.3.16&quot;,7000);
HostAndPort hostAndPort2 = new HostAndPort(&quot;192.168.3.16&quot;,7001);
HostAndPort hostAndPort3 = new HostAndPort(&quot;192.168.3.16&quot;,7002);
HostAndPort hostAndPort4 = new HostAndPort(&quot;192.168.3.16&quot;,7003);
HostAndPort hostAndPort5 = new HostAndPort(&quot;192.168.3.16&quot;,7004);
HostAndPort hostAndPort6 = new HostAndPort(&quot;192.168.3.16&quot;,7005);
HashSet&lt;HostAndPort&gt; objects = new HashSet&lt;&gt;();
objects.add(hostAndPort1);
objects.add(hostAndPort2);
objects.add(hostAndPort3);
objects.add(hostAndPort4);
objects.add(hostAndPort5);
objects.add(hostAndPort6);

JedisCluster jedisCluster = new JedisCluster(objects);

jedisCluster.publish(&quot;xjq&quot;,&quot;yes&quot;);
</code></pre>
<p><strong>订阅</strong></p>
<pre><code class="language-java">jedisCluster.subscribe(new JedisPubSub() {
    @Override
    public void onMessage(String channel, String message) {
        System.out.printf(&quot;I have rececive a message from %s,message is %s%n&quot;,channel,message);
    }
},&quot;xjq&quot;);
</code></pre>
<h1 id="redis-发布订阅实际应用"><a class="header" href="#redis-发布订阅实际应用">Redis 发布订阅实际应用</a></h1>
<h3 id="redis-sentinel-节点发现"><a class="header" href="#redis-sentinel-节点发现">Redis Sentinel 节点发现</a></h3>
<p><strong>Redis Sentinel</strong> 节点主要使用发布订阅机制，实现新节点的发现，以及交换主节点的之间的状态</p>
<p>如下所示，每一个 <strong>Sentinel</strong> 节点将会定时向 <code>_sentinel_:hello</code> 频道发送消息，并且每个 <strong>Sentinel</strong> 都会订阅这个节点。</p>
<p><img src="8.%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6_Redis//images/redis-sentinel-pub-sub.jpg" alt="" /></p>
<p>这样一旦有节点往这个频道发送消息，其他节点就可以立刻收到消息。</p>
<p>这样一旦有的新节点加入，它往这个频道发送消息，其他节点收到之后，判断本地列表并没有这个节点，于是就可以当做新的节点加入本地节点列表。</p>
<p>除此之外，每次往这个频道发送消息内容可以包含节点的状态信息，这样可以作为后面 <strong>Sentinel</strong> 领导者选举的依据。</p>
<p>以上都是对于 Redis 服务端来讲，对于客户端来讲，我们也可以用到发布订阅机制。</p>
<p>当 <strong>Redis Sentinel</strong> 进行主节点故障转移，这个过程各个阶段会通过发布订阅对外提供。</p>
<p>对于我们客户端来讲，比较关心切换之后的主节点，这样我们及时切换主节点的连接（旧节点此时已故障，不能再接受操作指令），</p>
<p>客户端可以订阅 <code>+switch-master</code>频道，一旦 <strong>Redis Sentinel</strong> 结束了对主节点的故障转移就会发布主节点的的消息。</p>
<h2 id="redission-分布式锁"><a class="header" href="#redission-分布式锁">redission 分布式锁</a></h2>
<p>就是采用服务通知的机制实现分布式锁的唤醒</p>
<p>当线程加锁失败之后，线程将会订阅 <code>redisson_lock__channel_xxx</code>（xx 代表锁的名称） 频道，使用异步线程监听消息，然后利用 Java 中 <code>Semaphore</code> 使当前线程进入阻塞</p>
<p>一旦其他客户端进行解锁，redission 就会往这个<code>redisson_lock__channel_xxx</code> 发送解锁消息。</p>
<p>等异步线程收到消息，将会调用 <code>Semaphore</code> 释放信号量，从而让当前被阻塞的线程唤醒去加锁</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概念-1"><a class="header" href="#概念-1"><strong>概念</strong></a></h1>
<h2 id="主从哨兵的局限性"><a class="header" href="#主从哨兵的局限性"><strong>主从+哨兵的局限性</strong></a></h2>
<p>之前介绍过Redis主从集群+哨兵的搭建，架构如下图所示</p>
<p><img src="8.%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6_Redis//images/redis-master-slaver-sentinel.jpg" alt="" /></p>
<p>这种集群模式下水平扩容和垂直扩容都可以实现，并且可以实现高可用性和易用性</p>
<ul>
<li>水平扩容：比如增加一套主从集群，在predixy代理处配置hash寻址，让部分数据可以被新加入的主从集群存储，水平扩容的实现强烈<strong>依赖于predixy代理</strong>。</li>
<li>垂直扩容：比如增加某个集群的内存，提升单机/单集群的处理能力</li>
<li>高可用性：一套哨兵集群监控多套redis主从集群，高可用的实现依赖于哨兵</li>
<li>易用性：指的是客户端的易用性，也是依赖于predixy代理来实现</li>
</ul>
<p><strong>但是此架构下还是有缺陷的：</strong></p>
<ul>
<li>水平扩容问题：水平扩容依赖于predixy实现既是优点也是缺点，因为predixy的实现是根据crc16计算key的哈希值，然后通过modula也就是求模的办法将key分布到不同的集群中去，所以说当水平扩容的时候会涉及到大量缓存重建</li>
<li>可用性问题：集群的高可用性是建立在哨兵集群之上的，假设哨兵集群全部宕机，那么整个集群的故障转移功能将会丧失，也不能动态发现新加入的集群，最终导致集群的可用性受到影响。</li>
</ul>
<p><strong>那么redis cluster又是怎么解决上面两个问题的呢？</strong></p>
<ul>
<li>针对水平扩容问题：redis使用hash槽算法，默认分配16384个hash槽位（2^14），然后将槽位均匀分配到不同的redis实例中去，找数据的时候通过crc16(key) % 16384找到对应的槽位，再看槽位在哪台实例上，最后去实例上取数据，使用槽位将具体的数据与redis实例解耦，当新增或者减少redis实例的时候自动将槽位均匀迁移到其他可用的redis实例上去。</li>
<li>针对可用性问题：redis使用流行病协议，即Gossip/ˈɡɒsɪp/ Protocol ，每台redis主机即使客户端也是服务端，随时都在向整个集群扩散自己的可用性状态，实际上就是基于P2P的 <strong>去中心化网络拓扑架构</strong>，没有中心节点，所有节点通过Gossip协议通信，所有节点既是数据存储节点，也是控制节点。</li>
</ul>
<p>下面就针对水平扩容问题的hash寻址算法和针对可用性问题的流行病协议详细讨论</p>
<h2 id="hash寻址算法"><a class="header" href="#hash寻址算法">hash寻址算法</a></h2>
<h3 id="普通hash"><a class="header" href="#普通hash">普通hash</a></h3>
<p>普通hash也就是最简单的hash算法，即</p>
<pre><code class="language-text">index = hash(key) % N
</code></pre>
<p>新增加了一个节点，那么所有key取模的结果都变了，导致所有的数据都要重新迁移一遍，如果节点下线了呢？那么毫无疑问所有数据都要还原回去，就redis而言，这就叫<strong>大量缓存的重建</strong>，那么有没有新增/删除节点影响不那么大的hash算法呢？答案肯定是有，下面轮到一致性hash出场。</p>
<h3 id="一致性hash"><a class="header" href="#一致性hash">一致性hash</a></h3>
<blockquote>
<p>一致哈希由MIT的Karger及其合作者提出，现在这一思想已经扩展到其它领域。在这篇1997年发表的学术论文中介绍了“一致哈希”如何应用于用户易变的分布式Web服务中。哈希表中的每一个代表分布式系统中一个节点，在系统添加或删除节点只需要移动K/n （方法K是总key的个数，n是节点个数）</p>
</blockquote>
<p>一致性hash的特性</p>
<ul>
<li><strong>平衡性</strong>：尽可能让数据尽可能分散到所有节点上，避免造成极其不均匀</li>
<li><strong>单调性</strong>：要求在新增或者减少节点的时候，原有的结果绝大部分不受影响，而新增的数据尽可能分配到新加的节点</li>
<li><strong>分散性</strong>：好的算法在不同终端，针对相同的数据的计算，得到的结果应该是一样的，一致性要很强</li>
<li><strong>负载</strong>：针对相同的节点，避免被不同终端映射不同的内容</li>
<li><strong>平滑性</strong>：对于增加节点或者减少节点，应该能够平滑过渡</li>
</ul>
<h3 id="hash环"><a class="header" href="#hash环">hash环</a></h3>
<p>普通hash算法导致大量数据迁移的根本原因是N的不确定性，有没有在N变化的时候影响范围更小的算法呢？有人提出了<strong>环</strong>的概念</p>
<p>hash环通过构建环状的hash空间代替线性hash空间的方法解决了上面的问题，假设将0~2^32-1的hash空间分布到一个环上</p>
<ul>
<li>节点加入环：将节点通过hash(节点的信息如ip端口等) % 2^32-1取节点在环上位置</li>
<li>数据读写：读写数据时同样取key的hash，即hash(key) % 2^32-1落到环上的某一位置，再<strong>顺时针</strong>找到离环最近的那个节点进行读写</li>
</ul>
<p><img src="8.%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6_Redis//images/redis-hash-cycle.jpg" alt="" /></p>
<p><strong>新增与删除</strong></p>
<p>新增一个节点4，只会影响到节点2到节点4之间的数据，其他的数据不会被影响到，这也是<strong>一致性</strong>的体现</p>
<p>删除一个节点也是同样的道理，假设删除节点4，也只是会影响到节点2到原节点4之间的数据</p>
<p><strong>缺点</strong></p>
<p>假设节点分布不均匀（hash算法并不能保证绝对的平衡性），那么大部分数据都会落在一个节点上，导致请求和数据倾斜，这样就不能很好的保证负载均衡。</p>
<p><img src="8.%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6_Redis//images/redis-hash-cycle-nonuniform.jpg" alt="" /></p>
<p>那么解决办法就是增加虚拟节点（注意，此时环上<strong>全部都是虚拟节点</strong>），对每一个节点计算多个hash，尽量保证环上的节点是均匀的，如下图</p>
<p><img src="8.%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6_Redis//images/redis-hash-cycle-uniform.jpg" alt="" /></p>
<h3 id="hash槽"><a class="header" href="#hash槽">hash槽</a></h3>
<p>hash槽（hash slot）<strong>是redis中一致性hash的实</strong>现，很多文章将一致性hash环和hash槽分开来讲，其实hash槽也是一致性hash的一种实现。</p>
<p>redis默认分配16384个hash槽位，然后将槽位均匀分配到不同的redis实例中去，找数据的时候通过CRC16算法计算后再取模找到对应的槽位（CRC16我们应该不陌生，这个winrar里面使用的CRC32是一样的，只是校验长度不一样而已），算法如下</p>
<pre><code>CRC16(key) % 16384
</code></pre>
<p><img src="8.%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6_Redis//images/redis-hash-slot-algorithm.jpg" alt="" /></p>
<p>使用槽位将具体的数据与redis实例解耦，当新增或者减少redis实例的时候用redis cluster总线通过Ping/Pong报文进行广播，告知整个redis集群新节点上线/下线，并迁移槽位和更新集群中的槽位映射表，整个过程尽量保证hash槽的平均分</p>
<p><strong>那么是基于什么样的考虑，redis的作者没有用hash环呢？</strong></p>
<p>redis的作者认为他的CRC16(key) mod 16384的效果已经不错了，虽然没有一致性hash灵活，但实现很简单，节点增删时处理起来也很方便</p>
<p>当然还有个原因是hash槽的分布更加均匀，如果有N个节点，那么每个节点都负载1/N，此处引用一句话总结</p>
<p><strong>那为什么hash槽是16384个呢？</strong></p>
<p><strong>分布均匀</strong></p>
<p>实际上是因为CRC16会输出16bit的结果，可以看作是一个分布在0~2^16-1之间的数，redis的作者测试发现这个数对2^14求模的会将key在0-2^14-1之间分布得很均匀，2^14即16384</p>
<p><strong>节省空间</strong></p>
<p>还有个说法是为了节省存储空间，每个节点用一个Bitmap来存放其对应的槽，2k = 2*1024*8 = 16384，也就是说，每个节点用2k的内存空间，总共16384个比特位，就可以存储该结点对应了哪些槽。然后这2k的信息，通过Gossip协议，在节点之间传递</p>
<h2 id="gossip协议流行病协议"><a class="header" href="#gossip协议流行病协议">Gossip协议(流行病协议)</a></h2>
<p>redis cluster正是通过Gossip协议在节点之间同步数据的，所有节点都是对等的，既是数据存储节点，也是控制节点。redis cluster启动的时候会开两个端口，一个是常规的6379端口，另外一个端口一般是（6379+ <strong>10000</strong>），这个就是所谓的Cluster总线，这个端口的作用就是就是利用Gossip协议进行节点之间的通信。</p>
<p>这里顺便提一下<strong>反熵</strong>（Anti-Entropy），熵描述的是一个系统的混乱程度，大名鼎鼎的<strong>熵增定律</strong>指的是一个有序系统在无外力的作用下，会慢慢转化到无序的状态，所谓反熵就是需要借助外力来减少系统的混乱程度，redis通过Gossip协议传播节点之间的可用信息，使得整个系统有序可用，是反熵行为，假设redis集群奉行无为而治，那么整个集群会随着各种不确定性（比如内存满了、网络抖动等）变得越来越无序，可用性降低，符合熵增定律。</p>
<h2 id="容错机制"><a class="header" href="#容错机制">容错机制</a></h2>
<h3 id="主观下线"><a class="header" href="#主观下线"><strong>主观下线</strong></a></h3>
<p>集群中每个节点都会定期向其他节点发送ping消息，接受节点回复ping消息作为响应。如果在cluster-node-timeout时间内通信一直失败，则发送节点会认为接收节点存在故障，把接受节点标记为主观下线(pfail)状态。</p>
<h3 id="客观下线"><a class="header" href="#客观下线"><strong>客观下线</strong></a></h3>
<ul>
<li>当某个节点判断另一个节点主观下线后，相应的节点状态会跟随消息在集群内传播</li>
<li>假设节点a标记节点b为主观下线，一段时间后节点a通过消息把节点b的状态发送到其他节点，当其他节点收到消息并解析出消息体中含有b的pfail状态，把节点b加入下线报告链表；</li>
<li>当某一节点c收到节点b的pfail状态时，此时有超过一半的槽主节点都标记了节点b为pfail状态时，则标记故障节点b为客观下线；</li>
<li>向集群广播一条pfail消息，通知集群内的所有节点标记故障节点b为客观下线状态并立刻生效，同时通知故障节点b的从节点触发故障转移流程</li>
</ul>
<h3 id="故障恢复"><a class="header" href="#故障恢复"><strong>故障恢复</strong></a></h3>
<p><strong>资格检查</strong></p>
<p>若从节点与主节点断线时间超过一定时间，则不具备资格</p>
<p><strong>准备选举时间</strong></p>
<p>当从节点符合故障转移资格后，要等待一段选举时间后才开始选举</p>
<p>在故障节点的所有从节点中，复制偏移量最大的那个从节点最先开始（与主节点的数据最一致）进行选举，然后是次大的节点开始选举.....剩下其余的从节点等待到它们的选举时间到达后再进行选举</p>
<p><strong>发起选举</strong></p>
<p><strong>选举投票</strong></p>
<p>只有持有槽的主节点才具有一张唯一的选票，从从节点收集到N/2 + 1个持有槽的主节点投票时，从节点可以执行替换主节点操作</p>
<p><strong>替换主节点</strong></p>
<p>当从节点收集到足够的选票之后，触发替换主节点操作</p>
<ul>
<li>当前从节点取消复制变为主节点</li>
<li>撤销故障主节点负责的槽，并把这些槽委派给自己</li>
<li>向集群广播自己的pong消息，通知集群内所有的节点当前从节点变为主节点并接管了故障主节点的槽信息</li>
</ul>
<h1 id="redis-cluster集群"><a class="header" href="#redis-cluster集群">Redis Cluster集群</a></h1>
<h2 id="概念-2"><a class="header" href="#概念-2">概念</a></h2>
<ul>
<li>
<p>Redis 集群是一个提供在<strong>多个Redis间节点间共享数据</strong>的程序集。</p>
</li>
<li>
<p>Redis集群并不支持处理多个keys的命令,因为这需要在不同的节点间移动数据,从而达不到像Redis那样的性能,在高负载的情况下可能会导致不可预料的错误.</p>
</li>
<li>
<p>Redis 集群通过分区来提供<strong>一定程度的可用性</strong>,在实际环境中当某个节点宕机或者不可达的情况下继续处理命令. Redis 集群的优势:</p>
<ul>
<li>自动分割数据到不同的节点上。</li>
<li>整个集群的部分节点失败或者不可达的情况下能够继续处理命令。</li>
</ul>
</li>
</ul>
<h2 id="redis-集群的数据分片"><a class="header" href="#redis-集群的数据分片">Redis 集群的数据分片</a></h2>
<p>Redis 集群没有使用一致性hash, 而是引入了 <strong>哈希槽</strong>的概念.</p>
<p>Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽,举个例子,比如当前集群有3个节点,那么:</p>
<ul>
<li>节点 A 包含 0 到 5500号哈希槽.</li>
<li>节点 B 包含5501 到 11000 号哈希槽.</li>
<li>节点 C 包含11001 到 16384号哈希槽.</li>
</ul>
<p>这种结构很容易添加或者删除节点. 比如如果我想新添加个节点D, 我需要从节点 A, B, C中得部分槽到D上. 如果我想移除节点A,需要将A中的槽移到B和C节点上,然后将没有任何槽的A节点从集群中移除即可. 由于从一个节点将哈希槽移动到另一个节点并不会停止服务,所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态.</p>
<h2 id="redis-集群的主从复制模型"><a class="header" href="#redis-集群的主从复制模型">Redis 集群的主从复制模型</a></h2>
<p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品.</p>
<p>在我们例子中具有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用.</p>
<p>然而如果在集群创建的时候（或者过一段时间）我们为每个节点添加一个从节点A1，B1，C1,那么整个集群便有三个master节点和三个slave节点组成，这样在节点B失败后，集群便会选举B1为新的主节点继续服务，整个集群便不会因为槽找不到而不可用了</p>
<p>不过当B和B1 都失败后，集群是不可用的.</p>
<h2 id="redis-一致性保证"><a class="header" href="#redis-一致性保证">Redis 一致性保证</a></h2>
<h3 id="不保证强一致性"><a class="header" href="#不保证强一致性">不保证强一致性</a></h3>
<p><strong>异步复制</strong></p>
<p>Redis 并不能保证数据的<strong>强一致性</strong>. 这意味这在实际中集群在特定的条件下可能会丢失写操作.</p>
<p>第一个原因是因为集群是用了异步复制. 写操作过程:</p>
<ul>
<li>客户端向主节点B写入一条命令.</li>
<li>主节点B向客户端回复命令状态.</li>
<li>主节点将写操作复制给他得从节点 B1, B2 和 B3.</li>
</ul>
<p><strong>性能与一致性的权衡</strong></p>
<p>主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。 注意：Redis 集群可能会在将来提供同步写的方法。 </p>
<p><strong>网络分裂导致非一致性</strong></p>
<p>Redis 集群另外一种可能会丢失命令的情况是集群出现了网络分区， 并且一个客户端与至少包括一个主节点在内的少数实例被孤立。</p>
<p>举个例子 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点， 其中 A 、B 、C 为主节点， A1 、B1 、C1 为A，B，C的从节点， 还有一个客户端 Z1 假设集群中发生网络分区，那么集群可能会分为两方，大部分的一方包含节点 A 、C 、A1 、B1 和 C1 ，小部分的一方则包含节点 B 和客户端 Z1 .</p>
<p>Z1仍然能够向主节点B中写入, 如果网络分区发生时间较短,那么集群将会继续正常运作,如果分区的时间足够让大部分的一方将B1选举为新的master，那么Z1写入B中得数据便丢失了.</p>
<p>注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项：</p>
<h2 id="集群原理"><a class="header" href="#集群原理">集群原理</a></h2>
<h3 id="键分布模型"><a class="header" href="#键分布模型">键分布模型</a></h3>
<p>键空间被分割为 16384 槽（slot），事实上集群的最大节点数量是 16384 个。（然而建议最大节点数量设置在1000这个数量级上）</p>
<p>所有的主节点都负责 16384 个哈希槽中的一部分。当集群处于稳定状态时，集群中没有在执行重配置（reconfiguration）操作，每个哈希槽都只由一个节点进行处理（不过主节点可以有一个或多个从节点，可以在网络断线或节点失效时替换掉主节点）。</p>
<p>以下是用来把键映射到哈希槽的算法（下一段哈希标签例外就是按照这个规则）：</p>
<h3 id="键哈希标签keys-hash-tags"><a class="header" href="#键哈希标签keys-hash-tags">键哈希标签（Keys hash tags）</a></h3>
<p><strong>设置hash标签确保同一个slot</strong></p>
<p>哈希标签是确保两个键都在同一个哈希槽里的一种方式</p>
<p>为了实现哈希标签，哈希槽是用另一种不同的方式计算的。基本来说，如果一个键包含一个 “{…}” 这样的模式，只有 { 和 } 之间的字符串会被用来做哈希以获取哈希槽。但是由于可能出现多个 { 或 }，计算的算法如下：</p>
<ul>
<li>如果键包含一个 { 字符。</li>
<li>那么在 { 的右边就会有一个 }。</li>
<li>在 { 和 } 之间会有一个或多个字符，第一个 } 一定是出现在第一个 { 之后。</li>
</ul>
<p>然后不是直接计算键的哈希，只有在第一个 { 和它右边第一个 } 之间的内容会被用来计算哈希值。</p>
<p>例子：</p>
<ul>
<li>比如这两个键 {user1000}.following 和 {user1000}.followers 会被哈希到同一个哈希槽里，因为只有 user1000 这个子串会被用来计算哈希值。</li>
<li>对于 foo{}{bar} 这个键，整个键都会被用来计算哈希值，因为第一个出现的 { 和它右边第一个出现的 } 之间没有任何字符。</li>
</ul>
<pre><code class="language-ruby">def HASH_SLOT(key)
    s = key.index &quot;{&quot;
    if s
        e = key.index &quot;}&quot;,s+1
        if e &amp;&amp; e != s+1
            key = key[s+1..e-1]
        end
    end
    crc16(key) % 16384
end
</code></pre>
<h3 id="集群节点属性"><a class="header" href="#集群节点属性">集群节点属性</a></h3>
<h3 id="固定唯一id"><a class="header" href="#固定唯一id">固定唯一ID</a></h3>
<p>在集群中，每个节点都有一个唯一的名字。节点名字是一个十六进制表示的160 bit 随机数，这个随机数是节点第一次启动时获得的（通常是用 /dev/urandom）。 节点会把它的ID保存在配置文件里，以后永远使用这个ID，只要这个节点配置文件没有被系统管理员删除掉。</p>
<p>节点ID是用于在整个集群中标识每个节点。一个给定的节点可以在不改变节点ID的情况下改变 IP 和地址。集群能检测到 IP 或端口的变化，然后使用在集群连接（cluster bus）上的 gossip 协议来发布广播消息，通知配置变更。</p>
<p>每个节点都有其他相关信息是所有节点都知道的：</p>
<ul>
<li>节点的 IP 地址和 TCP 端口号。</li>
<li>各种标识。</li>
<li>节点使用的哈希槽。</li>
<li>最近一次用集群连接发送 ping 包的时间。</li>
<li>最近一次在回复中收到一个 pong 包的时间。</li>
<li>最近一次标识节点失效的时间。</li>
<li>该节点的从节点个数。</li>
<li>如果该节点是从节点，会有主节点ID信息。（如果它是个主节点则该信息置为0000000…）</li>
</ul>
<p>使用 CLUSTER NODES 命令可以获得以上的一些信息，这个命令可以发送到集群中的所有节点，无论主节点还是从节点</p>
<pre><code>redis-cli cluster nodes

d1861060fe6a534d42d8a19aeb36600e18785e04 127.0.0.1:6379 myself - 0 1318428930 1 connected 0-1364
3886e65cc906bfd9b1f7e7bde468726a052d1dae 127.0.0.1:6380 master - 1318428930 1318428931 2 connected 1365-2729
d289c575dcbc4bdd2931585fd4339089e461a27d 127.0.0.1:6381 master - 1318428931 1318428931 3 connected 2730-4095
各个域依次表示的是：节点ID，IP地址：端口号，标识，上一次发送 ping 包的时间，上一次收到 pong 包的时间，连接状态，节点使用的哈希槽。
</code></pre>
<h3 id="集群拓扑结构"><a class="header" href="#集群拓扑结构">集群拓扑结构</a></h3>
<p>Redis 集群是一个网状结构，每个节点都通过 TCP 连接跟其他每个节点连接。</p>
<p>在一个有 N 个节点的集群中，每个节点都有 N-1 个流出的 TCP 连接，和 N-1 个流入的连接。 这些 TCP 连接会永久保持，并不是按需创建的。</p>
<h3 id="节点握手"><a class="header" href="#节点握手">节点握手</a></h3>
<p>节点总是在集群连接端口接受连接，甚至会回复接收到的 ping 包，即使发送 ping 包的节点是不可信的。 然而如果某个节点不被认为是在集群中，那么所有它发出的数据包都会被丢弃掉。</p>
<p>只有在两种方式下，一个节点才会认为另一个节点是集群中的一部分：</p>
<ul>
<li>
<p>当一个节点使用 MEET 消息介绍自己。一个 meet 消息跟一个 PING 消息完全一样，但它会强制让接收者接受发送者为集群中的一部分。 只有在系统管理员使用以下命令要求的时候，节点才会发送 MEET 消息给其他节点：</p>
<pre><code>CLUSTER MEET ip port
</code></pre>
</li>
</ul>
<ul>
<li>
<p>一个已被信任的节点能通过传播gossip消息让另一个节点被注册为集群中的一部分</p>
<p>如果 A 知道 B，B 知道 C，那么 B 会向 A 发送 C 的gossip消息。A 收到后就会把 C 当作是网络中的一部分，并且尝试连接 C</p>
<p>从根本上来说，这表示集群能自动发现其他节点，但前提是有一个由系统管理员强制创建的信任关系</p>
</li>
</ul>
<h3 id="moved-重定向"><a class="header" href="#moved-重定向">MOVED 重定向</a></h3>
<p>一个 Redis 客户端可以自由地向集群中的任意节点（包括从节点）发送查询。接收的节点会分析查询，如果这个命令是集群可以执行的（就是查询中只涉及一个键），那么节点会找这个键所属的哈希槽对应的节点。</p>
<p>如果刚好这个节点就是对应这个哈希槽，那么这个查询就直接被节点处理掉。否则这个节点会查看它内部的 哈希槽 -&gt; 节点ID 映射，然后给客户端返回一个 MOVED 错误。</p>
<pre><code>GET x
-MOVED 3999 127.0.0.1:6381
</code></pre>
<p>当集群是稳定的时候，所有客户端最终都会得到一份哈希槽 -&gt; 节点的映射表，这样能使得集群效率非常高：客户端直接定位目标节点，不用重定向、或代理或发生其他单点故障（single point of failure entities）。</p>
<p>一个客户端也应该能处理本文后面将提到的 -ASK 重定向错误。</p>
<h3 id="集群在线重配置live-reconfiguration"><a class="header" href="#集群在线重配置live-reconfiguration">集群在线重配置（live reconfiguration）</a></h3>
<p>Redis 集群支持在集群运行过程中添加或移除节点。实际上，添加或移除节点都被抽象为同一个操作，那就是把哈希槽从一个节点移到另一个节点。</p>
<ul>
<li>向集群添加一个新节点，就是把一个空节点加入到集群中并把某些哈希槽从已存在的节点移到新节点上。</li>
<li>从集群中移除一个节点，就是把该节点上的哈希槽移到其他已存在的节点上。</li>
<li>所以实现这个的核心是能把哈希槽移来移去。从实际角度看，哈希槽就只是一堆键，所以 Redis 集群在重组碎片（reshard）时做的就是把键从一个节点移到另一个节点。</li>
</ul>
<p>CLUSTER 的子命令，这些命令是用来操作 Redis 集群节点上的哈希槽转换表（slots translation table）。</p>
<ul>
<li>
<p><code>CLUSTER ADDSLOTS</code> slot1 [slot2] … [slotN]</p>
</li>
<li>
<p><code>CLUSTER DELSLOTS</code> slot1 [slot2] … [slotN]</p>
</li>
<li>
<p><code>CLUSTER SETSLOT</code> slot NODE node</p>
</li>
<li>
<p><code>CLUSTER SETSLOT</code> slot MIGRATING node</p>
</li>
<li>
<p><code>CLUSTER SETSLOT</code> slot IMPORTING node</p>
</li>
<li>
<p>头两个命令，ADDSLOTS 和 DELSLOTS，就是简单地用来给一个 Redis 节点指派（assign）或移除哈希槽。 在哈希槽被指派后，节点会将这个消息通过 gossip 协议向整个集群传播。ADDSLOTS 命令通常是用于在一个集群刚建立的时候快速给所有节点指派哈希槽。</p>
</li>
<li>
<p>当 SETSLOT 子命令使用 NODE 形式的时候，用来给指定 ID 的节点指派哈希槽。 除此之外哈希槽能通过两个特殊的状态来设定，MIGRATING 和 IMPORTING：</p>
<ul>
<li>当一个槽被设置为 MIGRATING，原来持有该哈希槽的节点仍会接受所有跟这个哈希槽有关的请求，但只有当查询的键还存在原节点时，原节点会处理该请求，否则这个查询会通过一个 -ASK 重定向（-ASK redirection）转发到迁移的目标节点。</li>
<li>当一个槽被设置为 IMPORTING，只有在接受到 ASKING 命令之后节点才会接受所有查询这个哈希槽的请求。如果客户端一直没有发送 ASKING 命令，那么查询都会通过 -MOVED 重定向错误转发到真正处理这个哈希槽的节点那里。</li>
</ul>
</li>
</ul>
<p>假设我们有两个 Redis 节点，称为 A 和 B。我们想要把哈希槽 8 从 节点A 移到 节点B，所以我们发送了这样的命令：</p>
<ul>
<li>我们向 节点B 发送：CLUSTER SETSLOT 8 IMPORTING A</li>
<li>我们向 节点A 发送：CLUSTER SETSLOT 8 MIGRATING B</li>
</ul>
<p>其他所有节点在每次被询问到的一个键是属于哈希槽 8 的时候，都会把客户端引向节点”A”。具体如下：</p>
<ul>
<li>所有关于已存在的键的查询都由节点”A”处理。</li>
<li>所有关于不存在于节点 A 的键都由节点”B”处理。</li>
</ul>
<h3 id="ask-重定向"><a class="header" href="#ask-重定向">ASK 重定向</a></h3>
<p>为什么我们不能单纯地使用 MOVED 重定向呢？因为当我们使用 MOVED 的时候，意味着我们认为哈希槽永久地被另一个不同的节点处理，并且希望接下来的所有查询都尝试发到这个指定的节点上去。</p>
<p>而 ASK 意味着我们只要<strong>下一个查询发送到指定节点上去。</strong></p>
<p>这个命令是必要的，因为下一个关于哈希槽 8 的查询需要的键或许还在节点 A 中，所以我们希望客户端尝试在节点 A 中查找，如果需要的话也在节点 B 中查找。 由于这是发生在 16384 个槽的其中一个槽，所以对于集群的性能影响是在可接受的范围。</p>
<p>然而我们需要强制客户端的行为，以确保客户端会在尝试 A 中查找后去尝试在 B 中查找。如果客户端在发送查询前发送了 ASKING 命令，那么节点 B 只会接受被设为 IMPORTING 的槽的查询。 本质上来说，ASKING 命令在客户端设置了一个一次性标识（one-time flag），强制一个节点可以执行一次关于带有 IMPORTING 状态的槽的查询。</p>
<p>所以从客户端看来，ASK 重定向的完整语义如下：</p>
<ul>
<li>如果接受到 ASK 重定向，那么把查询的对象调整为指定的节点。</li>
<li>先发送 ASKING 命令，再开始发送查询。</li>
<li>现在不要更新本地客户端的映射表把哈希槽 8 映射到节点 B。</li>
</ul>
<p>一旦完成了哈希槽 8 的转移，节点 A 会发送一个 MOVED 消息，客户端也许会永久地把哈希槽 8 映射到新的 ip:端口号 上。</p>
<h3 id="失效检测failure-detection"><a class="header" href="#失效检测failure-detection">失效检测（Failure detection）</a></h3>
<p><strong>大部分失效</strong></p>
<p>Redis 集群失效检测是用来识别出大多数节点何时无法访问某一个主节点或从节点。当这个事件发生时，就提升一个从节点来做主节点；若如果无法提升从节点来做主节点的话，那么整个集群就置为错误状态并停止接收客户端的查询。</p>
<p>每个节点都有一份跟其他已知节点相关的标识列表。其中有两个标识是用于失效检测，分别是 PFAIL 和 FAIL。*</p>
<ul>
<li>PFAIL 表示可能失效（Possible failure），这是一个非公认的（non acknowledged）失效类型。</li>
<li>FAIL 表示一个节点已经失效，而且这个情况已经被大多数主节点在某段固定时间内确认过的了。</li>
</ul>
<p><strong>PFAIL 标识:</strong></p>
<p>当一个节点在超过 NODE_TIMEOUT 时间后仍无法访问某个节点，那么它会用 PFAIL 来标识这个不可达的节点。无论节点类型是什么，主节点和从节点都能标识其他的节点为 PFAIL。</p>
<p>Redis 集群节点的不可达性（non reachability）是指，发送给某个节点的一个活跃的 ping 包（active ping）(一个我们发送后要等待其回复的 ping 包)已经等待了超过 NODE_TIMEOUT 时间，那么我们认为这个节点具有不可达性。为了让这个机制能正常工作，NODE_TIMEOUT 必须比网络往返时间（network round trip time）大。</p>
<p>节点为了在普通操作中增加可达性，当在经过一半 NODE_TIMEOUT 时间还没收到目标节点对于 ping 包的回复的时候，就会马上尝试重连接该节点。这个机制能保证连接都保持有效，所以节点间的失效连接通常都不会导致错误的失效报告。</p>
<p><strong>FAIL 标识:</strong></p>
<p>单独一个 PFAIL 标识只是每个节点的一些关于其他节点的本地信息，它不是为了起作用而使用的，也不足够触发从节点的提升。要让一个节点真正被认为失效了，那需要让 PFAIL 状态上升为 FAIL 状态。 </p>
<p>每个节点向其他每个节点发送的 gossip 消息中有包含一些随机的已知节点的状态。最终每个节点都能收到一份其他每个节点的节点标识。使用这种方法，每个节点都有一套机制去标记他们检查到的关于其他节点的失效状态。</p>
<p>当下面的条件满足的时候，会使用这个机制来让 PFAIL 状态升级为 FAIL 状态：</p>
<ul>
<li>某个节点，我们称为节点 A，标记另一个节点 B 为 PFAIL。</li>
<li>节点 A 通过 gossip 字段收集到集群中大部分主节点标识的节点 B 的状态信息。</li>
<li>大部分主节点标记节点 B 为 PFAIL 状态，或者在 NODE_TIMEOUT * FAIL_REPORT_VALIDITY_MULT 这个时间内是处于 PFAIL 状态。</li>
</ul>
<p>如果以上所有条件都满足了，那么节点 A 会：</p>
<ul>
<li>标记节点 B 为 FAIL。</li>
<li>向所有可达节点发送一个 FAIL 消息。</li>
</ul>
<p>FAIL 消息会强制每个接收到这消息的节点把节点 B 标记为 FAIL 状态。</p>
<p>注意，FAIL 标识基本都是单向的，也就是说，一个节点能从 PFAIL 状态升级到 FAIL 状态，但要清除 FAIL 标识只有以下两种可能方法：</p>
<ul>
<li>节点已经恢复可达的，并且它是一个从节点。在这种情况下，FAIL 标识可以清除掉，因为从节点并没有被故障转移。</li>
<li>节点已经恢复可达的，而且它是一个主节点，但经过了很长时间（N * NODE_TIMEOUT）后也没有检测到任何从节点被提升了。</li>
</ul>
<p><strong>PFAIL -&gt; FAIL 的转变使用一种弱协议（agreement）：</strong></p>
<ul>
<li>节点是在一段时间内收集其他节点的信息，所以即使大多数主节点要去”同意”标记某节点为 FAIL，实际上这只是表明说我们在不同时间里从不同节点收集了信息，得出当前的状态不一定是稳定的结论</li>
<li>当每个节点检测到 FAIL 节点的时候会强迫集群里的其他节点把各自对该节点的记录更新为 FAIL，但没有一种方式能保证这个消息能到达所有节点。比如有个节点可能检测到了 FAIL 的节点，但是因为分区，这个节点无法到达其他任何一个节点。</li>
</ul>
<p>然而 Redis 集群的失效检测有一个要求：最终所有节点都应该同意给定节点的状态是 FAIL，哪怕它处于分区。有两种情况是来源于脑裂情况（？），或者是小部分节点相信该节点处于 FAIL 状态，或者是相信节点不处于 FAIL 状态。在这两种情况中，最后集群都会认为给定的节点只有一个状态：</p>
<p>**第 1 种情况: **如果大多数节点都标记了某个节点为 FAIL，由于链条反应，这个主节点最终会被标记为 FAIL。</p>
<p><strong>第 2 种情况:</strong> 当只有小部分的主节点标记某个节点为 FAIL 的时候，从节点的提升并不会发生（它是使用一个更正式的算法来保证每个节点最终都会知道节点的提升。），并且每个节点都会根据上面的清除规则（在经过了一段时间 &gt; N * NODE_TIMEOUT 后仍没有从节点提升操作）来清除 FAIL 状态。</p>
<p><strong>本质上来说，FAIL 标识只是用来触发从节点提升（slave promotion）算法的安全部分</strong></p>
<p>理论上一个从节点会在它的主节点不可达的时候独立起作用并且启动从节点提升程序，然后等待主节点来拒绝认可该提升（如果主节点对大部分节点恢复连接）。PFAIL -&gt; FAIL 的状态变化、弱协议、强制在集群的可达部分用最短的时间传播状态变更的 FAIL 消息，这些东西增加的复杂性有实际的好处。由于这种机制，如果集群处于错误状态的时候，所有节点都会在同一时间停止接收写入操作，这从使用 Redis 集群的应用的角度来看是个很好的特性。还有非必要的选举，是从节点在无法访问主节点的时候发起的，若该主节点能被其他大多数主节点访问的话，这个选举会被拒绝掉。</p>
<h3 id="集群阶段cluster-epoch"><a class="header" href="#集群阶段cluster-epoch">集群阶段（Cluster epoch）</a></h3>
<p>Redis 集群使用一个类似于木筏算法（Raft algorithm）”术语”的概念。在 Redis 集群中这个术语叫做 阶段（epoch），它是用来记录事件的版本号，所以当有多个节点提供了冲突的信息的时候，另外的节点就可以通过这个状态来了解哪个是最新的。 currentEpoch 是一个 64bit 的 unsigned 数。</p>
<p>Redis 集群中的每个节点，包括主节点和从节点，都在创建的时候设置了 currentEpoch 为0。</p>
<p>当节点接收到来自其他节点的 ping 包或 pong 包的时候，如果发送者的 epoch（集群连接消息头部的一部分）大于该节点的 epoch，那么更新发送者的 epoch 为 currentEpoch。</p>
<p>由于这个语义，最终所有节点都会支持集群中较大的 epoch。</p>
<p>这个信息在此处是用于，当一个节点的状态发生改变的时候为了执行一些动作寻求其他节点的同意（agreement）。</p>
<p>目前这个只发生在从节点的提升过程，这个将在下一节中详述。本质上说，epoch 是一个集群里的逻辑时钟，并决定一个给定的消息赢了另一个带着更小 epoch 的消息。</p>
<h3 id="配置阶段configuration-epoch"><a class="header" href="#配置阶段configuration-epoch">配置阶段（Configuration epoch）</a></h3>
<p>每一个主节点总是通过发送 ping 包和 pong 包向别人宣传它的 configEpoch 和一份表示它负责的哈希槽的位图。</p>
<p>当一个新节点被创建的时候，主节点中的 configEpoch 设为零。</p>
<p>从节点由于故障转移事件被提升为主节点时，为了取代它那失效的主节点，会把 configEpoch 设置为它赢得选举的时候的 configEpoch 值。</p>
<p>configEpoch 用于在不同节点提出不同的配置信息的时候（这种情况或许会在分区之后发生）解决冲突</p>
<p>从节点也会在 ping 包和 pong 包中向别人宣传它的 configEpoch 域，不过从节点的这个域表示的是上一次跟它的主节点交换数据的时候主节点的 configEpoch 值。这能让其他个体检测出从节点的配置信息是不是需要更新了（主节点不会给一个配置信息过时的从节点投票）。</p>
<p>每次由于一些已知节点的值比自己的值大而更新 configEpoch 值，它都会永久性地存储在 nodes.conf 文件中。</p>
<p>当一个节点重启，它的 configEpoch 值被设为所有已知节点中最大的那个 configEpoch 值。</p>
<h3 id="丛节点的选举和提升"><a class="header" href="#丛节点的选举和提升">丛节点的选举和提升</a></h3>
<p>从节点的选举和提升都是由从节点处理的，主节点会投票要提升哪个从节点。一个从节点的选举是在主节点被至少一个具有成为主节点必备条件的从节点标记为 FAIL 的状态的时候发生的。</p>
<p>当以下条件满足时，一个从节点可以发起选举：</p>
<ul>
<li>该从节点的主节点处于 FAIL 状态。</li>
<li>这个主节点负责的哈希槽数目不为零。</li>
<li>从节点和主节点之间的重复连接（replication link）断线不超过一段给定的时间，这是为了确保从节点的数据是可靠的。</li>
<li>一个从节点想要被推选出来，那么第一步应该是提高它的 currentEpoch 计数，并且向主节点们请求投票。</li>
</ul>
<p>从节点通过广播一个 FAILOVER_AUTH_REQUEST 数据包给集群里的每个主节点来请求选票。然后等待回复（最多等 NODE_TIMEOUT 这么长时间）。一旦一个主节点给这个从节点投票，会回复一个 FAILOVER_AUTH_ACK，并且在 NODE_TIMEOUT * 2 这段时间内不能再给同个主节点的其他从节点投票。在这段时间内它完全不能回复其他授权请求。</p>
<p>从节点会忽视所有带有的时期（epoch）参数比 currentEpoch 小的回应（ACKs），这样能避免把之前的投票的算为当前的合理投票。</p>
<p>一旦某个从节点收到了大多数主节点的回应，那么它就赢得了选举。否则，如果无法在 NODE_TIMEOUT 时间内访问到大多数主节点，那么当前选举会被中断并在 NODE_TIMEOUT * 4 这段时间后由另一个从节点尝试发起选举。</p>
<p>从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一点点延迟，这段延迟是这么计算的：</p>
<pre><code>DELAY = 500 milliseconds + random delay between 0 and 500 milliseconds +
        SLAVE_RANK * 1000 milliseconds.
</code></pre>
<p>固定延时（fixed delay）确保我们会等到 FAIL 状态在集群内广播后，否则若从节点尝试发起选举，主节点们仍然不知道那个主节点已经 FAIL，就会拒绝投票。</p>
<p>一旦有从节点赢得选举，它就会开始用 ping 和 pong 数据包向其他节点宣布自己已经是主节点，并提供它负责的哈希槽，设置 configEpoch 为 currentEpoch（选举开始时生成的）。</p>
<p>为了加速其他节点的重新配置，该节点会广播一个 pong 包 给集群里的所有节点（那些现在访问不到的节点最终也会收到一个 ping 包或 pong 包，并且进行重新配置）。</p>
<p>其他节点会检测到有一个新的主节点（带着更大的configEpoch）在负责处理之前一个旧的主节点负责的哈希槽，然后就升级自己的配置信息。 旧主节点的从节点，或者是经过故障转移后重新加入集群的该旧主节点，不仅会升级配置信息，还会配置新主节点的备份。</p>
<h3 id="主节点回复从节点的投票请求"><a class="header" href="#主节点回复从节点的投票请求">主节点回复从节点的投票请求</a></h3>
<p>主节点接收到来自于从节点、要求以 FAILOVER_AUTH_REQUEST 请求的形式投票的请求。 要授予一个投票，必须要满足以下条件：</p>
<ul>
<li>在一个给定的时段（epoch）里，一个主节点只能投一次票，并且拒绝给以前时段投票：每个主节点都有一个 lastVoteEpoch 域，一旦认证请求数据包（auth request packet）里的 currentEpoch 小于 lastVoteEpoch，那么主节点就会拒绝再次投票。当一个主节点积极响应一个投票请求，那么 lastVoteEpoch 会相应地进行更新。</li>
<li>一个主节点投票给某个从节点当且仅当该从节点的主节点被标记为 FAIL。</li>
<li>如果认证请求里的 currentEpoch 小于主节点里的 currentEpoch 的话，那么该请求会被忽视掉。因此，主节点的回应总是带着和认证请求一致的 currentEpoch。如果同一个从节点在增加 currentEpoch 后再次请求投票，那么保证一个来自于主节点的、旧的延迟回复不会被新一轮选举接受。</li>
</ul>
<p>主节点的 currentEpoch 是 5， lastVoteEpoch 是 1（在几次失败的选举后这也许会发生的）</p>
<ul>
<li>从节点的 currentEpoch 是 3。</li>
<li>从节点尝试用 epoch 值为 4（3+1）来赢得选票，主节点回复 ok，里面的 currentEpoch 是 5，可是这个回复延迟了。</li>
<li>从节点尝试用 epoch 值为 5（4+1）来再次赢得选票，收到的是带着 currentEpoch 值为 5 的延迟回复，这个回复会被当作有效的来接收。</li>
<li>
<ol start="4">
<li>主节点若已经为某个失效主节点的一个从节点投票后，在经过 NODE_TIMEOUT * 2 时间之前不会为同个失效主节点的另一个从节点投票。这并不是严格要求的，因为两个从节点用同个 epoch 来赢得选举的可能性很低，不过在实际中，系统确保正常情况当一个从节点被选举上，那么它有足够的时间来通知其他从节点，以避免另一个从节点发起另一个新的选举。</li>
</ol>
</li>
<li>
<ol start="5">
<li>主节点不会用任何方式来尝试选出最好的从节点，只要从节点的主节点处于 FAIL 状态并且投票主节点在这一轮中还没投票，主节点就能进行积极投票。</li>
</ol>
</li>
<li>
<ol start="6">
<li>若一个主节点拒绝为给定从节点投票，它不会给任何负面的回应，只是单纯忽略掉这个投票请求。</li>
</ol>
</li>
<li>
<ol start="7">
<li>主节点不会授予投票给那些 configEpoch 值比主节点哈希槽表里的 configEpoch 更小的从节点。记住，从节点发送了它的主节点的 configEpoch 值，还有它的主节点负责的哈希槽对应的位图。本质上来说，这意味着，请求投票的从节点必须拥有它想要进行故障转移的哈希槽的配置信息，而且信息应该比它请求投票的主节点的配置信息更新或者一致。</li>
</ol>
</li>
</ul>
<h3 id="从节点选举的竞争情况"><a class="header" href="#从节点选举的竞争情况">从节点选举的竞争情况</a></h3>
<p>这一节解释如何使用 epoch 概念来使得从节点提升过程对分区操作更有抵抗力。</p>
<ul>
<li>主节点不是无限期地可达。它拥有三个从节点 A，B，C。</li>
<li>从节点 A 赢得了选举并且被推选为主节点。</li>
<li>一个分区操作使得集群中的大多数节点无法访问节点 A。</li>
<li>节点 B 赢得了选举并且被推选为主节点。</li>
<li>一个分区操作使得集群中大多数节点无法访问节点 B。</li>
<li>之前分区操作的问题被修复了，节点 A 又恢复可访问状态。</li>
</ul>
<p>此刻，节点 B 仍然失效，节点 A 恢复可访问，会与节点 C 竞选去获得选票对节点 B 进行故障转移。</p>
<p>这两个有同样的哈希槽的从节点最终都会请求被提升，然而由于它们发布的 configEpoch 是不一样的，而且节点 C 的 epoch 比较大，所以所有的节点都会把它们的配置更新为节点 C 的。</p>
<p>节点 A 会从来源于节点 C（负责同样哈希槽的节点）的 ping 包中检测出节点 C 的 epoch 是更大的，所以它会重新设置自己为节点 C 的一个从节点。</p>
<h3 id="服务器哈希槽信息的传播规则"><a class="header" href="#服务器哈希槽信息的传播规则">服务器哈希槽信息的传播规则</a></h3>
<p>Redis 集群很重要的一个部分是用来传播关于集群节点负责哪些哈希槽的信息的机制。这对于新集群的启动和提升从节点来负责处理哈希槽（它那失效的主节点本该处理的槽）的能力来说是必不可少的。</p>
<p>个体持续交流使用的 ping 包和 pong 包都包含着一个头部，这个头部是给发送者使用的，为了向别的节点宣传它负责的哈希槽。这是主要用来传播变更的机制，不过集群管理员手动进行重新配置是例外（比如为了在主节点间移动哈希槽，通过 redis-trib 来进行手动碎片整理）。</p>
<p>当一个新的 Redis 集群节点创建的时候，它的本地哈希槽表（表示给定哈希槽和给定节点 ID 的映射关系表）被初始化，每个哈希槽被置为 nil，也就是，每个哈希槽都是没赋值的。</p>
<p>一个节点要更新它的哈希槽表所要遵守的第一个规则如下：</p>
<p><strong>规则 1：如果一个哈希槽是没有赋值的，然后有个已知节点认领它，那么我就会修改我的哈希槽表，把这个哈希槽和这个节点关联起来。</strong></p>
<p>由于这个规则，当一个新集群被创建的时候，只需要手动给哈希槽赋值上（通常是通过 redis-trib 命令行工具使用 CLUSTER 命令来实现）负责它的主节点，然后这些信息就会迅速在集群中传播开来。</p>
<p>然而，当一个配置更新的发生是因为一个从节点在其主节点失效后被提升为主节点的时候，这个规则显然还不足够。新的主节点会宣传之前它做从节点的时候负责的哈希槽，但从其他节点看来这些哈希槽并没有被重新赋值，所以如果它们只遵守第一个规则的话就不会升级配置信息。</p>
<p>由于这个原因就有第二个规则，是用来把一个已赋值给以前节点的哈希槽重新绑定到一个新的认领它的节点上</p>
<p><strong>规则 2：如果一个哈希槽已经被赋值了，有个节点它的 configEpoch 比哈希槽当前拥有者的值更大，并且该节点宣称正在负责该哈希槽，那么我们会把这个哈希槽重新绑定到这个新节点上。</strong></p>
<p>因为有这第二个规则，所以集群中的所有节点最终都会同意<strong>哈希槽的拥有者是所有声称拥有它的节点中 configEpoch 值最大的那个</strong>。</p>
<h3 id="update-消息"><a class="header" href="#update-消息">UPDATE 消息</a></h3>
<p>上面描述的传播哈希槽配置信息的系统只使用节点间交换信息的普通 ping 包和 pong 包。 这要求存在一个节点（可以是负责给定哈希槽的主节点或从节点）拥有更新后的配置信息，</p>
<p>然而也存在例外。当有一个节点，它是唯一一个负责处理给定哈希槽的节点，有可能在分区操作后它恢复正常，但拥有的配置信息是过时的。</p>
<p>例子：一个给定的哈希槽是由节点 A 和 B 负责的。节点 A 是一个主节点，然后它在某个时刻失效了，所以节点 B 被提升为主节点。过了一段时间节点 B 也失效了，集群没有其他备份节点可以来处理这个哈希槽，所以只能开始修复操作。</p>
<p>在一段时间过后节点 A 恢复正常了，并且作为一个可写入的主节点重新加入集群，但它的配置信息是过时的。此时没有任何备份节点能更新它的配置信息。这就是 UPDATE 消息存在的目的：当一个节点检测到其他节点在宣传它的哈希槽的时候是用一份过时的配置信息，那么它就会向这个节点发送一个 UPDATE 消息，这个消息包含新节点的 ID 和它负责的哈希槽（以 bitmap 形式发送）。</p>
<p>注意：目前更新配置信息可以用 ping 包/ pong 包，也可以用 UPDATE 消息，这两种方法是共享同一个代码路径（code path）。这两者在更新一个带有老旧信息的节点的配置信息时会有功能上的重复。然而这两种机制都是非常有用的，因为 ping / pong 包在一段时间后能填充（populate）新节点的哈希槽路由表，而 UPDATE 消息只是在一个过时配置信息被检测出来时才被发送出去，并且只覆盖那些需要修复的错误配置信息。</p>
<h3 id="从结点迁移"><a class="header" href="#从结点迁移">从结点迁移</a></h3>
<p>Redis 集群实现了一个叫做备份迁移（replica migration）的概念，以提高系统的可用性。</p>
<p>在集群中有主节点-从节点的设定，如果主从节点间的映射关系是固定的，那么久而久之，当发生多个单一节点独立故障的时候，系统可用性会变得很有限。</p>
<p>例如有一个每个主节点都只有一个从节点的集群，当主节点或者从节点故障失效的时候集群能让操作继续执行下去，但如果主从节点都失效的话就没法让操作继续执行下去。然而这样长期会积累很多由硬件或软件问题引起的单一节点独立故障。例如：</p>
<ul>
<li>主节点 A 有且只有一个从节点 A1。</li>
<li>主节点 A 失效了。A1 被提升为新的主节点。</li>
<li>三个小时后，A1 因为一个独立事件（跟节点 A 的失效无关）失效了。由于没有其他从节点可以提升为主节点（因为节点 A 仍未恢复正常），集群没法继续进行正常操作。</li>
</ul>
<p>如果主从节点间的映射关系是固定的，那要让集群更有抵抗力地面对上面的情况的唯一方法就是为每个主节点添加从节点。然而这要付出的代价也更昂贵，因为要求 Redis 执行更多的实例、更多的内存等等。</p>
<p>一个候选方案就是在集群中创建不对称性，然后让集群布局时不时地自动变化。例如，假设集群有三个主节点 A，B，C。节点 A 和 B 都各有一个从节点，A1 和 B1。节点 C 有两个从节点：C1 和 C2。</p>
<p>备份迁移是从节点自动重构的过程，为了迁移到一个没有可工作从节点的主节点上。在上面提到的例子中，备份迁移过程如下：</p>
<ul>
<li>主节点 A 失效。A1 被提升为主节点。</li>
<li>节点 C2 迁移成为节点 A1 的从节点，要不然 A1 就没有任何从节点。</li>
<li>三个小时后节点 A1 也失效了。</li>
<li>节点 C2 被提升为取代 A1 的新主节点。</li>
<li>集群仍然能继续正常工作。</li>
</ul>
<h3 id="迁移算法"><a class="header" href="#迁移算法">迁移算法</a></h3>
<p>迁移算法不用任何形式的协议，因为 Redis 集群中的从节点布局不是集群配置信息（配置信息要求前后一致并且/或者用 config epochs 来标记版本号）的一部分。 它使用的是一个避免在主节点没有备份时从节点大批迁移的算法。这个算法保证，一旦集群配置信息稳定下来，<strong>最终每个主节点都至少会有一个从节点作为备份</strong>。</p>
<ul>
<li>
<p>每个从节点若检测出存在至少一个没有好的从节点的单一主节点，那么就会触发这个算法的执行</p>
</li>
<li>
<p>采取行动的从节点是属于那些拥有最多从节点的主节点，并且不处于 FAIL 状态及拥有最小的节点 ID。</p>
</li>
<li>
<p>如果有 10 个主节点，它们各有 1 个从节点，另外还有 2 个主节点，它们各有 5 个从节点。会尝试迁移的从节点是在那 2 个拥有 5 个从节点的主节点中的所有从节点里，节点 ID 最小的那个</p>
</li>
</ul>
<p><strong>竞争情况</strong></p>
<p>在集群配置信息不稳定的情况下，有可能发生一种竞争情况：多个从节点都认为自己是不处于 FAIL 状态并且拥有较小节点 ID（实际上这是一种比较难出现的状况）。如果这种情况发生的话，结果是多个从节点都会迁移到同个主节点下，不过这种结局是无害的。这种竞争发生的话，有时候会使得割让出从节点的主节点变成没有任何备份节点，当集群再次达到稳定状态的时候，本算法会再次执行，然后把从节点迁移回它原来的主节点。</p>
<p>最终每个主节点都会至少有一个从节点作为备份节点。通常表现出来的行为是，一个从节点从一个拥有多个从节点的主节点迁移到一个孤立的主节点。</p>
<p>这个算法能通过一个用户可配置的参数 cluster-migration-barrier 进行控制。这个参数表示的是，一个主节点在拥有多少个好的从节点的时候就要割让一个从节点出来。例如这个参数若被设为 2，那么只有当一个主节点拥有 2 个可工作的从节点时，它的一个从节点会尝试迁移。</p>
<h3 id="发布订阅publishsubscribe"><a class="header" href="#发布订阅publishsubscribe">发布/订阅（Publish/Subscribe）</a></h3>
<p>在一个 Redis 集群中，客户端能订阅任何一个节点，也能发布消息给任何一个节点。集群会确保发布的消息都会按需进行转发。 目前的实现方式是单纯地向所有节点广播所有的发布消息，在将来的实现中会用 bloom filters 或其他算法来优化。</p>
<h1 id="集群配置-1"><a class="header" href="#集群配置-1">集群配置</a></h1>
<pre><code class="language-shell">#端口配置
port 7000
#集群启用
cluster-enabled yes
#保存节点配置文件的路径
cluster-config-file nodes.conf
#节点超时
cluster-node-timeout 5000

appendonly yes
</code></pre>
<h1 id="实战"><a class="header" href="#实战">实战</a></h1>
<h2 id="经典三主三从"><a class="header" href="#经典三主三从">经典三主三从</a></h2>
<h3 id="规划"><a class="header" href="#规划"><strong>规划</strong></a></h3>
<pre><code>7000 7001 7002 7003 7004 7005 自动配置主从
</code></pre>
<h3 id="基础配置"><a class="header" href="#基础配置"><strong>基础配置</strong></a></h3>
<pre><code class="language-sh"># 拷贝命令
sed  's/bind 127.0.0.1/bind 0.0.0.0/g' ../redis.conf &gt;redis.conf
sed -i 's/^port 6379/port 7005/g' redis.conf
sed -i 's/^protected-mode yes/protected-mode no/g' redis.conf
sed -i 's/^daemonize no/daemonize yes/g' redis.conf
</code></pre>
<h3 id="集群配置-2"><a class="header" href="#集群配置-2"><strong>集群配置</strong></a></h3>
<pre><code class="language-shell">
# 启动cluster
sed -i 's/# cluster-enabled yes/cluster-enabled yes/g' redis.conf
# 启用集群配置文件
sed -i 's/# cluster-config-file nodes-6379.conf/cluster-config-file nodes-6379.conf/g'  redis.conf
# 集群不需要所有槽都被映射也能提供服务
sed -i 's/# cluster-require-full-coverage yes/cluster-require-full-coverage no/g' redis.conf
</code></pre>
<h3 id="启停"><a class="header" href="#启停"><strong>启停</strong></a></h3>
<pre><code class="language-shell">../../redis-server redis.conf
kill -15 `ps aux | grep -v grep | grep redis | awk '{ print $2 }'`
</code></pre>
<h3 id="完整配置"><a class="header" href="#完整配置"><strong>完整配置</strong></a></h3>
<pre><code class="language-shell">kill -15 `ps aux | grep -v grep | grep redis | awk '{ print $2 }'`
for i in 7000 7001 7002 7003 7004 7005;
do
    rm -rf $i;
    mkdir $i;
    cd $i;
    sed  's/bind 127.0.0.1/bind 0.0.0.0/g' ../redis.conf &gt;redis.conf
    sed -i &quot;s/^port 6379/port $i/g&quot; redis.conf
    sed -i 's/^protected-mode yes/protected-mode no/g' redis.conf
    sed -i 's/^daemonize no/daemonize yes/g' redis.conf
    sed -i 's/# cluster-enabled yes/cluster-enabled yes/g' redis.conf
    sed -i 's/# cluster-config-file nodes-6379.conf/cluster-config-file nodes-6379.conf/g'  redis.conf 
    ../redis-server redis.conf
    cd ../
done
</code></pre>
<h3 id="启动集群"><a class="header" href="#启动集群"><strong>启动集群</strong></a></h3>
<p><strong>随机指定主从</strong></p>
<pre><code class="language-shell">./redis-cli --cluster create 192.168.3.16:7000 192.168.3.16:7001 192.168.3.16:7002 192.168.3.16:7003 192.168.3.16:7004 192.168.3.16:7005  --cluster-replicas 1
</code></pre>
<p><strong>手动指定</strong></p>
<pre><code class="language-shell">./redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002  --cluster-replicas 0

./redis-cli --cluster add-node --slave 127.0.0.1:7003 127.0.0.1:7000 --cluster-slave
./redis-cli --cluster add-node --slave 127.0.0.1:7004 127.0.0.1:7001 --cluster-slave
./redis-cli --cluster add-node --slave 127.0.0.1:7005 127.0.0.1:7002 --cluster-slave
</code></pre>
<h3 id="查看集群"><a class="header" href="#查看集群">查看集群</a></h3>
<p><strong>查看集群信息</strong></p>
<pre><code class="language-text">cluster info
</code></pre>
<p><strong>查看集群节点</strong></p>
<pre><code>cluster nodes
</code></pre>
<h3 id="操作集群"><a class="header" href="#操作集群">操作集群</a></h3>
<p><strong>删除节点</strong></p>
<pre><code>如果有slave，先删除slave或者将slave转移到其他master下
</code></pre>
<p><strong>删除slave</strong></p>
<pre><code>redis-cli --cluster del-node 172.17.0.7:6379 'f9e78f563314a1d88796ec0ca2b13e4ac3cae75f'
</code></pre>
<p><strong>转移slot</strong></p>
<p>因为master上面有slot，所以首先reshard转移slot，假设将  127.0.0.1:7000 上面的slot转移到 127.0.0.1:7001 和127.0.0.1:7002  上</p>
<pre><code class="language-shell">#非交互式
redis-cli --cluster reshard  127.0.0.1:7000

redis-cli --cluster reshard 172.17.0.4:6379 --cluster-from '46623a0b2ec8abb8a0688769337e91268df3c73f' --cluster-to '14d129294d95867777a91d29b708413baa8a276c' --cluster-slots 2500 --cluster-yes


 redis-cli --cluster reshard host:port --cluster-from &lt;arg&gt; --cluster-to &lt;arg&gt; --cluster-slots &lt;arg&gt; --cluster-yes --cluster-timeout &lt;arg&gt; --cluster-pipeline &lt;arg&gt;

# 参数说明：
# host：port：必传参数，集群内任意节点地址，用来获取整个集群信息。
# --cluster-from：制定源节点的id，如果有多个源节点，使用逗号分隔，如果是all源节点变为集群内所有主节点，在迁移过程中提示用户输入。
# --cluster-to：需要迁移的目标节点的id，目标节点只能填写一个，在迁移过程中提示用户输入。
# --cluster-slots：需要迁移槽的总数量，在迁移过程中提示用户输入。
# --cluster-yes：当打印出reshard执行计划时，是否需要用户输入yes确认后再执行reshard。
# --cluster-timeout：控制每次migrate操作的超时时间，默认为60000毫秒。
# --cluster-pipeline：控制每次批量迁移键的数量，默认为10。
</code></pre>
<pre><code class="language-shell">#然后将剩余的slot转移到172.17.0.3上，执行下面一条命令即可，还剩余2962个slot
redis-cli --cluster reshard 172.17.0.4:6379 --cluster-from '46623a0b2ec8abb8a0688769337e91268df3c73f' --cluster-to '8a7b1a4cf2980c031c0e5e912cf366981588e3c9' --cluster-slots 2962 --cluster-yes
</code></pre>
<p><strong>删除master</strong></p>
<pre><code>redis-cli --cluster del-node 172.17.0.4:6379 '46623a0b2ec8abb8a0688769337e91268df3c73f'
</code></pre>
<p><strong>添加节点</strong></p>
<pre><code>redis-cli --cluster add-node 172.17.0.4:6379 172.17.0.2:6379
</code></pre>
<h3 id="故障转移"><a class="header" href="#故障转移">故障转移</a></h3>
<p>上面的删除节点都是在已经情况下操作的，假设现在在未知情况下宕机了，那么会发生什么？</p>
<h4 id="master宕机"><a class="header" href="#master宕机">master宕机</a></h4>
<p>假设master宕机，让127.0.0.1:7000 宕机，过了一会儿，看cluster nodes信息发现 127.0.0.1:7000 有fail标志</p>
<p>稍等片刻之后发现127.0.0.1:7004 变成了master</p>
<p>在看看127.0.0.1:7004 的日志输出有下面这句话</p>
<pre><code>Failover election won: I'm the new master.
</code></pre>
<p>也就是说当集群内的mater宕机后，slave被选举一个出来当做master，集群依然可用，假设原来的master恢复了，那么它将变成slave追随现在的master</p>
<h4 id="master-slave宕机"><a class="header" href="#master-slave宕机">master-slave宕机</a></h4>
<p>假如master和slave双双宕机了呢？此时将都变成fail</p>
<p>默认情况下此时集群将变得不可用，执行get指令时会报错</p>
<pre><code>(error) CLUSTERDOWN The cluster is down
</code></pre>
<p>但是如果配置了cluster-require-full-coverage，那么集群依然<strong>部分可用</strong>，所谓部分可用即宕机的slot不可用，其他的slot还是可用的，参考：<a href="https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/53594257/clusterdown-the-cluster-is-down-in-redis">https://stackoverflow.com/quest</a></p>
<pre><code>cluster-require-full-coverage no
</code></pre>
<p>很多文章都说此时slot会自动转移，但是我测试时并不会自动转移，仔细想一想，master-slave双双都在不可抗力下宕机了，那么里面的数据肯定是拿不出来的，怎么转移slot呢？</p>
<h2 id="代理"><a class="header" href="#代理">代理</a></h2>
<h3 id="安装-2"><a class="header" href="#安装-2">安装</a></h3>
<pre><code># 安装编译环境，各种工具等，注意libstdc++-static可能安装不上
yum install -y git wget gcc gcc-c++ libstdc++-static make telnet
# 创建文件夹
cd ~ &amp;&amp; mkdir soft &amp;&amp; cd soft
# clone代码到本地
git clone https://github.com/joyieldInc/predixy.git
# 编译安装
cd predixy &amp;&amp; make 
# 拷贝
mkdir -p /opt/predixy &amp;&amp; cp src/predixy /opt/predixy
# 添加环境变量
cat &gt;&gt; /etc/profile &lt;&lt;EOF
export PATH=$PATH:/opt/predixy
EOF
echo  'source /etc/profile' &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc
# 帮助命令
predixy -h
</code></pre>
<h3 id="配置predixconf"><a class="header" href="#配置predixconf">配置predix.conf</a></h3>
<pre><code># 开启日志
sed -i 's/# Log .\/predixy.log/Log .\/predixy.log/g' predixy.conf
#predixy 默认运行在7617端口
# 引入cluster.conf
sed -i 's/# Include cluster.conf/Include cluster.conf/g' predixy.conf
# 注释测试 try.conf
sed -i 's/Include try.conf/# Include try.conf/g' predixy.conf
</code></pre>
<h3 id="配置clusterconf"><a class="header" href="#配置clusterconf">配置cluster.conf</a></h3>
<pre><code>cat &gt; cluster.conf &lt;&lt;EOF
ClusterServerPool {
    #这个是主节点访问权重，如果是只把备节点用作备份不去做读写分离，直接将这个配置成100只去读主节点就好了。
    MasterReadPriority 100
    # redis实例的访问密码
    # Password sjwkk123456
    # 读写分离功能，从静态redis slave节点执行读请求的优先级，所谓静态节点，是指在本配置文件中显示列出的redis节点，不指定的话为0
    StaticSlaveReadPriority 50 
    # 功能见上，所谓动态节点是指在本配置文件中没有列出，但是通过redis sentinel动态发现的节点，不指定的话为0
    DynamicSlaveReadPriority 50
    # predixy会周期性的请求redis sentinel以获取最新的集群信息，该参数以秒为单位指定刷新周期，不指定的话为1秒
    RefreshInterval 1
    # 请求在predixy中最长的处理/等待时间，如果超过该时间redis还没有响应的话，那么predixy会关闭同redis的连接，并给客户端一个错误响应，对于blpop这种阻塞式命令，该选项不起作用，为0则禁止此功能，即如果redis不返回就一直等待，不指定的话为0
    ServerTimeout 1
    # 一个redis实例出现多少次才错误以后将其标记为失效，不指定的话为10
    ServerFailureLimit 10
    # 一个redis实例失效后多久后去检查其是否恢复正常，不指定的话为1秒
    ServerRetryTimeout 1
    #predixy与redis的连接tcp keepalive时间，为0则禁止此功能，不指定的话为0
    KeepAlive 120
    Servers {
        # 配置所有节点地址
        + 127.0.0.1:7000
        + 127.0.0.1:7001
        + 127.0.0.1:7002
        + 127.0.0.1:7003
        + 127.0.0.1:7004
        + 127.0.0.1:7005
    }
}
EOF
</code></pre>
<h3 id="启动并测试"><a class="header" href="#启动并测试">启动并测试</a></h3>
<pre><code class="language-shell"># 启动
predixy /etc/predixy/conf/predixy.conf &amp;

# 查看日志
tail -f /etc/predixy/conf/predixy.log 

# 连接代理
redis-cli -h 172.17.0.8 -p 7617

# 设置值
set k1 aaa

# 获取值
get k1
</code></pre>
<p><a href="https://zhuanlan.zhihu.com/p/362143353">参考文章</a></p>
<p><strong>下载链接</strong></p>
<pre><code>curl -O  http://download.redis.io/releases/redis-6.0.6.tar.gz
tar -xf redis-6.0.6.tar.gz
cd redis-6.0.6
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="redis-有序集合sorted-set"><a class="header" href="#redis-有序集合sorted-set">Redis 有序集合(sorted set)</a></h2>
<ul>
<li>
<p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。</p>
</li>
<li>
<p>不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</p>
</li>
</ul>
<p>有序集合的成员是唯一的,但分数(score)却可以重复。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
<p><strong>示例</strong></p>
<pre><code class="language-shell">redis 127.0.0.1:6379&gt; ZADD runoobkey 1 redis
(integer) 1
redis 127.0.0.1:6379&gt; ZADD runoobkey 2 mongodb
(integer) 1
redis 127.0.0.1:6379&gt; ZADD runoobkey 3 mysql
(integer) 1
redis 127.0.0.1:6379&gt; ZADD runoobkey 3 mysql
(integer) 0
redis 127.0.0.1:6379&gt; ZADD runoobkey 4 mysql
(integer) 0
redis 127.0.0.1:6379&gt; ZRANGE runoobkey 0 10 WITHSCORES

1) &quot;redis&quot;
2) &quot;1&quot;
3) &quot;mongodb&quot;
4) &quot;2&quot;
5) &quot;mysql&quot;
6) &quot;4
</code></pre>
<h2 id="redis-有序集合命令"><a class="header" href="#redis-有序集合命令">Redis 有序集合命令</a></h2>
<p><strong>添加成员、或者更新已有成员分数</strong>
<code>ZADD key score1 member1 [score2 member2]</code></p>
<p><strong>获取有序集合的成员数</strong>
<code>ZCARD key</code></p>
<p><strong>统计指定区间分数的成员数</strong>
<code>ZCOUNT key min max</code></p>
<p><strong>有序集合中对指定成员的分数加上增量</strong>
<code>ZINCRBY key increment member</code></p>
<p><strong>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中</strong>
<code>ZINTERSTORE destination numkeys key [key ...]</code></p>
<p><strong>在有序集合中计算在指定字典区间内成员数量</strong>
<code>ZLEXCOUNT key min max</code></p>
<p><strong>通过索引区间返回有序集合指定区间内的成员</strong>
<code>ZRANGE key start stop [WITHSCORES]</code></p>
<p><strong>通过字典区间返回有序集合的成员</strong>
<code>ZRANGEBYLEX key min max [LIMIT offset count]</code></p>
<p><strong>通过分数返回有序集合指定区间内的成员</strong>
<code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]</code></p>
<p><strong>返回有序集合中指定成员的索引</strong>
<code>ZRANK key member</code></p>
<p><strong>移除有序集合中的一个或多个成员</strong>
<code>ZREM key member [member ...]</code></p>
<p><strong>移除有序集合中给定的字典区间的所有成员</strong>
<code>ZREMRANGEBYLEX key min max</code></p>
<p><strong>移除有序集合中给定的排名区间的所有成员</strong>
<code>ZREMRANGEBYRANK key start stop</code></p>
<p><strong>移除有序集合中给定的分数区间的所有成员</strong>
<code>ZREMRANGEBYSCORE key min max</code></p>
<p><strong>返回有序集中指定区间内的成员，通过索引，分数从高到低</strong>
<code>ZREVRANGE key start stop [WITHSCORES]</code></p>
<p><strong>返回有序集中指定分数区间内的成员，分数从高到低排序</strong>
<code>ZREVRANGEBYSCORE key max min [WITHSCORES]</code></p>
<p><strong>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</strong>
<code>ZREVRANK key member</code></p>
<p><strong>返回有序集中，成员的分数值</strong>
<code>ZSCORE key member</code></p>
<p><strong>计算给定的一个或多个有序集的并集，并存储在新的 key 中</strong>
<code>ZUNIONSTORE destination numkeys key [key ...]</code></p>
<p><strong>迭代有序集合中的元素（包括元素成员和元素分值）</strong>
<code>ZSCAN key cursor [MATCH pattern] [COUNT count]</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="五种基础数据结构"><a class="header" href="#五种基础数据结构">五种基础数据结构</a></h1>
<p>redis 的所有数据结构都以唯一的 key 字符串作为名称，通过唯一的 key 获取相对应的 value 数据。不同的数据类型的差异就在于 value 的结构不一样。</p>
<ul>
<li>string（字符串）</li>
<li>list（列表）</li>
<li>hash（字典）</li>
<li>set（集合）</li>
<li>zset（有序集合）</li>
</ul>
<h1 id="string"><a class="header" href="#string">string</a></h1>
<p>string 是最简单的数据结构，其内部就是一个字符数组。string 是动态字符串，相当于 ArrayList，当字符串长度小于 1M 时扩容都是加倍现有的空间。当字符串长度大于 1M 时每次扩容只会增加 1M 的空间。字符串长度最大为 512M。</p>
<h2 id="键值对操作"><a class="header" href="#键值对操作">键值对操作</a></h2>
<pre><code class="language-sh">127.0.0.1:6379&gt; set name codehole
OK
127.0.0.1:6379&gt; get name
&quot;codehole&quot;
127.0.0.1:6379&gt; exists name
(integer) 1
127.0.0.1:6379&gt; del name
(integer) 1
127.0.0.1:6379&gt; get name
(nil)
127.0.0.1:6379&gt;
</code></pre>
<h2 id="批量键值对操作"><a class="header" href="#批量键值对操作">批量键值对操作</a></h2>
<pre><code class="language-sh">mset key value [key value ...]
mget key [key ...]
</code></pre>
<pre><code class="language-sh">127.0.0.1:6379&gt; set name1 codehole
OK
127.0.0.1:6379&gt; set name2 holycoder
OK
127.0.0.1:6379&gt; mget name1 name2 name3
1) &quot;codehole&quot;
2) &quot;holycoder&quot;
3) (nil)
127.0.0.1:6379&gt; mset name1 boy name2 girl name3 unknown
OK
127.0.0.1:6379&gt; mget name1 name2 name3
1) &quot;boy&quot;
2) &quot;girl&quot;
3) &quot;unknown&quot;
127.0.0.1:6379&gt;
</code></pre>
<h2 id="过期和-set-命令拓展"><a class="header" href="#过期和-set-命令拓展">过期和 set 命令拓展</a></h2>
<ul>
<li>expire：设置指定 key 的过期时间</li>
<li>setex：添加 key 并设置过期时间</li>
<li>setnx：如果key不存在添加，key存在则不添加。</li>
</ul>
<h2 id="计数"><a class="header" href="#计数">计数</a></h2>
<ul>
<li>incr key</li>
<li>incrby key increment</li>
</ul>
<p>如果 value 是整数，可以对其进行自增操作。注意：自增是有范围的，范围在 signed long 的最大值和最小值之间，超过返回会报错。</p>
<h1 id="list"><a class="header" href="#list">list</a></h1>
<ul>
<li>list 相当于 java 中的 LinkedList，由于是链表结构故新增和删除特别快，但是索引定位特别慢。redis 中的 list 是双向链表结构，支持前后遍历，当列表最后一个元素被删除时，该数据结构会被自动删除。</li>
<li>redis 的 list 结构常用来做异步队列使用。将需要延后处理的任务序列化成字符串，放入 redis 的 list，另一个线程从这个列表中轮训数据进行处理。</li>
<li>使用 list 可以实现先进先出（队列）和后进先出（栈）的效果，添加命令有：<code>lpush</code>、<code>rpush</code>，区别在于取出命令的区别：<code>lpop</code>、<code>rpop</code>。</li>
<li>lpop、rpop记忆：假设 list 元素都是从右边进来(rpush)，左边出是队列，对应命令是 lpop；右边出是栈，对应的命令是 rpop。</li>
</ul>
<h2 id="右进左出队列"><a class="header" href="#右进左出队列"><strong>右进左出：队列</strong></a></h2>
<ul>
<li>rpush key value [value ...] 从右边添加数据，相反的还有 lpush。</li>
<li>llen key</li>
<li>lpop key</li>
</ul>
<h2 id="右进右出栈"><a class="header" href="#右进右出栈">右进右出：栈</a></h2>
<ul>
<li>rpush key value [value ...]</li>
<li>rlen key</li>
<li>rpop key</li>
</ul>
<h2 id="慢操作"><a class="header" href="#慢操作">慢操作</a></h2>
<ul>
<li>lindex key index：相当于 Java 链表的 get(int index)，由于需要对链表进行遍历，性能随着 index 增大而变差。</li>
<li>ltrim key start stop：修剪 start 和 end 区间之间的值，外边的去掉。</li>
<li>lrange key start stop：获取索引范围内的值。</li>
<li>索引值可以为负数，-1 代表倒数第一个元素，-2 代表倒数第二个元素，这点和 Groovy 的 Range 对象很相似。</li>
</ul>
<p><em>example</em></p>
<pre><code class="language-shell">127.0.0.1:6379&gt; rpush books python java golang
(integer) 3
127.0.0.1:6379&gt; lindex books 1
&quot;java&quot;
127.0.0.1:6379&gt; lrange books 0 -1
1) &quot;python&quot;
2) &quot;java&quot;
3) &quot;golang&quot;
127.0.0.1:6379&gt; ltrim books 1 -1 # 去掉第一个元素
OK
127.0.0.1:6379&gt; lrange books 0 -1 # 查看所有元素
1) &quot;java&quot;
2) &quot;golang&quot;
127.0.0.1:6379&gt; ltrim books 1 0 # 区间范围长度为负数，会清空 list。
OK
127.0.0.1:6379&gt; llen books
(integer) 0
127.0.0.1:6379&gt;
</code></pre>
<h2 id="快速列表"><a class="header" href="#快速列表">快速列表</a></h2>
<p>redis list 结构并不简单是一个 linkedList，而是一种称之为「快速链表quicklist」的结构。</p>
<p>在列表元素较少的情况下，会使用一块连续的内存存储，这个结构是 ziplist，即「压缩列表」。</p>
<p>它将所有的元素彼此紧挨着一起存储，分配的是一块连续的内存。</p>
<p>当数据量比较多的时候才会改成 quicklist，因为普通链表需要附加的指针空间太大，会浪费空间，还会加重内存的碎片化。</p>
<p>比如某普通链表存的只是 int 类型的数据，结构上还需要两个额外的指针 prev 和 next。</p>
<p>所以 redis 将链表和 ziplist 结合起来组成了 quicklist。将多个 ziplist 使用双向指针串起来使用。</p>
<h1 id="hash"><a class="header" href="#hash">hash</a></h1>
<blockquote>
<p>hash 相当于 java 的 HashMap，value 是一个键值对。它是一个无序字典，最后一个元素移除后该结构会被删除。</p>
</blockquote>
<p>hash 相当于 java 的 HashMap，value 是一个键值对。它是一个无序字典，最后一个元素移除后该结构会被删除。</p>
<p>适用场景：使用 string 时保存一个用户信息需要将整个对象序列化存入，当我们只需要某个属性却需要把整个对象取出，这样会浪费网络流量和时间。使用 hash 可以将用户信息分段存储，可以只取出部分数据。</p>
<h2 id="基本操作"><a class="header" href="#基本操作">基本操作</a></h2>
<ul>
<li>hset key field value</li>
<li>hget key field</li>
<li>hgetall key</li>
<li>hlen key</li>
<li>hmset key field value [field value ...]</li>
<li>hmget key field [field ...]</li>
</ul>
<h2 id="example"><a class="header" href="#example"><strong>example</strong></a></h2>
<pre><code class="language-shell">127.0.0.1:6379&gt; hset userList user1 zhangsan
(integer) 1
127.0.0.1:6379&gt; hset userList user2 lisi
(integer) 1
127.0.0.1:6379&gt; hset userList user3 wangwu
(integer) 1
127.0.0.1:6379&gt; hgetall userList # 获取所有，key value 依次输出。
1) &quot;user1&quot;
2) &quot;zhangsan&quot;
3) &quot;user2&quot;
4) &quot;lisi&quot;
5) &quot;user3&quot;
6) &quot;wangwu&quot;
127.0.0.1:6379&gt; hlen userList
(integer) 3
127.0.0.1:6379&gt; hget userList user2
&quot;lisi&quot;
127.0.0.1:6379&gt; hset userList user2 lisa # 修改值返回0
(integer) 0
127.0.0.1:6379&gt; hget userList user2
&quot;lisa&quot;
127.0.0.1:6379&gt; hmset userList user4 Harry user5 Jessica # 多个设值
OK
127.0.0.1:6379&gt; hgetall userList
 1) &quot;user1&quot;
 2) &quot;zhangsan&quot;
 3) &quot;user2&quot;
 4) &quot;lisa&quot;
 5) &quot;user3&quot;
 6) &quot;wangwu&quot;
 7) &quot;user4&quot;
 8) &quot;Harry&quot;
 9) &quot;user5&quot;
10) &quot;Jessica&quot;
127.0.0.1:6379&gt; hmget userList user4 user5 user6 # 多个取值
1) &quot;Harry&quot;
2) &quot;Jessica&quot;
3) (nil)
</code></pre>
<h2 id="计数-1"><a class="header" href="#计数-1">计数</a></h2>
<p><strong>hash 的 field 也可以进行计数，用法和 incrby 一样。</strong></p>
<ul>
<li>hincrby key field increment</li>
</ul>
<pre><code>127.0.0.1:6379&gt; hset user-Harry age 21
(integer) 1
127.0.0.1:6379&gt; hget user-Harry age
&quot;21&quot;
127.0.0.1:6379&gt; hincrby user-Harry age 1 # 年龄 +1
(integer) 22
127.0.0.1:6379&gt; hget user-Harry age
&quot;22&quot;
</code></pre>
<h1 id="set"><a class="header" href="#set">set</a></h1>
<p>set 相当于 java 的 HashSet，以键值对存储，无序，唯一。</p>
<ul>
<li>sadd key member [member ...]</li>
<li>smembers key</li>
<li>sismember key member</li>
<li>scard key</li>
<li>spop key [count]</li>
</ul>
<pre><code class="language-shell">127.0.0.1:6379&gt; sadd books python
(integer) 1
127.0.0.1:6379&gt; sadd books python # 重复添加不会生效
(integer) 0
127.0.0.1:6379&gt; sadd books java golang
(integer) 2
127.0.0.1:6379&gt; smembers books # 查看所有成员
1) &quot;python&quot;
2) &quot;java&quot;
3) &quot;golang&quot;
127.0.0.1:6379&gt; sismember books java # 是否是一个成员
(integer) 1
127.0.0.1:6379&gt; sismember books rust
(integer) 0
127.0.0.1:6379&gt; scard books # 相当于 count()
(integer) 3
127.0.0.1:6379&gt; spop books # 弹出一个
&quot;python&quot;
127.0.0.1:6379&gt; smembers books
1) &quot;java&quot;
2) &quot;golang&quot;
</code></pre>
<h1 id="zset"><a class="header" href="#zset">zset</a></h1>
<h2 id="介绍-1"><a class="header" href="#介绍-1">介绍</a></h2>
<p>有序列表，类似于 Sorted 和 HashMap 的结合体。</p>
<p>一方面它是一个 set，保证元素的唯一性；另一方面它可以为每个 value 赋予一个 score 作为这个 value 的排序权重。</p>
<p>其内部实现用的是一种叫做「跳跃链表」的数据结构。</p>
<p>适用场景：</p>
<ol>
<li>存储粉丝列表，value 是粉丝的用户Id，score 是关注时间。我们可以以此对粉丝列表按关注时间排序；</li>
<li>存储学生成绩，value 是学生的ID，score 是他的成绩，以此对成绩分组进行排序。</li>
</ol>
<h2 id="常用命令"><a class="header" href="#常用命令">常用命令</a></h2>
<ul>
<li><strong>zadd key score member</strong> [score member ...]：添加一个或多个成员</li>
<li><strong>zrange key start stop</strong> [WITHSCORES]：查看成员区间，WITHSCORES 表示显示成绩。</li>
<li><strong>zrevrange key start stop</strong> [WITHSCORES]：反向查看成员区间</li>
<li><strong>zcard key</strong>：成员个数</li>
<li><strong>zscore key member</strong>：查看成员排序权重</li>
<li><strong>zrank key member</strong>：查看指定成员的排名</li>
<li><strong>zrangebyscore key min max</strong> [WITHSCORES] [LIMIT offset count]：以成绩排名显示</li>
<li><strong>zrem key member</strong> [member ...]：移除指定成员</li>
</ul>
<h1 id="过期时间"><a class="header" href="#过期时间">过期时间</a></h1>
<p>redis 的所有数据结构都可以设置过期时间（单位 s），时间到了，redis 会自动删除相应的对象。</p>
<ol>
<li>过期是以对象为单位的，即一个 key 是一个对象。比如一个 Hash 结构的过期是整个 key 的过期而不是某个子 key 的过期。</li>
<li>如果一个字符串设置了过期时间，然后调用 set 方法设置了它，它的过期时间会消失。</li>
</ol>
<pre><code class="language-shell">127.0.0.1:6379&gt; set codehole yoyo
OK
127.0.0.1:6379&gt; expire codehole 600
(integer) 1
127.0.0.1:6379&gt; ttl codehole
(integer) 596
127.0.0.1:6379&gt; set codehole yoyo
OK
127.0.0.1:6379&gt; ttl codehole
(integer) -1
127.0.0.1:6379&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="关于版本控制"><a class="header" href="#关于版本控制">关于版本控制</a></h1>
<p>版本控制是一种记录一个或若干文件内容变化,以便将来查阅特定版本修订情况的系统</p>
<h2 id="版本控制系统的变迁"><a class="header" href="#版本控制系统的变迁">版本控制系统的变迁</a></h2>
<h3 id="本地版本控制"><a class="header" href="#本地版本控制">本地版本控制</a></h3>
<ul>
<li>Revision Control System (<a href="https://www.gnu.org/software/rcs/">RCS</a>)  是一种最流行的本地版本控制系统</li>
<li>工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）,通过应用所有的补丁，可以重新计算出各个版本的文件内容。</li>
</ul>
<h3 id="集中化的版本控制系统"><a class="header" href="#集中化的版本控制系统">集中化的版本控制系统</a></h3>
<p>​	但是如何让在不同系统上的开发者协同工作？集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生,诸如 CVS、Subversion 以及 Perforce 等,都有一个单一的集中管理的服务器，保存所有文件的修订版本,而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新</p>
<p>​	如果中心数据库所在的磁盘发生损坏,项目的整个变更历史将会丢失</p>
<h3 id="分布式版本控制系统"><a class="header" href="#分布式版本控制系统">分布式版本控制系统</a></h3>
<p>​	分布式版本控制系统（Distributed Version Control System，简称 DVCS）很好的解决了上面的问题,像 Git、Mercurial、Bazaar 以及 Darcs 等</p>
<p>​	客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录</p>
<p>​	任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复</p>
<h2 id="什么是git"><a class="header" href="#什么是git">什么是git</a></h2>
<h3 id="git-和其它版本控制系统的差别"><a class="header" href="#git-和其它版本控制系统的差别">Git 和其它版本控制系统的差别</a></h3>
<p>Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git 对待数据的方法</p>
<ul>
<li>
<p>其他系统对待数据的方式</p>
<p>一组基本文件和每个文件随时间逐步累积的差异,通常给称为 (<strong>基于差异（delta-based）</strong>)</p>
</li>
<li>
<p>而Git 更像是把数据看作是对小型文件系统的一系列快照</p>
<ul>
<li>每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引</li>
<li>为了效率,如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件</li>
<li>Git 对待数据更像是一个 <strong>快照流</strong>。</li>
<li>Git 更像是一个小型的文件系统</li>
</ul>
</li>
</ul>
<h3 id="git保证完整性"><a class="header" href="#git保证完整性">GIT保证完整性</a></h3>
<ul>
<li>Git 中所有的数据在存储前都计算校验和，然后以校验和来引用</li>
<li>Git 用以计算校验和的机制叫做 SHA-1 散列</li>
<li>这是一个由 40 个十六进制字符(0~F)组成的字符串</li>
<li>Git 数据库中保存的信息都是以文件内容的哈希值来索引</li>
</ul>
<h3 id="git-一般只添加数据"><a class="header" href="#git-一般只添加数据">Git 一般只添加数据</a></h3>
<ul>
<li>你执行的 Git 操作，几乎只往 Git 数据库中 <strong>添加</strong> 数据, 你很难让 Git 执行任何不可逆操作</li>
</ul>
<h3 id="三种状态"><a class="header" href="#三种状态">三种状态</a></h3>
<p><strong>已提交（committed）</strong></p>
<p><strong>已修改（modified）</strong> </p>
<p><strong>已暂存（staged）</strong></p>
<h2 id="git的配置"><a class="header" href="#git的配置">GIT的配置</a></h2>
<h3 id="配置文件"><a class="header" href="#配置文件">配置文件</a></h3>
<ul>
<li><code>git config</code> 命令来帮助设置 <code>控制 Git 外观和行为的</code> 配置变量</li>
<li>这些变量可能会存储在三个不同的位置
<ul>
<li>/etc/gitconfig :所有用户的通用配置, <code>git config</code> 时带上 <code>--system</code> 选项时会读写该文件的配置变量</li>
<li><em>~/.gitconfig<code>或</code>~/.config/git/config</em> 当前用户的变量,--global选项为读写此文件,为当前用户的所有仓库的通用配置</li>
<li><em>.git/config</em> 针对该仓库 --local选项读取该文件,默认情况下使用它(当然，你需要进入某个 Git 仓库中才能让该选项生效)</li>
</ul>
</li>
</ul>
<p>每一个级别会覆盖上一级别的配置</p>
<h3 id="设置用户信息"><a class="header" href="#设置用户信息">设置用户信息</a></h3>
<p>安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址</p>
<pre><code class="language-shell">$ git config --global user.name &quot;John Doe&quot;
$ git config --global user.email johndoe@example.com
</code></pre>
<h3 id="文本编辑器"><a class="header" href="#文本编辑器">文本编辑器</a></h3>
<pre><code class="language-shell">git config --global core.editor emacs

$ git config --global core.editor &quot;'C:/Program Files/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin&quot;
</code></pre>
<h3 id="命令其他使用"><a class="header" href="#命令其他使用">命令其他使用</a></h3>
<p>你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置,</p>
<pre><code class="language-shell">//检查某一项配置
git config &lt;key&gt;
git config list
</code></pre>
<h3 id="获取帮助"><a class="header" href="#获取帮助">获取帮助</a></h3>
<pre><code class="language-shell">//全面手册
git help config

//快速参考
git add -h
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git库管理"><a class="header" href="#git库管理">Git库管理</a></h1>
<p>版本库管理？那不是管理员要干的事情么，怎么放在“Git独奏”这一部分了？</p>
<p>没有错，这是因为对于Git，每个用户都是自己版本库的管理员，所以在“Git独奏”的最后一章，来谈一谈Git版本库管理的问题</p>
<p>如果下面的问题您没有遇到或者不感兴趣，读者大可以放心的跳过这一章。</p>
<ul>
<li>从网上克隆来的版本库，为什么对象库中找不到对象文件？而且引用目录里也看不到所有的引用文件？</li>
<li>不小心添加了一个大文件到Git库中，用重置命令丢弃了包含大文件的提交，可是版本库不见小，大文件仍在对象库中。</li>
<li>本地版本库的对象库里文件越来越多，这可能导致Git性能的降低。</li>
</ul>
<h2 id="对象和引用哪里去了"><a class="header" href="#对象和引用哪里去了">对象和引用哪里去了</a></h2>
<pre><code>git clone git://github.com/ossxp-com/gitdemo-commit-tree.git i-am-admin
</code></pre>
<p>进入克隆的版本库，使用<strong>git show-ref</strong>命令看看所含的引用。</p>
<pre><code>$ cd /path/to/my/workspace/i-am-admin
$ git show-ref
6652a0dce6a5067732c00ef0a220810a7230655e refs/heads/master
6652a0dce6a5067732c00ef0a220810a7230655e refs/remotes/origin/HEAD
6652a0dce6a5067732c00ef0a220810a7230655e refs/remotes/origin/master
c9b03a208288aebdbfe8d84aeb984952a16da3f2 refs/tags/A
1a87782f8853c6e11aacba463af04b4fa8565713 refs/tags/B
9f8b51bc7dd98f7501ade526dd78c55ee4abb75f refs/tags/C
887113dc095238a0f4661400d33ea570e5edc37c refs/tags/D
6decd0ad3201ddb3f5b37c201387511059ac120c refs/tags/E
70cab20f099e0af3f870956a3fbbbda50a17864f refs/tags/F
96793e37c7f1c7b2ddf69b4c1e252763c11a711f refs/tags/G
476e74549047e2c5fbd616287a499cc6f07ebde0 refs/tags/H
76945a15543c49735634d58169b349301d65524d refs/tags/I
f199c10c3f1a54fa3f9542902b25b49d58efb35b refs/tags/J
</code></pre>
<p>其中以<code>refs/heads/</code>开头的是分支；以<code>refs/remotes/</code>开头的是远程版本库分支在本地的映射，会在后面章节介绍；以<code>refs/tags/</code>开头的是里程碑。按照之前的经验，在<code>.git/refs</code>目录下应该有这些引用所对应的文件才是。看看都在么？</p>
<pre><code>$ find .git/refs/ -type f
.git/refs/remotes/origin/HEAD
.git/refs/heads/master
</code></pre>
<p>为什么才有两个文件？实际上当运行下面的命令后，引用目录下的文件会更少：</p>
<pre><code>$ git pack-refs --all
$ find .git/refs/ -type f
.git/refs/remotes/origin/HEAD
</code></pre>
<pre><code>$ find .git/objects/ -type f
.git/objects/pack/pack-969329578b95057b7ea1208379a22c250c3b992a.idx
.git/objects/pack/pack-969329578b95057b7ea1208379a22c250c3b992a.pack
</code></pre>
<p>对象库中只有两个文件，本应该一个一个独立保存的对象都不见了。读者应该能够猜到，所有的对象文件都被打包到这两个文件中了，其中以<code>.pack</code>结尾的文件是打包文件，以<code>.idx</code>结尾的是索引文件。打包文件和对应的索引文件只是扩展名不同，都保存于<code>.git/objects/pack/</code>目录下。Git对于以SHA1哈希值作为目录名和文件名保存的对象有一个术语，称为松散对象。</p>
<p>松散对象打包后会提高访问效率，而且不同的对象可以通过增量存储节省磁盘空间。</p>
<p>可以通过Git一个底层命令可以查看索引中包含的对象：</p>
<pre><code>$ git show-index &lt; .git/objects/pack/pack-*.idx | head -5
661 0cd7f2ea245d90d414e502467ac749f36aa32cc4 (0793420b)
63020 1026d9416d6fc8d34e1edfb2bc58adb8aa5a6763 (ed77ff72)
3936 15328fc6961390b4b10895f39bb042021edd07ea (13fb79ef)
3768 1a588ca36e25f58fbeae421c36d2c39e38e991ef (86e3b0bd)
2022 1a87782f8853c6e11aacba463af04b4fa8565713 (e269ed74)
</code></pre>
<p>为什么克隆远程版本库就可以产生对象库打包以及引用打包的效果呢？</p>
<p>这是因为克隆远程版本库时，使用了“智能”的通讯协议，远程Git服务器将对象打包后传输给本地，形成本地版本库的对象库中的一个包含所有对象的包以及索引文件</p>
<p>无疑这样的传输方式——按需传输、打包传输，效率最高。</p>
<p>克隆之后的版本库在日常的提交中，产生的新的对象仍旧以松散对象存在，而不是以打包的形式，日积月累会在本地版本库的对象库中形成大量的松散文件</p>
<p>松散对象只是进行了压缩，而没有（打包文件才有的）增量存储的功能，会浪费磁盘空间，也会降低访问效率</p>
<p>更为严重的是一些非正式的临时对象（暂存区操作中产生的临时对象）也以松散对象的形式保存在对象库中，造成磁盘空间的浪费。下一节就着手处理临时对象的问题。</p>
<h2 id="暂存区操作引入的临时对象"><a class="header" href="#暂存区操作引入的临时对象">暂存区操作引入的临时对象</a></h2>
<p>暂存区操作有可能在对象库中产生临时对象，例如文件反复的修改和反复的向暂存区添加，或者添加到暂存区后不提交甚至直接撤销，就会产生垃圾数据占用磁盘空间</p>
<p>然后将工作区中两个内容完全一样的大文件加入暂存区。</p>
<pre><code>$ git add bigfile bigfile.dup
</code></pre>
<p>查看一下磁盘空间占用：</p>
<ul>
<li>
<p>工作区连同版本库共占用33MB。</p>
<pre><code>$ du -sh .
33M     .
</code></pre>
</li>
<li>
<p>其中版本库只占用了11MB。版本库空间占用是工作区的一半。</p>
<p>如果再有谁说版本库空间占用一定比工作区大，可以用这个例子回击他。</p>
<pre><code>$ du -sh .git/
11M     .git/
</code></pre>
</li>
</ul>
<p>看看版本库中对象库内的文件，会发现多出了一个松散对象。之所以添加两个文件而只有一个松散对象，是因为Git对于文件的保存是将内容保存为blob对象中，和文件名无关，相同内容的不同文件会共享同一个blob对象。</p>
<pre><code>$ find .git/objects/ -type f
.git/objects/2e/bcd92d0dda2bad50c775dc662c6cb700477aff
.git/objects/pack/pack-969329578b95057b7ea1208379a22c250c3b992a.idx
.git/objects/pack/pack-969329578b95057b7ea1208379a22c250c3b992a.pack
</code></pre>
<p>如果不想提交，想将文件撤出暂存区，则进行如下操作。</p>
<ul>
<li>
<p>当前暂存区的状态。</p>
<pre><code>$ git status -s
A  bigfile
A  bigfile.dup
</code></pre>
</li>
<li>
<p>将添加的文件撤出暂存区。</p>
<pre><code>$ git reset HEAD
</code></pre>
</li>
<li>
<p>通过查看状态，看到文件被撤出暂存区了。</p>
<pre><code>$ git status -s
?? bigfile
?? bigfile.dup
</code></pre>
</li>
</ul>
<p>文件撤出暂存区后，在对象库中产生的blob松散对象仍然存在，通过查看版本库的磁盘占用就可以看出来。</p>
<pre><code>$ du -sh .git/
11M     .git/
</code></pre>
<p>Git提供了<strong>git fsck</strong>命令，可以查看到版本库中包含的没有被任何引用关联松散对象</p>
<pre><code>$ git fsck
dangling blob 2ebcd92d0dda2bad50c775dc662c6cb700477aff
</code></pre>
<p>标识为dangling的对象就是没有被任何引用直接或者间接关联到的对象。这个对象就是前面通过暂存区操作引入的大文件的内容。如何将这个文件从版本库中彻底删除呢？Git提供了一个清理的命令：</p>
<pre><code>$ git prune
</code></pre>
<p>用<strong>git prune</strong>清理之后，会发现：</p>
<ul>
<li>
<p>用<strong>git fsck</strong>查看，没有未被关联到的松散对象。</p>
<pre><code>$ git fsck
</code></pre>
</li>
<li>
<p>版本库的空间占用也小了10MB，证明大的临时对象文件已经从版本库中删除了。</p>
<pre><code>$ du -sh .git/
236K    .git/
</code></pre>
</li>
</ul>
<h2 id="重置提交引入的对象"><a class="header" href="#重置提交引入的对象">重置提交引入的对象</a></h2>
<p>上一节用<strong>git prune</strong>命令清除暂存区操作时引入的临时对象，但是如果是用重置命令抛弃的提交和文件就不会轻易的被清除。</p>
<p>将这两个大文件提交到版本库中。</p>
<ul>
<li>
<p>添加到暂存区。</p>
<pre><code>$ git add bigfile bigfile.dup
</code></pre>
</li>
<li>
<p>提交到版本库。</p>
<pre><code>$ git commit -m &quot;add bigfiles.&quot;
[master 51519c7] add bigfiles.
 2 files changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 bigfile
 create mode 100644 bigfile.dup
</code></pre>
</li>
<li>
<p>查看版本库的空间占用。</p>
<pre><code>$ du -sh .git/
11M     .git/
</code></pre>
</li>
</ul>
<p>做一个重置操作，抛弃刚刚针对两个大文件做的提交。</p>
<pre><code>$ git reset --hard HEAD^
</code></pre>
<p>重置之后，看看版本库的变化。</p>
<ul>
<li>
<p>版本库的空间占用没有变化，还是那么“庞大”。</p>
<pre><code>$ du -sh .git/
11M     .git/
</code></pre>
</li>
<li>
<p>查看对象库，看到三个松散对象。</p>
<pre><code>$ find .git/objects/ -type f
.git/objects/info/packs
.git/objects/2e/bcd92d0dda2bad50c775dc662c6cb700477aff
.git/objects/d9/38dee8fde4e5053b12406c66a19183a24238e1
.git/objects/51/519c7d8d60e0f958e135e8b989a78e84122591
.git/objects/pack/pack-969329578b95057b7ea1208379a22c250c3b992a.idx
.git/objects/pack/pack-969329578b95057b7ea1208379a22c250c3b992a.pack
</code></pre>
</li>
<li>
<p>这三个松散对象分别对应于撤销的提交，目录树，以及大文件对应的blob对象。</p>
<pre><code>$ git cat-file -t 51519c7
commit
$ git cat-file -t d938dee
tree
$ git cat-file -t 2ebcd92
blob
</code></pre>
</li>
</ul>
<p>向上一节一样，执行<strong>git prune</strong>命令，期待版本库空间占用会变小。可是：</p>
<ul>
<li>
<p>版本库空间占用没有变化！</p>
<pre><code>$ git prune
$ du -sh .git/
11M     .git/
</code></pre>
</li>
<li>
<p>执行<strong>git fsck</strong>也看不到未被关联到的对象。</p>
<pre><code>$ git fsck
</code></pre>
</li>
<li>
<p>除非像下面这样执行。</p>
<pre><code>$ git fsck --no-reflogs
dangling commit 51519c7d8d60e0f958e135e8b989a78e84122591
</code></pre>
</li>
</ul>
<p>还记得前面章节中介绍的reflog么？reflog是防止误操作的最后一道闸门。</p>
<pre><code>$ git reflog
6652a0d HEAD@{0}: HEAD^: updating HEAD
51519c7 HEAD@{1}: commit: add bigfiles.
</code></pre>
<p>可以看到撤销的操作仍然记录在reflog中，正因如此Git认为撤销的提交和大文件都还被可以被追踪到，还在使用着，所以无法用<strong>git prune</strong>命令删除。</p>
<p>如果确认真的要丢弃不想要的对象，需要对版本库的reflog做过期操作，相当于将<code>.git/logs/</code>下的文件清空。</p>
<ul>
<li>
<p>使用下面的reflog过期命令做不到让刚刚撤销的提交过期，因为reflog的过期操作缺省只会让90天前的数据过期。</p>
</li>
<li>
<pre><code>$ git reflog expire --all
$ git reflog
6652a0d HEAD@{0}: HEAD^: updating HEAD
51519c7 HEAD@{1}: commit: add bigfiles.
</code></pre>
</li>
</ul>
<p>需要要为<strong>git reflog</strong>命令提供<code>--expire=&lt;date&gt;</code>参数，强制<code>&lt;date&gt;</code>之前的记录全部过期。</p>
<pre><code>$ git reflog expire --expire=now --all
$ git reflog
</code></pre>
<p>使用<code>now</code>作为时间参数，让 reflog 的全部记录都过期</p>
<p>没有了 reflog，即回滚的添加大文件的提交从 reflog 中看不到后</p>
<p>该提交对应的 commit 对象、tree 对象和 blob 对象就会成为未被关联的 dangling 对象</p>
<p>可以用<strong>git prune</strong>命令清理</p>
<h2 id="git管家git-gc"><a class="header" href="#git管家git-gc">Git管家：<code>git gc</code></a></h2>
<p>实际操作中会很少用到<strong>git prune</strong>命令来清理版本库，而是会使用一个更为常用的命令<strong>git gc</strong></p>
<p>命令<strong>git gc</strong>就好比Git版本库的管家，会对版本库进行一系列的优化动作。</p>
<ul>
<li>
<p>对分散在<code>.git/refs</code>下的文件进行打包，打包到文件<code>.git/packed-refs</code>中</p>
<p>如果没有将配置<code>gc.packrefs</code>关闭，就会执行命令：<strong>git pack-refs –all –prune</strong>实现对引用的打包。</p>
</li>
<li>
<p>丢弃90天前的reflog记录。</p>
<p>会运行使reflog过期命令：<strong>git reflog expire –all</strong>。因为采用了缺省参数调用，因此只会清空reflog中90天前的记录。</p>
</li>
<li>
<p>对松散对象进行打包。</p>
<ul>
<li>运行<strong>git repack</strong>命令，凡是有引用关联的对象都被打在包里，未被关联的对象仍旧以松散对象形式保存。</li>
</ul>
</li>
<li>
<p>清除未被关联的对象。缺省只清除2周以前的未被关联的对象。</p>
<ul>
<li>可以向<strong>git gc</strong>提供<code>--prune=&lt;date&gt;</code>参数，其中的时间参数传递给<strong>git prune –expire <date></strong>，实现对指定日期之前的未被关联的松散对象进行清理。</li>
</ul>
</li>
<li>
<p>其他清理</p>
<ul>
<li>如运行<strong>git rerere gc</strong>对合并冲突的历史记录进行过期操作。</li>
</ul>
</li>
<li>
<p>例如像暂存区操作引入的没有关联的临时对象会最少保留2个星期，而因为重置而丢弃的提交和文件则会保留最少3个月。</p>
</li>
</ul>
<p>复制两个大文件到工作区。</p>
<pre><code>$ cp /tmp/bigfile bigfile
$ cp /tmp/bigfile bigfile.dup
</code></pre>
<p>在文件<code>bigfile.dup</code>后面追加些内容，造成<code>bigfile</code>和<code>bigfile.dup</code>内容不同。</p>
<pre><code>$ echo &quot;hello world&quot; &gt;&gt; bigfile.dup
</code></pre>
<p>将这两个稍有不同的文件提交到版本库。</p>
<pre><code>$ git add bigfile bigfile.dup
$ git commit -m &quot;add bigfiles.&quot;
[master c62fa4d] add bigfiles.
 2 files changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 bigfile
 create mode 100644 bigfile.dup
</code></pre>
<p>可以看到版本库中提交进来的两个不同的大文件是不同的对象。</p>
<pre><code>$ git ls-tree HEAD | grep bigfile
100644 blob 2ebcd92d0dda2bad50c775dc662c6cb700477aff    bigfile
100644 blob 9e35f946a30c11c47ba1df351ca22866bc351e7b    bigfile.dup
</code></pre>
<p>做版本库重置，抛弃最新的提交，即抛弃添加两个大文件的提交。</p>
<pre><code>$ git reset --hard HEAD^
HEAD is now at 6652a0d Add Images for git treeview.
</code></pre>
<p>此时的版本库有多大呢，还是像之前添加两个相同的大文件时占用11MB空间么？</p>
<pre><code>$ du -sh .git/
22M     .git/
</code></pre>
<p>版本库空间占用居然扩大了一倍！这显然是因为两个大文件分开存储造成的。可以用下面的命令在对象库中查看对象的大小。</p>
<pre><code>$ find .git/objects -type f -printf &quot;%-20p\t%s\n&quot;
.git/objects/0c/844d2a072fd69e71638558216b69ebc57ddb64  233
.git/objects/2e/bcd92d0dda2bad50c775dc662c6cb700477aff  11184682
.git/objects/9e/35f946a30c11c47ba1df351ca22866bc351e7b  11184694
.git/objects/c6/2fa4d6cb4c082fadfa45920b5149a23fd7272e  162
.git/objects/info/packs 54
.git/objects/pack/pack-969329578b95057b7ea1208379a22c250c3b992a.idx   2892
.git/objects/pack/pack-969329578b95057b7ea1208379a22c250c3b992a.pack  80015
</code></pre>
<p>输出的每一行用空白分隔，前面是文件名，后面是以字节为单位的文件大小。从上面的输出可以看出来，打包文件很小，但是有两个大的文件各自占用了11MB左右的空间。</p>
<p>执行<strong>git gc</strong>并不会删除任何对象，因为这些对象都还没有过期。但是会发现版本库的占用变小了。</p>
<ul>
<li>
<p>执行<strong>git gc</strong>对版本库进行整理。</p>
<pre><code>$ git gc
Counting objects: 69, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (49/49), done.
Writing objects: 100% (69/69), done.
Total 69 (delta 11), reused 63 (delta 8)
</code></pre>
</li>
<li>
<p>版本库空间占用小了一半！</p>
<pre><code>$ du -sh .git/
11M     .git/
</code></pre>
</li>
<li>
<p>原来是因为对象库重新打包，两个大文件采用了增量存储使得版本库变小。</p>
<pre><code>$ find .git/objects -type f -printf &quot;%-20p\t%s\n&quot; | sort
.git/objects/info/packs 54
.git/objects/pack/pack-7cae010c1b064406cd6c16d5a6ab2f446de4076c.idx 3004
.git/objects/pack/pack-7cae010c1b064406cd6c16d5a6ab2f446de4076c.pack 11263033
</code></pre>
</li>
</ul>
<p>如果想将抛弃的历史数据彻底丢弃，如下操作。</p>
<ul>
<li>
<p>不再保留90天的reflog，而是将所有reflog全部即时过期。</p>
<pre><code>$ git reflog expire --expire=now --all
</code></pre>
</li>
<li>
<p>通过<strong>git fsck</strong>可以看到有提交成为了未被关联的提交。</p>
<pre><code>$ git fsck
dangling commit c62fa4d6cb4c082fadfa45920b5149a23fd7272e
</code></pre>
</li>
<li>
<p>这个未被关联的提交就是删除大文件的提交。</p>
<pre><code>$ git show c62fa4d6cb4c082fadfa45920b5149a23fd7272e
commit c62fa4d6cb4c082fadfa45920b5149a23fd7272e
Author: Jiang Xin &lt;jiangxin@ossxp.com&gt;
Date:   Thu Dec 16 20:18:38 2010 +0800

    add bigfiles.

diff --git a/bigfile b/bigfile
new file mode 100644
index 0000000..2ebcd92
Binary files /dev/null and b/bigfile differ
diff --git a/bigfile.dup b/bigfile.dup
new file mode 100644
index 0000000..9e35f94
Binary files /dev/null and b/bigfile.dup differ
</code></pre>
</li>
<li>
<p>不带参数调用<strong>git gc</strong>虽然不会清除尚未过期（未到2周）的大文件，但是会将未被关联的对象从打包文件中移出，成为松散文件。</p>
<pre><code>$ git gc
Counting objects: 65, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (45/45), done.
Writing objects: 100% (65/65), done.
Total 65 (delta 8), reused 63 (delta 8)
</code></pre>
</li>
<li>
<p>未被关联的对象重新成为松散文件，所以<code>.git</code>版本库的空间占用又反弹了。</p>
<pre><code>$ du -sh .git/
22M     .git/
$ find .git/objects -type f -printf &quot;%-20p\t%s\n&quot; | sort
.git/objects/0c/844d2a072fd69e71638558216b69ebc57ddb64  233
.git/objects/2e/bcd92d0dda2bad50c775dc662c6cb700477aff  11184682
.git/objects/9e/35f946a30c11c47ba1df351ca22866bc351e7b  11184694
.git/objects/c6/2fa4d6cb4c082fadfa45920b5149a23fd7272e  162
.git/objects/info/packs 54
.git/objects/pack/pack-969329578b95057b7ea1208379a22c250c3b992a.idx 2892
.git/objects/pack/pack-969329578b95057b7ea1208379a22c250c3b992a.pack 80015
</code></pre>
</li>
<li>
<p>实际上如果使用立即过期参数<code>--prune=now</code>调用<strong>git gc</strong>，就不用再等2周了，直接就可以完成对未关联的对象的清理。</p>
<pre><code>$ git gc --prune=now
Counting objects: 65, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (45/45), done.
Writing objects: 100% (65/65), done.
Total 65 (delta 8), reused 65 (delta 8)
</code></pre>
</li>
<li>
<p>清理过后，版本库的空间占用降了下来。</p>
<pre><code>$ du -sh .git/
240K    .git/
</code></pre>
</li>
</ul>
<h2 id="git管家的自动执行"><a class="header" href="#git管家的自动执行">Git管家的自动执行</a></h2>
<p>实际上对于1.6.6及以后版本的Git已经基本上不需要手动执行<strong>git gc</strong>命令了，因为部分Git命令会自动调用<strong>git gc –auto</strong>命令，在版本库确实需要整理的情况下自动开始整理操作。</p>
<p>目前有如下Git命令会自动执行<strong>git gc –auto</strong>命令，实现对版本库的按需整理。</p>
<ul>
<li>执行命令<strong>git merge</strong>进行合并操作后，对版本库进行按需整理。</li>
<li>执行命令<strong>git receive-pack</strong>，即版本库接收其他版本库推送（push）的提交后，版本库会做按需整理操作。
<ul>
<li>当版本库接收到其他版本库的推送（push）请求时，会调用<strong>git receive-pack</strong>命令以接收请求。在接收到推送的提交后，对版本库进行按需整理。</li>
</ul>
</li>
<li>执行命令<strong>git rebase -i</strong>进行交互式变基操作后，会对版本库进行按需整理。</li>
<li>执行命令<strong>git am</strong>对mbox邮箱中通过邮件提交的补丁在版本库中进行应用的操作后，会对版本库做按需整理操作。</li>
</ul>
<p>对于提供共享式“写操作”的Git版本库，可以免维护</p>
<p>所谓的共享式写操作，就是版本库作为一个裸版本库放在服务器上，团队成员可以通过推送（push）操作将提交推送到共享的裸版本中。</p>
<p>每一次推送操作都会触发<strong>git gc –auto</strong>命令，对版本库进行按需整理</p>
<p>对于非独立工作的本地工作区，也可以免维护</p>
<p>因为和他人协同工作的本地工作区会经常执行<strong>git pull</strong>操作从他人版本库或者从共享的版本库拉回新提交，执行<strong>git pull</strong>操作会，会触发<strong>git merge</strong>操作，因此也会对本地版本库进行按需整理。</p>
<p>Git管家命令使用<code>--auto</code>参数调用，会进行按需整理。</p>
<p>因为版本库整理操作对于大的项目可能会非常费时，因此实际的整理并不会经常被触发，即有着非常苛刻的触发条件。想要观察到触发版本库整理操作是非常不容易的事情。</p>
<p>主要的触发条件是：</p>
<p><strong>松散对象只有超过一定的数量时才会执行</strong></p>
<p>而且在统计松散对象数量时，为了降低在<code>.git/objects/</code>目录下搜索松散对象对系统造成的负担，实际采取了取样搜索，即只会对对象库下一个子目录<code>.git/objects/17</code>进行文件搜索。在缺省的配置下，只有该目录中对象数目超过27个，才会触发版本库的整理。</p>
<p>至于为什么只在对象库下选择了一个子目录进行松散对象的搜索，这是因为SHA1哈希值是完全随机的，</p>
<p>文件在由前两位哈希值组成的目录中差不多是平均分布的。至于为什么选择<code>17</code>，不知道对于作者Junio C Hamano有什么特殊意义，也许是向Linus Torvalds被评选为二十世纪最有影响力的100人中排名第17位而进行致敬。</p>
<p>可以通过配置<strong>gc.auto</strong>的值，调整Git管家自动运行时触发版本库整理操作的频率，但是注意不要将<strong>gc.auto</strong>设置为0，否则<strong>git gc –auto</strong>命令永远不会触发版本库的整理。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p>1、git log -- filename(git log filename)
可以看到该文件相关的commit记录</p>
<p>2、git log -p filename -2
可以显示该文件前2次提交的diff</p>
<p>3、git show comit_id filename
可以查看某次提交中的某个文件变化</p>
<p>4、git show commit_id
查看某次提交</p>
<p>5、gitk --follow filename
以图形化界面的方式显示修改列表</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gitflow分支概念"><a class="header" href="#gitflow分支概念">gitflow分支概念</a></h1>
<table><thead><tr><th>分支名称</th><th>作用</th><th>生命周期</th><th>提交or合并</th><th>起止点</th></tr></thead><tbody>
<tr><td><em>Production</em> (<em>master</em>)</td><td>记录历史发布版本</td><td>贯穿整个项目</td><td>不能提交，由release分支合并</td><td>整个项目</td></tr>
<tr><td><em>Develop</em>分支</td><td>记录历史开发功能</td><td>贯穿整个项目</td><td>不能提交，由<em>feature</em>分支，<em>Bugfix</em>分支，<em>Release</em>分支合并代码</td><td>整个项目</td></tr>
<tr><td><em>Hotfix</em>分支</td><td>解决线上bug</td><td>临时分支，紧急修复</td><td>可提交</td><td>由生产分支产生，最终合并进生产分支，与开发分支</td></tr>
<tr><td><em>Reslease</em>分支</td><td>用于本次的Release如文档，<em>bug</em>修复，测试</td><td>临时分支，发版阶段</td><td>可提交</td><td>由开发分支产生，合并到开发分支与生产分支</td></tr>
<tr><td><em>Feature</em>分支</td><td>用于某个功能的开发</td><td>临时分支，开发阶段</td><td>可提交</td><td>由Develop分支产生，合并到Develop分支中</td></tr>
</tbody></table>
<h1 id="从不同角度理解分支"><a class="header" href="#从不同角度理解分支">从不同角度理解分支</a></h1>
<h2 id="生命周期"><a class="header" href="#生命周期">生命周期</a></h2>
<ul>
<li><em>production</em> 分支和<em>develop</em>分支 贯穿项目
<ul>
<li><em>production</em> 分支 记录发布版本，由<em>release</em>分支合并而来</li>
<li><em>develop</em> 分支记录各个功能点的开发进度</li>
</ul>
</li>
<li>其他分支，均为承担特定功能的 临时分支
<ul>
<li><em>hotfix</em> <em>bug</em>修复分支，由生产分支产生，合并到生产分支与开发分支</li>
<li><em>Reslease</em>：用于本次的发布，由开发分支产生，合并到开发分支与生产分支</li>
<li><em>feature</em>：用于某个功能的开发 </li>
</ul>
</li>
</ul>
<h2 id="项目阶段"><a class="header" href="#项目阶段">项目阶段</a></h2>
<ul>
<li>开发阶段主要涉及  <em>feature</em>分支 ，<em>develop</em>分支 </li>
<li>发布阶段主要涉及release分支，<em>production</em> 分支，<em>develop</em> 分支</li>
<li>紧急修复阶段：主要涉及<em>hotfix</em>分支，<em>production</em>分支，<em>develop</em>分支 </li>
</ul>
<h2 id="成员关注点"><a class="header" href="#成员关注点">成员关注点</a></h2>
<ul>
<li>开发人员 关注<em>develop</em> 分支，<em>feature</em>分支，hotfix分支</li>
<li>测试人员关注 <em>release</em>分支，<em>hotfix</em>分支</li>
<li>项目经理关注<em>production</em>分支，<em>release</em>分支</li>
</ul>
<h1 id="实践个完整的git-flow流程"><a class="header" href="#实践个完整的git-flow流程">实践⼀个完整的Git-Flow流程</a></h1>
<pre><code>git init
git add .
git commit -m &quot;project init&quot;
git checkout -b develop master //切换分支时，从master分支创建 develop分支
git checkout -b feature-login develop
git add .
git commit -m &quot;add loginUser.html&quot;
git checkout develop
git merge --no-ff feature-login
git branch -d feature-login
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git-merge简介"><a class="header" href="#git-merge简介">git-merge简介</a></h1>
<p>git-merge命令是用于从指定的commit(s)合并到当前分支的操作。</p>
<p>这里的指定commit(s)是指从这些历史commit节点开始，一直到当前分开的时候。</p>
<h1 id="合并方式"><a class="header" href="#合并方式">合并方式</a></h1>
<p>Git merge的时候，有几种合并方式可以选择</p>
<h2 id="--ff"><a class="header" href="#--ff">--ff</a></h2>
<p>如果能从一个分支的<em>commit</em>  直接 移动 到 被合并分支。则直接 更新 分支的 指针，而不会创建一个合并的提交</p>
<p>这是默认行为，<em>fast-forwar模式</em></p>
<h2 id="--no-ff"><a class="header" href="#--no-ff">--no-ff</a></h2>
<p>即使能 fast-forward也 要 创建一个<em>commit</em></p>
<h2 id="--squash"><a class="header" href="#--squash">--squash</a></h2>
<p>将待合并的 分支与当前分支的 最近共同 的祖先结点 到  待合并的分支 的 head节点的所有 提交压缩成一个</p>
<h2 id="--no-squash"><a class="header" href="#--no-squash">--no-squash</a></h2>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="git设置"><a class="header" href="#git设置">GIT设置</a></h1>
<h1 id="设置客户端中文不显示数字"><a class="header" href="#设置客户端中文不显示数字">设置客户端中文不显示数字</a></h1>
<pre><code>git config --global core.quotepath false
</code></pre>
<h1 id="储藏本地修改"><a class="header" href="#储藏本地修改">储藏本地修改</a></h1>
<pre><code>1. *git fetch &amp;&amp; git merge* 
2. *git stash*储藏本地修改
3. *git stash pop*恢复储藏
</code></pre>
<h1 id="commit操作"><a class="header" href="#commit操作">COMMIT操作</a></h1>
<h2 id="执行回退"><a class="header" href="#执行回退">执行回退</a></h2>
<pre><code class="language-sh">#回退上一版本
git reset --hard HEAD^
git push -f origin master

#回退上上个版本
git reset --hard HEAD^1
</code></pre>
<h2 id="保持跟远程一致"><a class="header" href="#保持跟远程一致">保持跟远程一致</a></h2>
<pre><code class="language-sh">git fetch --all 

git reset --hard origin/dev

git pull
</code></pre>
<h2 id="项目过大时拉取不了git"><a class="header" href="#项目过大时拉取不了git">项目过大时拉取不了GIT</a></h2>
<pre><code>当项目过大时，git clone时会出现error: RPC failed; HTTP 504 curl 22 The requested URL returned error: 504 Gateway Time-out的问题，此时我们可以只下载远程仓库中的最新的一个版本，而不下载其他老版本的内容，这样会大大减小存储与传输压力。


</code></pre>
<pre><code>我们可以在克隆时指定--depth 1，--depth后面的阿拉伯数字代表克隆仓库的最新几个版本，为1代表只克隆远程仓库的最新的一个版本。

</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-sh">git clone --depth 1 https://github.com/dogescript/xxxxxxx.git
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="分支简介"><a class="header" href="#分支简介">分支简介</a></h1>
<ul>
<li>在git中,每一次提交都相当于从当前版本重做一次快照,而分支类似于指针, 指向不同的快照</li>
<li>当前工作目录所处的分支 则是用 head指针 标识</li>
<li>新建分支类似于新建一个指针 指向某一个快照</li>
<li>切换分支 将头指针 移向某一分支指针</li>
</ul>
<h1 id="操作命令"><a class="header" href="#操作命令">操作命令</a></h1>
<pre><code class="language-shell">#新建分支
git branch testing
#分支切换,移动头指针在该分支指针上
git checkout testing
#新建分支自动切换
git checkout -b &lt;newbranchname&gt;
#删除分支
git branch -d hotfix
</code></pre>
<h1 id="分支合并"><a class="header" href="#分支合并">分支合并</a></h1>
<h2 id="命令-1"><a class="header" href="#命令-1">命令</a></h2>
<pre><code class="language-shell">#检出
git checkout master
#合并
git merge iss53
</code></pre>
<ul>
<li>快速合并</li>
</ul>
<p>在合并的时候，你应该注意到了“快进（fast-forward）”这个词</p>
<p>如果master分支 跟 iss53 位于同一链条则 不用进行合并</p>
<p>直接 将 master分支 移动到 iss53分支</p>
<ul>
<li>
<p>三方合并</p>
<p>Git 会使用两个分支的末端所指的快照（<code>C4</code> 和 <code>C5</code>）以</p>
<p>这两个分支的公共祖先（<code>C2</code>），做一个简单的三方合并,</p>
<p>如果没有冲突,则会产生一个合并提交</p>
</li>
</ul>
<h2 id="冲突时的分支合并"><a class="header" href="#冲突时的分支合并">冲突时的分支合并</a></h2>
<ul>
<li>
<p>对同一个文件的同一个部分进行了不同的修改,就会产生冲突此时 Git 做了合并，但是没有自动地创建一个新的合并提交</p>
</li>
<li>
<p><code>git status</code> 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件</p>
</li>
<li>
<p>冲突内容类似 下面</p>
<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html
&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;
=======
&lt;div id=&quot;footer&quot;&gt;
 please contact us at support@github.com
&lt;/div&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html
</code></pre>
<p>要选择 上面下面的一个然后提交</p>
</li>
</ul>
<h1 id="分支管理"><a class="header" href="#分支管理">分支管理</a></h1>
<pre><code class="language-shell">#查看当前分支的最后一次提交
git branch -v
#查看哪些分支已合并到当前分支
git branch --merged
#查看合并的分支 未完成的合并工作
git branch --no-merged

</code></pre>
<h1 id="分支开发工作流"><a class="header" href="#分支开发工作流">分支开发工作流</a></h1>
<p>gitflow</p>
<h1 id="远程分支"><a class="header" href="#远程分支">远程分支</a></h1>
<h2 id="远程跟踪分支"><a class="header" href="#远程跟踪分支">远程跟踪分支</a></h2>
<ul>
<li>
<p>远程跟踪分支是远程分支状态的引用。</p>
</li>
<li>
<p>它们是你无法移动的本地引用。</p>
</li>
<li>
<p>一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。</p>
</li>
<li>
<p>请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。</p>
</li>
<li>
<p>它们以 <code>&lt;remote&gt;/&lt;branch&gt;</code> 的形式命名</p>
</li>
</ul>
<h2 id="git-clone-的操作"><a class="header" href="#git-clone-的操作">git clone 的操作</a></h2>
<h3 id="远程分支的开始"><a class="header" href="#远程分支的开始">远程分支的开始</a></h3>
<ol>
<li>Git 的 <code>clone</code> 命令会为你自动将其命名为 <code>origin</code></li>
<li>拉取它的所有数据， 创建一个指向它的 <code>master</code> 分支的指针,并且在本地将其命名为 <code>origin/master</code>,这个即为远程跟踪分支</li>
<li>也会创建一个本地分支 指向 origin/master</li>
</ol>
<h3 id="远程分支的分叉"><a class="header" href="#远程分支的分叉">远程分支的分叉</a></h3>
<ul>
<li>
<p>你在本地的 <code>master</code> 分支做了一些工作，在同一段时间内有其他人推送提交到 <code>git.ourcompany.com</code> 并且更新了它的 <code>master</code> 分支</p>
</li>
<li>
<p>只要你保持不与 <code>origin</code> 服务器连接（并拉取数据），你的 <code>origin/master</code> 指针就不会移动。</p>
</li>
</ul>
<pre><code class="language-shell">#更新远程跟踪分支   
git fetch  &lt;remote&gt;
#将本地分支与远程分支合并
git merge origin/serverfix
#推送 本地分支 到远程分支
git push origin serverfix
#推送到远程 origin, 将本地serverfix推送到 远程servefix
git push origin serverfix:serverfix

</code></pre>
<h2 id="分支跟踪"><a class="header" href="#分支跟踪">分支跟踪</a></h2>
<p>clone通常会自动地创建一个跟踪 <code>origin/master</code> 的 <code>master</code> 分支</p>
<h3 id="手动跟踪某个分支"><a class="header" href="#手动跟踪某个分支">手动跟踪某个分支</a></h3>
<p>git checkout --track origin/serverfix</p>
<h3 id="checkout捷径"><a class="header" href="#checkout捷径">checkout捷径</a></h3>
<p>如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支：</p>
<pre><code class="language-shell">git checkout serverfix
</code></pre>
<h3 id="自定义分支名称"><a class="header" href="#自定义分支名称">自定义分支名称</a></h3>
<pre><code class="language-shell">git checkout -b sf origin/serverfix
</code></pre>
<h3 id="查看所有设置的跟踪分支"><a class="header" href="#查看所有设置的跟踪分支">查看所有设置的跟踪分支</a></h3>
<pre><code class="language-shell"> git branch -vv
</code></pre>
<h3 id="示例-1"><a class="header" href="#示例-1">示例</a></h3>
<pre><code class="language-shell">$ git branch -vv
  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets
  master    1ae2a45 [origin/master] deploying index fix
* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it
  testing   5ea463a trying something new
</code></pre>
<p><code>iss53</code> </p>
<p>正在跟踪 <code>origin/iss53</code> 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 </p>
<p><code>master</code> </p>
<p>正在跟踪 <code>origin/master</code> 分支并且是最新的。 </p>
<p>serverfix</p>
<p>正在跟踪 <code>teamone</code> 服务器上的 <code>server-fix-good</code> 分支并且领先 3 落后 1， 意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 </p>
<p><code>testing</code> </p>
<p>分支并没有跟踪任何远程分支。</p>
<p>​	需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：</p>
<p><code>git pull</code> 的魔法经常令人困惑所以通常单独显式地使用 <code>fetch</code> 与 <code>merge</code> 命令会更好一些</p>
<pre><code class="language-shell">$ git fetch --all; git branch -vv
</code></pre>
<h2 id="删除远程分支"><a class="header" href="#删除远程分支">删除远程分支</a></h2>
<pre><code class="language-shell"> git push origin --delete serverfix
</code></pre>
<h1 id="变基"><a class="header" href="#变基">变基</a></h1>
<h2 id="merge与rebase原理"><a class="header" href="#merge与rebase原理">merge与rebase原理</a></h2>
<p>个人理解:将该分支的基底基于 某个你想合并的分支</p>
<p>​	在 Git 中整合来自不同分支的修改主要有两种方法：<code>merge</code> 以及 <code>rebase</code>。</p>
<p>​	它的原理是首先找到这两个分支（即当前分支 <code>experiment</code>、变基操作的目标基底分支 <code>master</code>） 的最近共同祖先 <code>C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 <code>C3</code>, 最后以此将之前另存为临时文件的修改依序应用。 （译注：写明了 commit id，以便理解，下同）</p>
<p>​	Merge是基于三方快照 ,合并提交生成最新的一个快照</p>
<p>​	变基:可以使用 <code>rebase</code> 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p>
<p>rebase的过程</p>
<pre><code class="language-shell">git checkout experiment
git rebase master
git checkout master
git merge experiment
</code></pre>
<p><a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA">变基文档</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="拉取远程分支合并到本地分支"><a class="header" href="#拉取远程分支合并到本地分支">拉取远程分支合并到本地分支</a></h2>
<pre><code class="language-shell">git pull origin feature/develop-4.4.0-public
git pull upstream feature/develop-4.4.0-public
</code></pre>
<h2 id="删除未加入到版本管理的文件"><a class="header" href="#删除未加入到版本管理的文件">删除未加入到版本管理的文件</a></h2>
<pre><code class="language-shell">git clean -fd
</code></pre>
<h2 id="将版本库里的head替换工作区与暂存库"><a class="header" href="#将版本库里的head替换工作区与暂存库">将版本库里的head替换工作区与暂存库</a></h2>
<pre><code class="language-shell">git checkout head . 
</code></pre>
<h3 id="不分页"><a class="header" href="#不分页">不分页</a></h3>
<pre><code>git config --global core.pager cat 
</code></pre>
<h3 id="分页"><a class="header" href="#分页">分页</a></h3>
<pre><code>git config --global core.pager less
</code></pre>
<h2 id="bare-repo"><a class="header" href="#bare-repo">bare repo</a></h2>
<pre><code># 只有版本库，没有工作区的仓库。专门用于中心化存储
git init --bare

# 克隆仓库，并作为裸仓库
git clone --mirror https://xxxx
</code></pre>
<h3 id="使用ssh克隆"><a class="header" href="#使用ssh克隆">使用SSH克隆</a></h3>
<pre><code> git clone git+ssh://hap@192.168.1.2/~/working 
  sudo git clone username@12.345.67.891:/home/path/to/repo.git 

</code></pre>
<h3 id="远程跟踪分支信息"><a class="header" href="#远程跟踪分支信息">远程跟踪分支信息</a></h3>
<pre><code>git branch -vv
</code></pre>
<h3 id="git支持的协议"><a class="header" href="#git支持的协议">GIT支持的协议</a></h3>
<pre><code>$ git clone http[s]://example.com/path/to/repo.git
$ git clone http://git.oschina.net/yiibai/sample.git
$ git clone ssh://example.com/path/to/repo.git
$ git clone git://example.com/path/to/repo.git
$ git clone /opt/git/project.git 
$ git clone file:///opt/git/project.git
$ git clone ftp[s]://example.com/path/to/repo.git
$ git clone rsync://example.com/path/to/repo.git
</code></pre>
<h3 id="git显示两个分支的提交差异"><a class="header" href="#git显示两个分支的提交差异">GIT显示两个分支的提交差异</a></h3>
<pre><code># 在 newBranch不在 oldBranch的提交
git log oldBranch..newBranch
git branch oldbranch..newbranch
</code></pre>
<h3 id="git-diff"><a class="header" href="#git-diff">GIT DIFF</a></h3>
<pre><code># diff工具
git difftool
# 比较文件名
git difftool location\filename

## diff 当前版本的文件和某个commit的某个文件
git difftool 3693493981a35c07f2bee7cae71f8e8bd95be625 -- filename


## 
git difftool [start commit]..[end commit] filename

##
git log filename  # 查看某个文件的提交记录

git difftool 6cde26245763dd43f9505c7578a1f7be44b7fad1..8d5336398  -- filename


git diff HEAD^ -- filePath


git diff：是查看 workspace 与 index 的差别的。
git diff --cached：是查看 index 与 local repositorty 的差别的。
git diff HEAD：是查看 workspace 和 local repository 的差别的。（HEAD 指向的是 local repository 中最新提交的版本）
</code></pre>
<p>注：git diff 后跟两个参数，如果只写一个参数，表示默认跟 workspace中的代码作比较。git diff 显示的结果为 第二个参数所指的代码在第一个参数所指代码基础上的修改。如，git diff HEAD 表示 workspace 在 最新commit的基础上所做的修改。</p>
<h3 id="git-difftool"><a class="header" href="#git-difftool">git difftool</a></h3>
<pre><code class="language-shell">git difftool [&lt;options&gt;] [&lt;commit&gt; [&lt;commit&gt;]] [--] [&lt;path&gt;…​]
</code></pre>
<ol>
<li>
<p><code>git difftool</code>是一个 Git 命令，允许您使用常见差异工具在修订之间比较和编辑文件。<code>git difftool</code>是前端<code>git diff</code>并接受相同的选项和参数。参见 git-diff [1]。</p>
<p>-d   --dir-diff   : 将修改后的文件复制到临时位置，然后对它们执行一个目录 diff。该模式在启动 diff 工具之前从不提示。</p>
<p>-y   --no-prompt   :启动 diff 工具前不要提示。</p>
<p>--prompt   :在每次调用 diff 工具前提示。这是默认行为; 该选项用于覆盖任何配置设置。</p>
</li>
</ol>
<pre><code>-t &lt;tool&gt;   --tool=&lt;tool&gt;   
   
使用&lt;tool&gt;指定的 diff 工具。有效值包括 emerge，kompare，meld 和 vimdiff。运行git difftool --tool-help有效的&lt;工具&gt;设置列表。
   
如果没有指定 diff 工具，git difftool将使用配置变量diff.tool。
如果配置变量diff.tool没有设置，git difftool会选择一个合适的默认值。

您可以通过设置配置变量明确提供工具的完整路径difftool.&lt;tool&gt;.path。例如，您可以通过设置配置 kdiff3 的绝对路径difftool.kdiff3.path。否则，git difftool假定该工具在 PATH 中可用。
</code></pre>
<h3 id="不合并特定文件"><a class="header" href="#不合并特定文件">不合并特定文件</a></h3>
<pre><code class="language-shell">echo 'index.php merge=ours' &gt;&gt; .gitattributes
git add .gitattributes
</code></pre>
<h3 id="git-只合并某个目录文件"><a class="header" href="#git-只合并某个目录文件">git 只合并某个目录/文件</a></h3>
<pre><code>git checkout 分支名 目录/** 目录2/**

比如：git checkout pmc dist/**

(目录下可能还有多个目录所以用/** 不用/*，单独只合并某个文件的话，路径准确就行)
</code></pre>
<h3 id="git-设置-合并分支时-忽略某个文件"><a class="header" href="#git-设置-合并分支时-忽略某个文件">git 设置 合并分支时 忽略某个文件</a></h3>
<div style="break-before: page; page-break-before: always;"></div><p><a href="https://git-scm.com/book/zh/">GIT文档官网</a></p>
<h1 id="获取git仓库"><a class="header" href="#获取git仓库">获取GIT仓库</a></h1>
<p>一般有两种方式获取git仓库</p>
<ul>
<li>将尚未进行版本控制的本地目录转换为 Git 仓库；</li>
<li>从其它服务器 <strong>克隆</strong> 一个已存在的 Git 仓库。</li>
</ul>
<h2 id="已存在目录初始化仓库"><a class="header" href="#已存在目录初始化仓库">已存在目录初始化仓库</a></h2>
<pre><code class="language-shell">#初始化
git init
#添加文件
git add *.c
#提交
git commit -m
</code></pre>
<h2 id="远程库克隆"><a class="header" href="#远程库克隆">远程库克隆</a></h2>
<pre><code class="language-shell">git clone &lt;url&gt;
#这会在当前目录下创建一个名为 “libgit2” 的目录
git clone https://github.com/libgit2/libgit2
#自定义目录名
git clone https://github.com/libgit2/libgit2 mylibgit
#使用git协议或者 ssh协议
user@server:path/to/repo.git
</code></pre>
<h1 id="记录文件更新到仓库"><a class="header" href="#记录文件更新到仓库">记录文件更新到仓库</a></h1>
<h2 id="git文件状态"><a class="header" href="#git文件状态">git文件状态</a></h2>
<p>工作目录下的每一个文件都不外乎这两种状态: 已跟踪,未跟踪</p>
<ul>
<li>untracked</li>
<li>unmodified</li>
<li>modified</li>
<li>staged</li>
</ul>
<p>查看状态</p>
<pre><code class="language-shell">git status
#查看紧凑的状态
git status -s
</code></pre>
<h2 id="忽略文件gitignore"><a class="header" href="#忽略文件gitignore">忽略文件.gitignore</a></h2>
<h3 id="gitingore格式规范"><a class="header" href="#gitingore格式规范">gitingore格式规范</a></h3>
<ul>
<li>所有空行或者以 <code>#</code> 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。</li>
<li>匹配模式可以以（<code>/</code>）开头防止递归。</li>
<li>匹配模式可以以（<code>/</code>）结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（<code>!</code>）取反。</li>
</ul>
<h3 id="gitignore-pattern"><a class="header" href="#gitignore-pattern">gitignore pattern</a></h3>
<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。</p>
<ul>
<li>星号匹配任意多个字符</li>
<li>[abc]匹配任何在方括号的字符</li>
<li>? 号一个任意字符</li>
<li>[0-9]表示范围</li>
<li>** 表示匹配任意中间目录 a/**/z</li>
</ul>
<h2 id="对比差异"><a class="header" href="#对比差异">对比差异</a></h2>
<pre><code class="language-shell">#只显示尚未暂存的改动
git diff
#查看已经暂存的变化
git diff --staged
</code></pre>
<h2 id="提交"><a class="header" href="#提交">提交</a></h2>
<pre><code>git commit

//跳过使用暂存区域,自动把所有已经跟踪过的文件暂存起来一并提交
git commit -A
</code></pre>
<h2 id="移除文件"><a class="header" href="#移除文件">移除文件</a></h2>
<pre><code class="language-shell">#删除工作区的改动文件
rm file #暂存区-&gt; untracked
#删除git记录
git rm file 

#保留文件不想让git继续跟踪
git rm --cached file # tracked -&gt; untracked

#强制删除文件
git rm -f filename
</code></pre>
<h2 id="重命名"><a class="header" href="#重命名">重命名</a></h2>
<pre><code>git mv README.md README
命令等价于三个命令

 mv README.md README
 git rm README.md
 git add README
</code></pre>
<h1 id="查看提交历史"><a class="header" href="#查看提交历史">查看提交历史</a></h1>
<h2 id="git-log常用选项"><a class="header" href="#git-log常用选项">git log常用选项</a></h2>
<table><thead><tr><th style="text-align: left">选项</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>-p</code></td><td style="text-align: left">按补丁格式显示每个提交引入的差异。</td></tr>
<tr><td style="text-align: left"><code>--stat</code></td><td style="text-align: left">显示每次提交的文件修改统计信息。</td></tr>
<tr><td style="text-align: left"><code>--shortstat</code></td><td style="text-align: left">只显示 --stat 中最后的行数修改添加移除统计。</td></tr>
<tr><td style="text-align: left"><code>--name-only</code></td><td style="text-align: left">仅在提交信息后显示已修改的文件清单。</td></tr>
<tr><td style="text-align: left"><code>--name-status</code></td><td style="text-align: left">显示新增、修改、删除的文件清单。</td></tr>
<tr><td style="text-align: left"><code>--abbrev-commit</code></td><td style="text-align: left">仅显示 SHA-1 校验和所有 40 个字符中的前几个字符。</td></tr>
<tr><td style="text-align: left"><code>--relative-date</code></td><td style="text-align: left">使用较短的相对时间而不是完整格式显示日期（比如“2 weeks ago”）。</td></tr>
<tr><td style="text-align: left"><code>--graph</code></td><td style="text-align: left">在日志旁以 ASCII 图形显示分支与合并历史。</td></tr>
<tr><td style="text-align: left"><code>--pretty</code></td><td style="text-align: left">使用其他格式显示历史提交信息。可用的选项包括 oneline、short、full、fuller 和 format（用来定义自己的格式）。</td></tr>
<tr><td style="text-align: left"><code>--oneline</code></td><td style="text-align: left"><code>--pretty=oneline --abbrev-commit</code> 合用的简写。</td></tr>
</tbody></table>
<h2 id="pretty-format格式"><a class="header" href="#pretty-format格式">pretty format格式</a></h2>
<pre><code class="language-console"> git log --pretty=format:&quot;%h - %an, %ar : %s&quot;
</code></pre>
<table><thead><tr><th style="text-align: left">选项</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>%H</code></td><td style="text-align: left">提交的完整哈希值</td></tr>
<tr><td style="text-align: left"><code>%h</code></td><td style="text-align: left">提交的简写哈希值</td></tr>
<tr><td style="text-align: left"><code>%T</code></td><td style="text-align: left">树的完整哈希值</td></tr>
<tr><td style="text-align: left"><code>%t</code></td><td style="text-align: left">树的简写哈希值</td></tr>
<tr><td style="text-align: left"><code>%P</code></td><td style="text-align: left">父提交的完整哈希值</td></tr>
<tr><td style="text-align: left"><code>%p</code></td><td style="text-align: left">父提交的简写哈希值</td></tr>
<tr><td style="text-align: left"><code>%an</code></td><td style="text-align: left">作者名字</td></tr>
<tr><td style="text-align: left"><code>%ae</code></td><td style="text-align: left">作者的电子邮件地址</td></tr>
<tr><td style="text-align: left"><code>%ad</code></td><td style="text-align: left">作者修订日期（可以用 --date=选项 来定制格式）</td></tr>
<tr><td style="text-align: left"><code>%ar</code></td><td style="text-align: left">作者修订日期，按多久以前的方式显示</td></tr>
<tr><td style="text-align: left"><code>%cn</code></td><td style="text-align: left">提交者的名字</td></tr>
<tr><td style="text-align: left"><code>%ce</code></td><td style="text-align: left">提交者的电子邮件地址</td></tr>
<tr><td style="text-align: left"><code>%cd</code></td><td style="text-align: left">提交日期</td></tr>
<tr><td style="text-align: left"><code>%cr</code></td><td style="text-align: left">提交日期（距今多长时间）</td></tr>
<tr><td style="text-align: left"><code>%s</code></td><td style="text-align: left">提交说明</td></tr>
</tbody></table>
<h2 id="形象展示分支合并历史"><a class="header" href="#形象展示分支合并历史">形象展示分支合并历史</a></h2>
<pre><code class="language-console"> git log --pretty=format:&quot;%h %s&quot; --graph
</code></pre>
<h2 id="限制输出内容与长度"><a class="header" href="#限制输出内容与长度">限制输出内容与长度</a></h2>
<h3 id="查看最近的2条"><a class="header" href="#查看最近的2条">查看最近的2条</a></h3>
<p><em>git log -2</em> </p>
<h3 id="时间限制"><a class="header" href="#时间限制">时间限制</a></h3>
<ul>
<li>绝对日期</li>
</ul>
<p>可以使用 这个日期 2008-01-15</p>
<ul>
<li>相对日期</li>
</ul>
<p>也可以是类似 <code>&quot;2 years 1 day 3 minutes ago&quot;</code> 的相对日期</p>
<ul>
<li>案例</li>
</ul>
<pre><code class="language-shell">git log --since=2.weeks 最近两周
</code></pre>
<h3 id="作者过滤"><a class="header" href="#作者过滤">作者过滤</a></h3>
<p><em>--author</em></p>
<h3 id="提交说明搜索"><a class="header" href="#提交说明搜索">提交说明搜索</a></h3>
<p><em>--grep</em></p>
<h3 id="pickaxe搜索"><a class="header" href="#pickaxe搜索">pickAXE搜索</a></h3>
<p>只会显示那些添加或删除了该字符串的提交。 </p>
<p>假设你想找出添加或删除了对某一个特定函数的引用的提交，可以调用：</p>
<pre><code class="language-shell">git log -S function_name
</code></pre>
<h3 id="常用限制输出选项"><a class="header" href="#常用限制输出选项">常用限制输出选项</a></h3>
<table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody>
<tr><td><code>-&lt;n&gt;</code></td><td>最近的n条提交</td></tr>
<tr><td>--since<code>, </code>--after</td><td>仅显示指定时间之后的提交。</td></tr>
<tr><td>--until<code>, </code>--before</td><td>仅显示指定时间之前的提交。</td></tr>
<tr><td>--author</td><td>仅显示作者匹配指定字符串的提交。</td></tr>
<tr><td><code>--committer</code></td><td>仅显示提交者匹配指定字符串的提交。</td></tr>
<tr><td><code>--grep</code></td><td>仅显示提交说明中包含指定字符串的提交。</td></tr>
<tr><td><code>-S</code></td><td>仅显示添加或删除内容匹配指定字符串的提交。</td></tr>
</tbody></table>
<h1 id="撤销操作"><a class="header" href="#撤销操作">撤销操作</a></h1>
<h2 id="补漏"><a class="header" href="#补漏">补漏</a></h2>
<ul>
<li>
<p>使用场景</p>
<ul>
<li>有时候我们提交完了才发现漏掉了几个文件没有添加</li>
<li>或者提交信息写错了</li>
</ul>
</li>
<li>
<p>可以运行带有 <code>--amend</code> 选项的提交命令来重新提交：</p>
</li>
<li>
<p>这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改</p>
</li>
<li>
<p>并替换之前的提交日志</p>
</li>
</ul>
<pre><code class="language-shell">git commit --amend -m &quot;&quot;
</code></pre>
<h2 id="取消暂存"><a class="header" href="#取消暂存">取消暂存</a></h2>
<pre><code class="language-shell">#这个命令后续在了解
git reset HEAD CONTRIBUTING.md
#正规用法
git restore --staged &lt;file&gt;...
</code></pre>
<h2 id="撤消对文件的修改"><a class="header" href="#撤消对文件的修改">撤消对文件的修改</a></h2>
<pre><code class="language-shell">git restore &lt;file&gt;...

#用版本库最近的版本去替换当前的文件
git checkout file
</code></pre>
<h1 id="远程仓库的使用"><a class="header" href="#远程仓库的使用">远程仓库的使用</a></h1>
<h2 id="查看已配置的远程仓库"><a class="header" href="#查看已配置的远程仓库">查看已配置的远程仓库</a></h2>
<pre><code class="language-shell">git remote  #默认的名称为 origin
git remote -v #详细
</code></pre>
<h2 id="添加远程仓库"><a class="header" href="#添加远程仓库">添加远程仓库</a></h2>
<pre><code class="language-shell">#配置远程库
git remote add &lt;shortname&gt; &lt;url&gt;
git remote add pb https://github.com/paulboone/ticgit
#拉取代码
git fetch pb

现在 Paul 的 master 分支可以在本地通过 pb/master 访问到
</code></pre>
<h2 id="clone命令的行为"><a class="header" href="#clone命令的行为">clone命令的行为</a></h2>
<p>如果你使用 <code>clone</code> 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写</p>
<p><code>git clone</code> 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 <code>master</code> 分支</p>
<h2 id="gitpull"><a class="header" href="#gitpull">gitpull</a></h2>
<p>如果你的当前分支设置了跟踪远程分支</p>
<p>那么可以用 <code>git pull</code> 命令来自动抓取后合并该远程分支到当前分支</p>
<p>运行 <code>git pull</code> 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p>
<h2 id="推送远程分支"><a class="header" href="#推送远程分支">推送远程分支</a></h2>
<pre><code class="language-shell">git push &lt;remote&gt; &lt;branch&gt;
 git push origin master
</code></pre>
<p>限制</p>
<ul>
<li>只有当你有所克隆服务器的写入权限,并且之前没有人推送过时，这条命令才能生效</li>
<li>当已经有推送时,你必须先抓取他们的工作并将其合并进你的工作后才能推送</li>
</ul>
<h2 id="查看某个远程仓库"><a class="header" href="#查看某个远程仓库">查看某个远程仓库</a></h2>
<pre><code class="language-shell">git remote show origin
</code></pre>
<h2 id="远程仓库的重命名与移除"><a class="header" href="#远程仓库的重命名与移除">远程仓库的重命名与移除</a></h2>
<pre><code class="language-shell"> git remote rename pb paul
 git remote remove paul
</code></pre>
<h1 id="打标签"><a class="header" href="#打标签">打标签</a></h1>
<h2 id="查看标签"><a class="header" href="#查看标签">查看标签</a></h2>
<p>Git 可以给仓库历史中的某一个提交打上标签,使用这个功能来标记发布结点（ <code>v1.0</code> 、 <code>v2.0</code> 等等）</p>
<pre><code class="language-shell">#这个命令以字母顺序列出标签，但是它们显示的顺序并不重要。
git tag
#可以模糊匹配
git tag -l &quot;v1.8.5*&quot;
</code></pre>
<h2 id="创建标签"><a class="header" href="#创建标签">创建标签</a></h2>
<p>git有两种标签</p>
<h2 id="轻量标签"><a class="header" href="#轻量标签">轻量标签</a></h2>
<p>轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。</p>
<pre><code class="language-shell">#不要使用-a, -m -s 等
git tag v1.4-lw
git show v1.4-lw
</code></pre>
<h2 id="附注标签"><a class="header" href="#附注标签">附注标签</a></h2>
<p>​	而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。</p>
<pre><code class="language-shell">git tag -a v1.4 -m &quot;my version 1.4&quot;

git show v1.4
</code></pre>
<h2 id="提交历史打标签"><a class="header" href="#提交历史打标签">提交历史打标签</a></h2>
<pre><code>git log --pretty=oneline
git tag -a v1.2 9fceb02 #部分校验和足够区分
</code></pre>
<h2 id="共享标签"><a class="header" href="#共享标签">共享标签</a></h2>
<p><code>git push</code> 命令并不会传送标签到远程仓库服务器上,在创建完标签后你必须显式地推送标签到共享服务器上。</p>
<pre><code class="language-shell"> git push origin &lt;tagname&gt;
 #把所有不在远程仓库服务器上的标签全部传送到那里。
 git push origin --tags
</code></pre>
<h2 id="删除标签"><a class="header" href="#删除标签">删除标签</a></h2>
<pre><code> git tag -d v1.4-lw
 
 #推送远程仓库
 git push origin :refs/tags/v1.4-lw
  git push origin --delete &lt;tagname&gt;
</code></pre>
<h2 id="检出标签"><a class="header" href="#检出标签">检出标签</a></h2>
<pre><code class="language-shell">git checkout 2.0.0

</code></pre>
<p>仓库处于“分离头指针（detached HEAD）”的状态,如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支：</p>
<h1 id="git别名"><a class="header" href="#git别名">Git别名</a></h1>
<p>通过 <code>git config</code> 文件来轻松地为每一个命令设置一个别名</p>
<pre><code class="language-shell">$ git config --global alias.co checkout
$ git config --global alias.br branch
$ git config --global alias.ci commit
$ git config --global alias.st status
$ git config --global alias.unstage 'reset HEAD --'

$ git unstage fileA
$ git reset HEAD -- fileA
git config --global alias.last 'log -1 HEAD'

#执行外部命令 加上!
git config --global alias.visual '!gitk'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="修改最后一次提交"><a class="header" href="#修改最后一次提交"><strong>修改最后一次提交</strong></a></h1>
<p>修补提交</p>
<pre><code>git commit --amend
</code></pre>
<p><strong>它可以把我们这一次的修改合并到上一条历史记录当中</strong></p>
<h1 id="修改多个信息"><a class="header" href="#修改多个信息"><strong>修改多个信息</strong></a></h1>
<p>--amend虽然好用，但是它只能修改最后一次的提交信息，如果我们想要修改的提交记录在那之前，我们应该怎么办呢？</p>
<p>git当中并没有提供直接的工具来实现这一点，不过我们可以使用<strong>rebase</strong>来达成。我们可以加上-i进行交互式地变基，我们可以在任何想要的修改完成之后停止，也可以添加文件或者是做其他想要做的事情。但是我们变基的目标不是某一个分支而是当前分支的某一个历史节点，所以我们<strong>需要提供一个具体的commitid或者是指针位置</strong>。</p>
<p>git rebase -i的功能非常强大，我们几乎可以使用它来完成所有一切我们想要完成的事情。</p>
<p>比如我们想要修改倒数第二次提交，我们可以执行git rebase -i HEAD~3。也就是以倒数第三个节点作为基准节点执行变基，这时候git会进入一个vim窗口，在这个窗口当中我们可以看到最近的三次提交记录。</p>
<p>首先我们可以看到上面的三行就是我们可以修改的三个commit，分别展示的是要执行的操作以及commitid以及commit message。这里的操作默认的是pick，也就是使用该commit。关于我们可以执行的操作git在下方也给了充分的提示，其中比较常用的有<strong>pick、edit以及squash</strong>。</p>
<p>这一次我们想要做的是修改提交记录，所以我们应该执行edit，我们把想要修改的commit前的pick改成edit。比如这样：</p>
<p>退出之后，git会自动带我们<strong>回到我们选择edit的分支提交之后的版本</strong>。我们进行我们想要的修改，这里我在第15篇文章当中加上了一行：尝试rebase。之后再使用git add以及git commit --amend进行修改提交结果。</p>
<p>再之后我们执行git rebase --continue，把剩下要应用的变更应用完成</p>
<p>一切都结束之后，我们可以使用一下git show命令查看一下我们修改的bee9ce3这个commit的记录。可以看到已经多了这一行，说明我们的修改成功了。</p>
<h1 id="撤回提交"><a class="header" href="#撤回提交">撤回提交</a></h1>
<h2 id="revert撤回"><a class="header" href="#revert撤回">revert撤回</a></h2>
<blockquote>
<p>revert 可以取消指定的某次提交内容，原理是生成相应的提交 抵消</p>
</blockquote>
<h2 id="概述-3"><a class="header" href="#概述-3">概述</a></h2>
<p>当讨论 revert 时，需要分两种情况，因为 commit 分为两种：一种是常规的 commit，也就是使用 <code>git commit</code> 提交的 commit；另一种是 merge commit，在使用 <code>git merge</code> 合并两个分支之后，你将会得到一个新的 merge commit。</p>
<p>merge commit 和普通 commit 的不同之处在于 merge commit 包含两个 parent commit，代表该 merge commit 是从哪两个 commit 合并过来的。</p>
<pre><code class="language-sh">git show bd86846
</code></pre>
<p><strong>revert 常规 commit</strong></p>
<pre><code>`git revert &lt;commit id&gt;` # 即可，git 会生成一个新的 commit，将指定的 commit 内容从当前分支上撤除。
</code></pre>
<p><strong>revert merge commit</strong></p>
<p>revert merge commit 有一些不同，这时需要添加 <code>-m</code> 选项以代表这次 revert 的是一个 merge commit</p>
<p>但如果直接使用 git revert ，git 也不知道到底要撤除哪一条分支上的内容，这时需要指定一个 parent number 标识出&quot;主线&quot;，主线的内容将会保留，而另一条分支的内容将被 revert。</p>
<p>如上面的例子中，从 <code>git show</code> 命令的结果中可以看到，merge commit 的 parent 分别为 ba25a9d 和 1c7036f，其中 ba25a9d 代表 master 分支（从图中可以看出），1c7036f 代表 will-be-revert 分支。需要注意的是 -m 选项接收的参数是一个数字，数字取值为 1 和 2，也就是 Merge 行里面列出来的第一个还是第二个。</p>
<h2 id="reset"><a class="header" href="#reset">reset</a></h2>
<p>记住 合并前的最后一个  commitId，</p>
<h1 id="顺序变更合并拆分"><a class="header" href="#顺序变更合并拆分"><strong>顺序变更、合并、拆分</strong></a></h1>
<h2 id="顺序变更"><a class="header" href="#顺序变更">顺序变更</a></h2>
<p>我们不仅可以修改某一次commit当中的内容，还可以修改这些commit的相对顺序，以及可以让它们合并以及拆分。</p>
<p>修改顺序其实很简单，我们只需要人为地修改rebase -i之后弹出的vim文件即可。比如说原本的记录是：</p>
<pre><code>pick A change A
pick B change B
pick C change C
</code></pre>
<p>如果我们想要更换顺序，我们只需要修改这个文件即可。比如变成：</p>
<pre><code>pick B change B
pick A change A
pick C change C
</code></pre>
<p>那么当我们在退出vim的时候，git会首先应用B commit的变更，再应用A最后应用C。</p>
<h2 id="合并"><a class="header" href="#合并"><strong>合并</strong></a></h2>
<p>除此之外，我们还可以合并多个commit记录成一个。操作的方法也很简单，就是我们只需要把pick修改成squash。git会自动把所有squash的commit记录合并在一起。</p>
<pre><code>pick A change A
squash B change B
squash C change C
</code></pre>
<h2 id="拆分"><a class="header" href="#拆分"><strong>拆分</strong></a></h2>
<p>有的时候一个commit非常巨大，我们可能也会想要将它拆分，其实操作也很简单。比如我们想要把commit B拆分成两条，首先，我们在rebase的时候将commit B前面的pick修改成edit。</p>
<pre><code>pick A change A
edit B change B
pick C change C
</code></pre>
<p>当我们退出的时候，我们会进入到B commit刚刚提交完的状态。由于我们要做的是拆分B这个提交，所以我们需要执行git reset HEAD^，把上一次提交重置。然后再分别add我们想要拆分开来提交的文件。</p>
<p>整个操作如下：</p>
<pre><code>git reset HEAD^
git add test/*
git ci -m 'add test'
git add code/*
git ci -m 'update code'
git rebase --continue
</code></pre>
<p>这样我们就把commit B拆分成了两个commit插入到了历史记录当中了。</p>
<h2 id="注意-1"><a class="header" href="#注意-1">注意</a></h2>
<p>最后的最后，大家需要注意，虽然这些手段在修改记录的时候非常好用。但是如果这些commit已经被提交到了远程，我们是不可以直接git push同步的。因为git会校验我们提交的hash值，发现对不上之后会禁止我们的提交。所以如果想要提交到远程的话，只能使用git push -f强制覆盖。但是<strong>这是一个非常非常危险的操作</strong>，如果你git push -f了，没有人会知道你到底修改了什么，只建议在自己独有的分支上如此操作，一定一定要谨慎使用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="增删改"><a class="header" href="#增删改">增删改</a></h1>
<h2 id="删除本地tag"><a class="header" href="#删除本地tag">删除本地tag</a></h2>
<pre><code>git tag -d tag_1.6.21
</code></pre>
<h2 id="推送删除tag"><a class="header" href="#推送删除tag">推送删除tag</a></h2>
<pre><code>git push origin :refs/tags/tag_1.6.21
git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;
</code></pre>
<h2 id="新建本地tag"><a class="header" href="#新建本地tag">新建本地tag</a></h2>
<pre><code>git tag tag_1.6.23.1

//带注释的标签
git tag -a &lt;tagname&gt; -m &quot;runoob.com标签&quot;
</code></pre>
<h2 id="推送tag"><a class="header" href="#推送tag">推送tag	</a></h2>
<pre><code>git push origin tag_1.6.22.2
</code></pre>
<h2 id="一次性推送所有"><a class="header" href="#一次性推送所有">一次性推送所有</a></h2>
<pre><code>git push origin --tags
</code></pre>
<h1 id="查询"><a class="header" href="#查询">查询</a></h1>
<h2 id="模糊查询"><a class="header" href="#模糊查询">模糊查询</a></h2>
<pre><code class="language-console"> git tag -l &quot;v1.8.5*&quot;
</code></pre>
<h1 id="从tag签出"><a class="header" href="#从tag签出">从Tag签出</a></h1>
<p>如果你想查看一个标签指向的文件的版本，你可以对该标签执行 git checkout，尽管这会使你的存储库处于“detached HEAD”状态，这会产生一些不良的副作用：</p>
<pre><code>git checkout tag_name
git switch -c &lt;new-branch-name&gt;
</code></pre>
<pre><code class="language-console">git checkout -b &lt;branch-name&gt; &lt;tag_name&gt;
git checkout -b version2 v2.0.0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-shell">git reset --hard origin/feature/xxxx-branchname
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="鸡蛋不装在一个篮子里"><a class="header" href="#鸡蛋不装在一个篮子里">鸡蛋不装在一个篮子里</a></h2>
<p>Git的版本库目录和工作区在一起，因此存在一损俱损的问题，即如果删除一个项目的工作区，同时也会把这个项目的版本库删除掉。一个项目仅在一个工作区中维护太危险了，如果有两个工作区就会好很多。</p>
<p>上图中一个项目使用了两个版本库进行维护，两个版本库之间通过拉回（PULL）和/或推送（PUSH）操作实现同步。</p>
<ul>
<li>版本库A通过克隆操作创建克隆版本库B。</li>
<li>版本库A可以通过推送（PUSH）操作，将新提交传递给版本库B；</li>
<li>版本库A可以通过拉回（PULL）操作，将版本库B中的新提交拉回到自身（A）。</li>
</ul>
<p><img src="9.%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86_GIT/../images/git-clone-pull-push.png" alt="" /></p>
<p>Git使用<strong>git clone</strong>命令实现版本库克隆，主要有如下三种用法：</p>
<pre><code>用法1: git clone &lt;repository&gt; &lt;directory&gt;
用法2: git clone --bare   &lt;repository&gt; &lt;directory.git&gt;
用法3: git clone --mirror &lt;repository&gt; &lt;directory.git&gt;
</code></pre>
<p>这三种用法的区别如下：</p>
<ul>
<li>用法1将<code>&lt;repository&gt;</code>指向的版本库创建一个克隆到<code>&lt;directory&gt;</code>目录。目录<code>&lt;directory&gt;</code>相当于克隆版本库的工作区，文件都会检出，版本库位于工作区下的<code>.git</code>目录中。</li>
<li>用法2和用法3创建的克隆版本库都不含工作区，直接就是版本库的内容，这样的版本库称为裸版本库。一般约定俗成裸版本库的目录名以<code>.git</code>为后缀，所以上面示例中将克隆出来的裸版本库目录名写做<code>&lt;directory.git&gt;</code>。</li>
<li>用法3区别于用法2之处在于用法3克隆出来的裸版本对上游版本库进行了注册，这样可以在裸版本库中使用<strong>git fetch</strong>命令和上游版本库进行持续同步。</li>
<li>用法3只在 1.6.0 或更新版本的Git才提供。</li>
</ul>
<p>Git的PUSH和PULL命令的用法相似，使用下面的语法：</p>
<pre><code>git push [&lt;remote-repos&gt; [&lt;refspec&gt;]]
git pull [&lt;remote-repos&gt; [&lt;refspec&gt;]]
</code></pre>
<p>其中方括号的含义是参数可以省略，<code>&lt;remote-repos&gt;</code>是远程版本库的地址或名称，<code>&lt;refspec&gt;</code>是引用表达式，暂时理解为引用即可。在后面的章节再具体介绍PUSH和PULL命令的细节。</p>
<h2 id="对等工作区"><a class="header" href="#对等工作区">对等工作区</a></h2>
<p>不使用<code>--bare</code>或者<code>--mirror</code>创建出来的克隆包含工作区，这样就会产生两个包含工作区的版本库。这两个版本库是对等的</p>
<p><img src="9.%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86_GIT/../images/git-clone-1.png" alt="" /></p>
<p>但是往往提交是在一个版本（A）中进行的，另外一个（B）作为备份。对于这种对等工作区模式，版本库的同步只有一种可行的操作模式</p>
<p>就是在备份库（B）执行 git pull 命令从源版本库（A）拉回新的提交实现版本库同步</p>
<p>为什么不能从版本库A向版本库B执行 git push 的推送操作呢？看看下面的操作。</p>
<p>执行克隆命令，将<strong>版本库</strong><code>/path/to/my/workspace/demo</code>克隆到<code>/path/to/my/workspace/demo-backup</code>。</p>
<pre><code>$ git clone /path/to/my/workspace/demo /path/to/my/workspace/demo-backup
Cloning into /path/to/my/workspace/demo-backup...
done.
</code></pre>
<p>进入 demo 版本库，生成一些测试提交（使用<code>--allow-empty</code>参数可以生成空提交）。</p>
<pre><code>$ cd /path/to/my/workspace/demo/
$ git commit --allow-empty -m &quot;sync test 1&quot;
[master 790e72a] sync test 1
$ git commit --allow-empty -m &quot;sync test 2&quot;
[master f86b7bf] sync test 2
</code></pre>
<p>能够在 demo 版本库向 demo-backup 版本库执行PUSH操作么？</p>
<p>不行：允许向工作区推送已经检出的分支</p>
<p>为了实现同步，需要进入到备份版本库中，执行<strong>git pull</strong>命令。</p>
<pre><code>$ git pull
From /path/to/my/workspace/demo
   6e6753a..f86b7bf  master     -&gt; origin/master
Updating 6e6753a..f86b7bf
Fast-forward
</code></pre>
<p><strong>为什么执行 git pull 拉回命令没有像执行 git push 命令那样提供那么多的参数呢？</strong></p>
<p>这是因为在执行<strong>git clone</strong>操作后，克隆出来的demo-backup版本库中对源版本库（上游版本库）进行了注册</p>
<p>，所以当在 demo-backup 版本库执行拉回操作，无须设置上游版本库的地址。</p>
<p>在 demo-backup 版本库中可以使用下面的命令<strong>查看对上游版本库的注册信息</strong>：</p>
<pre><code>$ cd /path/to/my/workspace/demo-backup
$ git remote -v
origin  /path/to/my/workspace/demo (fetch)
origin  /path/to/my/workspace/demo (push)
</code></pre>
<p>实际注册上游远程版本库的奥秘都在Git的配置文件中（略去无关的行）：</p>
<pre><code>$ cat /path/to/my/workspace/demo-backup/.git/config
...
[remote &quot;origin&quot;]
        fetch = +refs/heads/*:refs/remotes/origin/*
        url = /path/to/my/workspace/demo
[branch &quot;master&quot;]
        remote = origin
        merge = refs/heads/master
</code></pre>
<p>关于配置文件<code>[remote]</code>小节和<code>[branch]</code>小节的奥秘在后面的章节予以介绍。</p>
<h2 id="克隆生成裸版本库"><a class="header" href="#克隆生成裸版本库">克隆生成裸版本库</a></h2>
<p>上一节在对等工作区模式下，工作区之间执行推送，可能会引发大段的错误输出，如果采用裸版本库则没有相应的问题。这是因为裸版本库没有工作区。没有工作区还有一个好处就是空间占用会更小。</p>
<p><img src="9.%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86_GIT/../images/git-clone-2.png" alt="" /></p>
<p>使用<code>--bare</code>参数克隆demo版本库到<code>/path/to/repos/demo.git</code>，然后就可以从 demo 版本库向克隆的裸版本库执行推送操作了</p>
<p>（为了说明方便，使用了<code>/path/to/repos/</code>作为Git裸版本的根路径，在后面的章节中这个目录也作为Git服务器端版本库的根路径。可以在磁盘中以root账户创建该路径并设置正确的权限。）</p>
<pre><code>$ git clone --bare /path/to/my/workspace/demo /path/to/repos/demo.git
Cloning into bare repository /path/to/repos/demo.git...
done.
</code></pre>
<p>克隆出来的<code>/path/to/repos/demo.git</code>目录就是版本库目录，不含工作区。</p>
<ul>
<li>
<p>看看<code>/path/to/repos/demo.git</code>目录的内容。</p>
<pre><code>$ ls -F /path/to/repos/demo.git
branches/  config  description  HEAD  hooks/  info/  objects/  packed-refs  refs/
</code></pre>
</li>
<li>
<p>还可以看到<code>demo.git</code>版本库<code>core.bare</code>的配置为<code>true</code>。</p>
<pre><code>$ git --git-dir=/path/to/repos/demo.git config core.bare
true
</code></pre>
</li>
</ul>
<p>这个方式实现版本库本地镜像显然是更好的方法，因为可以直接在工作区修改、提交，然后执行<strong>git push</strong>命令实现推送。稍有一点遗憾的是推送命令还需要加上裸版本库的路径。这个遗憾在后面介绍远程版本库的章节会给出解决方案。</p>
<h2 id="创建生成裸版本库"><a class="header" href="#创建生成裸版本库">创建生成裸版本库</a></h2>
<p>裸版本库不但可以通过克隆的方式创建，还可以通过<strong>git init</strong>命令以初始化的方式创建。之后的同步方式和上一节大同小异。</p>
<pre><code>$ git init --bare /path/to/repos/demo-init.git
Initialized empty Git repository in /path/to/repos/demo-init.git/
</code></pre>
<p>可是空版本库没有内容啊，那就执行PUSH操作为其创建内容呗。</p>
<pre><code>$ cd /path/to/my/workspace/demo
$ git push /path/to/repos/demo-init.git
No refs in common and none specified; doing nothing.
Perhaps you should specify a branch such as 'master'.
fatal: The remote end hung up unexpectedly
error: failed to push some refs to '/path/to/repos/demo-init.git'
</code></pre>
<pre><code>没有指定要推送的引用，而且两个版本库也没有共同的引用。
所以什么也没有做。
可能您需要提供要推送的分支名，如 'master'。
严重错误：远程操作意外终止
错误：部分引用推送失败，至 '/path/to/repos/demo-init.git'
</code></pre>
<p>关于这个问题详细说明要在后面的章节介绍，这里先说一个省略版：因为<code>/path/to/repos/demo-init.git</code> 版本库刚刚初始化完成，还没有任何提交更不要说分支了</p>
<p>当执行<strong>git push</strong>命令时，如果没有设定推送的分支，而且当前分支也没有注册到远程某个分支</p>
<p>将检查远程分支是否有和本地相同的分支名（如master），如果有，则推送，否则报错。</p>
<p>所以需要把<strong>git push</strong>命令写的再完整一些。像下面这样操作，就可以完成向空的裸版本库的推送。</p>
<pre><code>$ git push /path/to/repos/demo-init.git master:master
</code></pre>
<p>上面的<strong>git push</strong>命令也可以简写为：<strong>git push /pat h/to/repos/demo-init.git master</strong>。</p>
<p>推送成功了么？看看<code>demo-init.git</code>版本库中的提交。</p>
<pre><code>$ git --git-dir=/path/to/repos/demo-init.git log --oneline -2
0285742 sync test 4
d4b42b7 sync test 3
</code></pre>
<p>好了继续在 demo 中执行几次提交。</p>
<pre><code>$ cd /path/to/my/workspace/demo/
$ git commit --allow-empty -m &quot;sync test 5&quot;
[master 424aa67] sync test 5
$ git commit --allow-empty -m &quot;sync test 6&quot;
[master 70a5aa7] sync test 6
</code></pre>
<p>然后再向<code>demo-init.git</code>推送。注意这次使用的命令。</p>
<pre><code>$ git push /path/to/repos/demo-init.git
</code></pre>
<p>为什么这次使用<strong>git push</strong>命令后面没有跟上分支名呢？这是因为远程版本库（demo-init.git）中已经不再是空版本库了，而且有名为master的分支。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="查看提交信息"><a class="header" href="#查看提交信息">查看提交信息</a></h2>
<h3 id="git-rev-parse"><a class="header" href="#git-rev-parse"><strong>git rev-parse</strong></a></h3>
<p>命令<strong>git rev-parse</strong>是Git的一个底层命令，其功能非常丰富（或者说杂乱），很多Git脚本或工具都会用到这条命令。</p>
<p>例如可以显示Git版本库的位置（<code>--git-dir</code>），当前工作区目录的深度（<code>--show-cdup</code>），甚至可以用于被Git无关应用用于解析命令行参数（<code>--parseopt</code>）。</p>
<ul>
<li>
<p>显示分支。</p>
<pre><code>$ git rev-parse --symbolic --branches
</code></pre>
</li>
</ul>
<ul>
<li>
<p>显示里程碑</p>
<pre><code>$ git rev-parse --symbolic --tags
A
B
C
D
E
F
G
H
I
J
</code></pre>
</li>
<li>
<p>显示定义的所有引用</p>
<p>其中<code>refs/remotes/</code>目录下的引用成为远程分支（或远程引用），在后面的章节会予以介绍。</p>
<pre><code>$ git rev-parse --symbolic --glob=refs/*
refs/heads/master
refs/remotes/origin/HEAD
refs/remotes/origin/master
refs/tags/A
refs/tags/B
refs/tags/C
refs/tags/D
refs/tags/E
refs/tags/F
refs/tags/G
refs/tags/H
refs/tags/I
refs/tags/J
</code></pre>
</li>
<li>
<p>命令<strong>git rev-parse</strong>另外一个重要的功能就是将一个Git对象表达式表示为对应的SHA1哈希值</p>
<ul>
<li>
<p>显示HEAD对应的SHA1哈希值。</p>
<pre><code>$ git rev-parse  HEAD
6652a0dce6a5067732c00ef0a220810a7230655e
</code></pre>
</li>
<li>
<p>命令<strong>git describe</strong>的输出也可以显示为SHA1哈希值。</p>
<pre><code>$ git describe
A-1-g6652a0d
$ git rev-parse A-1-g6652a0d
6652a0dce6a5067732c00ef0a220810a7230655e
</code></pre>
</li>
<li>
<p>可以同时显示多个表达式的SHA1哈希值。</p>
<pre><code>$ git rev-parse  master  refs/heads/master
6652a0dce6a5067732c00ef0a220810a7230655e
6652a0dce6a5067732c00ef0a220810a7230655e
</code></pre>
</li>
<li>
<p>可以用哈希值的前几位指代整个哈希值</p>
<pre><code>$ git rev-parse  6652  6652a0d
6652a0dce6a5067732c00ef0a220810a7230655e
6652a0dce6a5067732c00ef0a220810a7230655e
</code></pre>
</li>
<li>
<p>里程碑的两种表示法均指向相同的对象。</p>
<ul>
<li>
<p>里程碑对象不一定是提交，有可能是一个Tag对象。Tag对象包含说明或者签名，还包括到对应提交的指向。</p>
<pre><code>$ git rev-parse  A  refs/tags/A
c9b03a208288aebdbfe8d84aeb984952a16da3f2
c9b03a208288aebdbfe8d84aeb984952a16da3f2

</code></pre>
</li>
<li>
<p>里程碑A指向了一个Tag对象而非提交的时候，用下面的三个表示法都可以指向里程碑对应的提交。</p>
</li>
</ul>
<pre><code>$ git rev-parse  A^{}  A^0  A^{commit}
81993234fc12a325d303eccea20f6fd629412712
81993234fc12a325d303eccea20f6fd629412712
81993234fc12a325d303eccea20f6fd629412712
</code></pre>
</li>
<li>
<p>连续的<code>^</code>符号依次沿着父提交进行定位至某一祖先提交。<code>^</code>后面的数字代表该提交的第几个父提交。</p>
<pre><code>$ git rev-parse  A^^3^2  F^2  J^{}
3252fcce40949a4a622a1ac012cb120d6b340ac8
3252fcce40949a4a622a1ac012cb120d6b340ac8
3252fcce40949a4a622a1ac012cb120d6b340ac8
</code></pre>
</li>
<li>
<p>记号<code>~&lt;n&gt;</code>就相当于连续&lt;n&gt;个符号<code>^</code>。</p>
<pre><code>$ git rev-parse  A~3  A^^^  G^0
e80aa7481beda65ae00e35afc4bc4b171f9b0ebf
e80aa7481beda65ae00e35afc4bc4b171f9b0ebf
e80aa7481beda65ae00e35afc4bc4b171f9b0ebf
</code></pre>
</li>
<li>
<p>显示里程碑A对应的目录树。下面两种写法都可以。</p>
<ul>
<li>
<pre><code>$ git rev-parse  A^{tree}  A:
95ab9e7db14ca113d5548dc20a4872950e8e08c0
95ab9e7db14ca113d5548dc20a4872950e8e08c0
</code></pre>
</li>
</ul>
</li>
<li>
<p>显示树里面的文件，下面两种表示法均可</p>
<pre><code>$ git rev-parse  A^{tree}:src/Makefile  A:src/Makefile
96554c5d4590dbde28183e9a6a3199d526eeb925
96554c5d4590dbde28183e9a6a3199d526eeb925
</code></pre>
</li>
<li>
<p>暂存区里的文件和HEAD中的文件相同</p>
<ul>
<li>
<pre><code>$ git rev-parse  :gitg.png  HEAD:gitg.png
fc58966ccc1e5af24c2c9746196550241bc01c50
fc58966ccc1e5af24c2c9746196550241bc01c50
</code></pre>
</li>
</ul>
</li>
<li>
<p>还可以通过在提交日志中查找字串的方式显示提交。</p>
<pre><code>$ git rev-parse :/&quot;Commit A&quot;
81993234fc12a325d303eccea20f6fd629412712
</code></pre>
</li>
<li>
<p>再有就是reflog相关的语法，参见“Git重置”章节中关于reflog的介绍。</p>
<pre><code>$ git rev-parse HEAD@{0} master@{0}
6652a0dce6a5067732c00ef0a220810a7230655e
6652a0dce6a5067732c00ef0a220810a7230655e
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="版本范围表示法"><a class="header" href="#版本范围表示法">版本范围表示法</a></h3>
<p>有的Git命令可以使用一个版本范围作为参数，命令<strong>git rev-list</strong>可以帮助研究Git的各种版本范围语法。</p>
<p>一个提交ID实际上就可以代表一个版本列表：含义是：<strong>该版本开始的所有历史提交</strong>。</p>
<pre><code>$ git rev-list --oneline  A
8199323 Commit A: merge B with C.
0cd7f2e commit C.
776c5c9 Commit B: merge D with E and F
beb30ca Commit F: merge I with J
212efce Commit D: merge G with H
634836c commit I.
3252fcc commit J.
83be369 commit E.
2ab52ad commit H.
e80aa74 commit G.
</code></pre>
<p><strong>两个或多个版本，相当于每个版本单独使用时指代的列表的并集</strong>。</p>
<pre><code>$ git rev-list --oneline  D  F
beb30ca Commit F: merge I with J
212efce Commit D: merge G with H
634836c commit I.
3252fcc commit J.
2ab52ad commit H.
e80aa74 commit G.
</code></pre>
<p><strong>在一个版本前面加上符号（<code>^</code>）含义是取反，即排除这个版本及其历史版本</strong>。</p>
<pre><code>$ git rev-list --oneline  ^G D
212efce Commit D: merge G with H
2ab52ad commit H.
</code></pre>
<p><strong>和上面等价的“点点”表示法。使用两个点连接两个版本</strong>，如<code>G..D</code>，就相当于<code>^G D</code>。</p>
<pre><code>$ git rev-list --oneline  G..D
212efce Commit D: merge G with H
2ab52ad commit H.
</code></pre>
<p><strong>版本取反，参数的顺序不重要，但是“点点”表示法前后的版本顺序很重要</strong>。</p>
<ul>
<li>
<p>语法：<code>^B C</code></p>
<pre><code>  $ git rev-list --oneline  ^B C
</code></pre>
</li>
</ul>
<p>0cd7f2e commit C</p>
<ul>
<li>
<p>语法：<code>C ^B</code></p>
<pre><code>$ git rev-list --oneline  C ^B
0cd7f2e commit C.
</code></pre>
</li>
<li>
<p>语法：<code>B..C</code>相当于<code>^B C</code></p>
<pre><code>$ git rev-list --oneline  B..C
0cd7f2e commit C.
</code></pre>
</li>
<li>
<p>语法：<code>C..B</code>相当于<code>^C B</code></p>
<pre><code>$ git rev-list --oneline  C..B
776c5c9 Commit B: merge D with E and F
212efce Commit D: merge G with H
83be369 commit E.
2ab52ad commit H.
e80aa74 commit G.
</code></pre>
</li>
</ul>
<p><strong>三点表示法的含义是两个版本共同能够访问到的除外。</strong></p>
<p>B和C共同能够访问到的F、I、J排除在外。</p>
<pre><code>$ git rev-list --oneline  B...C
0cd7f2e commit C.
776c5c9 Commit B: merge D with E and F
212efce Commit D: merge G with H
83be369 commit E.
2ab52ad commit H.
e80aa74 commit G.
</code></pre>
<p>三点表示法，两个版本的前后顺序没有关系。</p>
<p>实际上<code>r1...r2</code>相当于<code>r1 r2 --not $(git merge-base --all r1 r2)</code>，和顺序无关。</p>
<pre><code>$ git rev-list --oneline  C...B
0cd7f2e commit C.
776c5c9 Commit B: merge D with E and F
212efce Commit D: merge G with H
83be369 commit E.
2ab52ad commit H.
e80aa74 commit G.
</code></pre>
<p><strong>某提交的历史提交，自身除外，用语法<code>r1^@</code>表示。</strong></p>
<pre><code>$ git rev-list --oneline  B^@
beb30ca Commit F: merge I with J
212efce Commit D: merge G with H
634836c commit I.
3252fcc commit J.
83be369 commit E.
2ab52ad commit H.
e80aa74 commit G.
</code></pre>
<ul>
<li>
<p>提交本身不包括其历史提交，用语法<code>r1^!</code>表示。</p>
<pre><code>$ git rev-list --oneline  B^!
776c5c9 Commit B: merge D with E and F

$ git rev-list --oneline  F^! D
beb30ca Commit F: merge I with J
212efce Commit D: merge G with H
2ab52ad commit H.
</code></pre>
</li>
</ul>
<h2 id="浏览日志git-log"><a class="header" href="#浏览日志git-log">浏览日志：<strong>git log</strong></a></h2>
<p><strong>参数代表版本范围</strong></p>
<p>当不使用任何参数调用，相当于使用了缺省的参数HEAD，即显示当前HEAD能够访问到的所有历史提交</p>
<pre><code>$ git log --oneline F^! D
beb30ca Commit F: merge I with J
212efce Commit D: merge G with H
2ab52ad commit H.
e80aa74 commit G.
</code></pre>
<p><strong>分支图显示</strong></p>
<p>通过<code>--graph</code>参数调用<strong>git log</strong>可以显示字符界面的提交关系图</p>
<p>而且不同的分支还可以用不同的颜色来表示。如果希望每次查看日志的时候都看到提交关系图，可以设置一个别名，用别名来调用。</p>
<p><strong>显示最近的几条日志</strong></p>
<p>可以使用参数<code>-&lt;n&gt;</code>（<n>为数字），显示最近的<n>条日志。</p>
<p><strong>显示每次提交的具体改动</strong></p>
<p>使用参数<code>-p</code>可以在显示日志的时候同时显示改动。</p>
<p><strong>显示每次提交的变更概要</strong></p>
<p>可以使用<code>--stat</code>参数</p>
<pre><code>$ git log --stat --oneline  I..C
0cd7f2e commit C.
 README    |    1 +
 doc/C.txt |    1 +
 2 files changed, 2 insertions(+), 0 deletions(-)
beb30ca Commit F: merge I with J
3252fcc commit J.
 README           |    7 +++++++
 doc/J.txt        |    1 +
 src/.gitignore   |    3 +++
 src/Makefile     |   27 +++++++++++++++++++++++++++
 src/main.c       |   10 ++++++++++
 src/version.h.in |    6 ++++++
 6 files changed, 54 insertions(+), 0 deletions(-)
</code></pre>
<p><strong>定制输出</strong></p>
<p>Git的差异输出命令提供了很多输出模板提供选择，可以根据需要选择冗余显示或者精简显示。</p>
<ul>
<li>
<p>参数<code>--pretty=raw</code>显示提交的原始数据。可以显示提交对应的树ID。</p>
</li>
<li>
<p>参数<code>--pretty=fuller</code>会同时显示作者和提交者，两者可以不同。</p>
</li>
<li>
<p>参数<code>--pretty=oneline</code>显然会提供最精简的日志输出。也可以使用<code>--oneline</code>参数，效果近似。</p>
</li>
</ul>
<h2 id="差异比较git-diff"><a class="header" href="#差异比较git-diff">差异比较：<strong>git diff</strong></a></h2>
<ul>
<li>比较里程碑B和里程碑A，用命令：<strong>git diff B A</strong></li>
<li>比较工作区和里程碑A，用命令：<strong>git diff A</strong></li>
<li>比较暂存区和里程碑A，用命令：<strong>git diff –cached A</strong></li>
<li>比较工作区和暂存区，用命令：<strong>git diff</strong></li>
<li>比较暂存区和HEAD，用命令：<strong>git diff –cached</strong></li>
<li>比较工作区和HEAD，用命令：<strong>git diff HEAD</strong></li>
</ul>
<p><strong>Git中文件在版本间的差异比较</strong></p>
<p>差异比较还可以使用路径参数，只显示不同版本间该路径下文件的差异。语法格式：</p>
<p><strong>非Git目录/文件的差异比较</strong></p>
<p>命令<strong>git diff</strong>还可以在Git版本库之外执行，对非Git目录进行比较，就像GNU的<strong>diff</strong>命令一样。之所以提供这个功能是因为Git差异比较命令更为强大，提供了对GNU差异比较的扩展支持。</p>
<pre><code>$ git diff &lt;path1&gt; &lt;path2&gt;
</code></pre>
<p><strong>扩展的差异语法</strong></p>
<p>Git扩展了GNU的差异比较语法，提供了对重命名、二进制文件、文件权限变更的支持。在后面的“Git应用”辟专题介绍二进制文件的差异比较和补丁的应用。</p>
<p><strong>逐词比较，而非缺省的逐行比较</strong></p>
<p>Git的差异比较缺省是逐行比较，分别显示改动前的行和改动后的行，到底改动哪里还需要仔细辨别</p>
<p>Git还提供一种逐词比较的输出，有的人会更喜欢。使用<code>--word-diff</code>参数可以显示逐词比较。</p>
<h2 id="文件追溯git-blame"><a class="header" href="#文件追溯git-blame">文件追溯：<strong>git blame</strong></a></h2>
<p>Git的文件追溯命令可以指出是谁在什么时候，什么版本引入的此Bug。</p>
<p>当针对文件执行<strong>git blame</strong>命令，就会逐行显示文件，在每一行的行首显示此行最早是在什么版本引入的，由谁引入。</p>
<p>只想查看某几行，使用<code>-L n,m</code>参数，如下：</p>
<pre><code>$ git blame -L 6,+5 README
81993234 (Jiang Xin 2010-12-09 14:30:15 +0800  6) * create node A.
0cd7f2ea (Jiang Xin 2010-12-09 14:29:09 +0800  7) * create node C.
</code></pre>
<h2 id="二分查找git-bisect"><a class="header" href="#二分查找git-bisect">二分查找：<strong>git bisect</strong></a></h2>
<p>前面的文件追溯是建立在问题（Bug）已经定位（到代码上）的基础之上，然后才能通过错误的行（代码）找到人（提交者），打板子（教育或惩罚）。那么如何定位问题呢？Git的二分查找命令可以提供帮助。</p>
<p>Git提供的<strong>git bisect</strong>命令是基于版本库的，自动化的问题查找和定位工作流程</p>
<p>取代传统软件测试中粗放式的、针对软件发布版本的、无法定位到代码的测试。</p>
<p>执行二分查找，在发现问题后，首先要找到一个正确的版本，如果所发现的问题从软件最早的版本就是错的，那么就没有必要执行二分查找了，还是老老实实的Debug吧</p>
<p>但是如果能够找到一个正确的版本，即在这个正确的版本上问题没有发生，那么就可以开始使用<strong>git bisect</strong>命令在版本库中进行二分查找了：</p>
<ol>
<li>工作区切换到已知的“好版本”和“坏版本”的中间的一个版本</li>
<li>执行测试，问题重现，将版本库当前版本库为“坏版本”，如果问题没有重现，将当前版本标记为“好版本”。</li>
<li>重复1-2，直至最终找到第一个导致问题出现的版本。</li>
</ol>
<p><strong>example</strong></p>
<p>下面开始通过手动测试（查找<code>doc/B.txt</code>存在与否），借助Git二分查找定位“问题”版本。</p>
<ul>
<li>
<p>首先确认工作在master分支。</p>
<pre><code>$ cd /path/to/my/workspace/gitdemo-commit-tree/
$ git checkout master
Already on 'master'
</code></pre>
</li>
<li>
<p>开始二分查找。</p>
<pre><code>$ git bisect start
</code></pre>
</li>
<li>
<p>已经当前版本是“坏提交”，因为存在文件<code>doc/B.txt</code>。而G版本是“好提交”，因为不存在文件<code>doc/B.txt</code>。</p>
<pre><code>$ git cat-file -t master:doc/B.txt
blob
$ git cat-file -t G:doc/B.txt
fatal: Not a valid object name G:doc/B.txt
</code></pre>
</li>
<li>
<p>将当前版本（HEAD）标记为“坏提交”，将G版本标记为“好提交”。</p>
<pre><code>$ git bisect bad
$ git bisect good G
Bisecting: 5 revisions left to test after this (roughly 2 steps)
[0cd7f2ea245d90d414e502467ac749f36aa32cc4] commit C.
</code></pre>
</li>
<li>
<p>自动定位到C提交。没有文件<code>doc/B.txt</code>，也是一个好提交。</p>
<pre><code>$ git describe
C
$ ls doc/B.txt
ls: 无法访问doc/B.txt: 没有那个文件或目录
</code></pre>
</li>
<li>
<p>标记当前版本（C提交）为“好提交”。</p>
<pre><code>$ git bisect good
Bisecting: 3 revisions left to test after this (roughly 2 steps)
[212efce1548795a1edb08e3708a50989fcd73cce] Commit D: merge G with H
</code></pre>
</li>
<li>
<p>现在定位到D版本，这也是一个“好提交”。</p>
<pre><code>$ git describe
D
$ ls doc/B.txt
ls: 无法访问doc/B.txt: 没有那个文件或目录
</code></pre>
</li>
<li>
<p>标记当前版本（D提交）为“好提交”。</p>
<pre><code>$ git bisect good
Bisecting: 1 revision left to test after this (roughly 1 step)
[776c5c9da9dcbb7e463c061d965ea47e73853b6e] Commit B: merge D with E and F
</code></pre>
</li>
<li>
<p>现在定位到B版本，这是一个“坏提交”。</p>
<pre><code>$ git bisect bad
Bisecting: 0 revisions left to test after this (roughly 0 steps)
[83be36956c007d7bfffe13805dd2081839fd3603] commit E.
</code></pre>
</li>
<li>
<p>现在定位到E版本，这是一个“好提交”。当标记E为好提交之后，输出显示已经成功定位到引入坏提交的最接近的版本。</p>
<pre><code>$ git bisect good
776c5c9da9dcbb7e463c061d965ea47e73853b6e is the first bad commit
</code></pre>
</li>
<li>
<p>最终定位的坏提交用引用<code>refs/bisect/bad</code>标识。可以如下方法切换到该版本。</p>
<pre><code>$ git checkout bisect/bad
Previous HEAD position was 83be369... commit E.
HEAD is now at 776c5c9... Commit B: merge D with E and F
</code></pre>
</li>
<li>
<p>当对“Bug”定位和修复后，撤销二分查找在版本库中遗留的临时文件和引用。</p>
<p>撤销二分查找后，版本库切换回执行二分查找之前所在的分支。</p>
<pre><code>$ git bisect reset
Previous HEAD position was 776c5c9... Commit B: merge D with E and F
Switched to branch 'master'
</code></pre>
</li>
</ul>
<p><strong>把“好提交”标记成了“坏提交”该怎么办？</strong></p>
<p>在执行二分查找的过程中，一不小心就有可能犯错，将“好提交”标记为“坏提交”，或者相反。这将导致前面的查找过程也前功尽弃。Git的二分查找提供一个恢复查找进度的办法。</p>
<ul>
<li>
<p>例如对E提交，本来是一个“好版本”却被错误的标记为“坏版本”。</p>
<pre><code>$ git bisect bad
83be36956c007d7bfffe13805dd2081839fd3603 is the first bad commit
</code></pre>
</li>
<li>
<p>用<strong>git bisect log</strong>命令查看二分查找的日志记录。</p>
<p>把二分查找的日志保存在一个文件中。</p>
<pre><code>$ git bisect log &gt; logfile
</code></pre>
</li>
<li>
<p>编辑这个文件，删除记录了错误动作的行。</p>
<p>以井号（#）开始的行是注释。</p>
<pre><code>$ cat logfile
# bad: [6652a0dce6a5067732c00ef0a220810a7230655e] Add Images for git treeview.
# good: [e80aa7481beda65ae00e35afc4bc4b171f9b0ebf] commit G.
git bisect start 'master' 'G'
# good: [0cd7f2ea245d90d414e502467ac749f36aa32cc4] commit C.
git bisect good 0cd7f2ea245d90d414e502467ac749f36aa32cc4
# good: [212efce1548795a1edb08e3708a50989fcd73cce] Commit D: merge G with H
git bisect good 212efce1548795a1edb08e3708a50989fcd73cce
# bad: [776c5c9da9dcbb7e463c061d965ea47e73853b6e] Commit B: merge D with E and F
git bisect bad 776c5c9da9dcbb7e463c061d965ea47e73853b6e
</code></pre>
</li>
<li>
<p>结束上一次出错的二分查找。</p>
<pre><code>$ git bisect reset
Previous HEAD position was 83be369... commit E.
Switched to branch 'master'
</code></pre>
</li>
<li>
<p>通过日志文件恢复进度。</p>
<pre><code>$ git bisect replay logfile
We are not bisecting.
Bisecting: 5 revisions left to test after this (roughly 2 steps)
[0cd7f2ea245d90d414e502467ac749f36aa32cc4] commit C.
Bisecting: 0 revisions left to test after this (roughly 0 steps)
[83be36956c007d7bfffe13805dd2081839fd3603] commit E.
</code></pre>
</li>
<li>
<p>再一次回到了提交E，这一次不要标记错了。</p>
<pre><code>$ git describe
E
$ git bisect good
776c5c9da9dcbb7e463c061d965ea47e73853b6e is the first bad commit
</code></pre>
</li>
</ul>
<p><strong>二分查找使用自动化测试</strong></p>
<p>Git的二分查找命令支持<code>run</code>子命令，可以运行一个自动化测试脚本。</p>
<ul>
<li>如果脚本的退出码是0，正在测试的版本是一个“好版本”。</li>
<li>如果脚本的退出码是125，正在测试的版本被跳过。</li>
<li>如果脚本的退出码是1到127（125除外），正在测试的版本是一个“坏版本”。</li>
</ul>
<p>对于本例写一个自动化测试太简单了，无非就是判断文件是否存在，存在返回错误码1，不存在返回错误码0。</p>
<p>测试脚本<code>good-or-bad.sh</code>如下：</p>
<pre><code class="language-sh">#!/bin/sh

[ -f doc/B.txt ] &amp;&amp; exit 1
exit 0
</code></pre>
<p>用此自动化脚本执行二分查找就非常简单了。</p>
<ul>
<li>
<p>从已知的坏版本master和好版本G，开始新一轮的二分查找。</p>
<pre><code>$ git bisect start master G
Bisecting: 5 revisions left to test after this (roughly 2 steps)
[0cd7f2ea245d90d414e502467ac749f36aa32cc4] commit C.
</code></pre>
</li>
<li>
<p>自动化测试，使用脚本<code>good-or-bad.sh</code>。</p>
<pre><code>$ git bisect run sh good-or-bad.sh
running sh good-or-bad.sh
Bisecting: 3 revisions left to test after this (roughly 2 steps)
[212efce1548795a1edb08e3708a50989fcd73cce] Commit D: merge G with H
running sh good-or-bad.sh
Bisecting: 1 revision left to test after this (roughly 1 step)
[776c5c9da9dcbb7e463c061d965ea47e73853b6e] Commit B: merge D with E and F
running sh good-or-bad.sh
Bisecting: 0 revisions left to test after this (roughly 0 steps)
[83be36956c007d7bfffe13805dd2081839fd3603] commit E.
running sh good-or-bad.sh
776c5c9da9dcbb7e463c061d965ea47e73853b6e is the first bad commit
bisect run success
</code></pre>
</li>
<li>
<p>定位到的“坏版本”是B。</p>
<pre><code>$ git describe refs/bisect/bad
B
</code></pre>
</li>
</ul>
<h2 id="获取历史版本"><a class="header" href="#获取历史版本">获取历史版本</a></h2>
<p>提取历史提交中的文件无非就是下面表格中的操作，在之前的实践中多次用到，不再赘述。</p>
<table><thead><tr><th style="text-align: left">动作</th><th style="text-align: left">命令格式</th><th style="text-align: left">示例</th></tr></thead><tbody>
<tr><td style="text-align: left">查看历史提交的目录树</td><td style="text-align: left">git ls-tree &lt;tree-ish&gt; &lt;paths&gt;</td><td style="text-align: left">git ls-tree 776c5c9 READMEgit ls-tree -r refs/tags/D doc</td></tr>
<tr><td style="text-align: left">整个工作区切换到历史版本</td><td style="text-align: left">git checkout <commit></td><td style="text-align: left">git checkout HEAD^^</td></tr>
<tr><td style="text-align: left">检出某文件的历史版本</td><td style="text-align: left">git checkout <commit> – <paths></td><td style="text-align: left">git checkout refs/tags/D – READMEgit checkout 776c5c9 – doc</td></tr>
<tr><td style="text-align: left">检出某文件的历史版本到其他文件名</td><td style="text-align: left">git show &lt;commit&gt;:&lt;file&gt; &gt; new_name</td><td style="text-align: left">git show 887113d:README &gt; README.OLD</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h3 id="回退合并提交"><a class="header" href="#回退合并提交">回退合并提交</a></h3>
<pre><code class="language-powershell">git revert --merge &lt;需要撤的merge提交码&gt; -m 1
</code></pre>
<ol>
<li>其中 <strong>-m</strong> 指定回退到合并时两个提交里哪一个</li>
</ol>
<h4 id="假设某个合并提交详情如下"><a class="header" href="#假设某个合并提交详情如下">假设某个合并提交详情如下：</a></h4>
<pre><code class="language-text">commit 38eccd547e5dfeb4bc7d3f6988824177f9474214
Merge: 92909 418db
Author: Foo Bar &lt;test@example.com&gt;
Date:   Tue Dec 7 10:23:33 2021 +0100

Merge branch 'test'
</code></pre>
<ol>
<li>
<p><strong>-m 1</strong> 表示撤销 merge 并回退到92909这个提交上</p>
</li>
<li>
<p><strong>-m 2</strong> 表示撤销 merge 并回退到418db这个提交上</p>
</li>
</ol>
<p><strong>git revert 会有历史记录</strong></p>
<h3 id="使用-git-reset"><a class="header" href="#使用-git-reset">使用 git reset</a></h3>
<ol>
<li>查看合并提交的 提交ID</li>
</ol>
<pre><code>commit 38eccd547e5dfeb4bc7d3f6988824177f9474214
Merge: 92909 418db
</code></pre>
<ol start="2">
<li>
<p>git reset --hard</p>
<pre><code>git reset --hard 92909
</code></pre>
</li>
<li>
<p>一般左边的ID是 目标合并分支，右边的ID是 源合并分支</p>
</li>
<li>
<p>git reset 是直接改变 head指针</p>
</li>
<li>
<p>如果跟远程库不一致 则可能需要强制push</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tag"><a class="header" href="#tag">Tag</a></h2>
<p>马上就要和之前实践遗留的数据告别了，告别之前是不是要留个影呢？在Git里，“留影”用的命令叫做<strong>tag</strong>，更加专业的术语叫做“里程碑”（打tag，或打标签）。</p>
<pre><code>$ cd /path/to/my/workspace/demo
$ git tag -m &quot;Say bye-bye to all previous practice.&quot; old_practice
</code></pre>
<p>只要知道里程碑无非也是一个引用，通过记录提交ID（或者创建Tag对象）来为当前版本库状态进行“留影”。</p>
<p>可以执行<strong>git describe</strong>命令显示当前版本库的最新提交的版本号</p>
<ul>
<li>显示的时候会选取离该提交最近的里程碑作为“基础版本号”，</li>
<li>后面附加标识距离“基础版本”的数字以及该提交的SHA1哈希值缩写</li>
<li>因为最新的提交上恰好被打了一个“里程碑”，所以用“里程碑”的名字显示为版本号</li>
</ul>
<h2 id="删除文件"><a class="header" href="#删除文件">删除文件</a></h2>
<h3 id="本地删除"><a class="header" href="#本地删除">本地删除</a></h3>
<pre><code class="language-sh">rm *.txt
</code></pre>
<p><strong>直接在工作区删除，对暂存区和版本库没有任何影响</strong></p>
<p>**git checkout – <file>**可以让文件在工作区重现</p>
<h3 id="执行git-rm命令删除文件"><a class="header" href="#执行git-rm命令删除文件">执行<strong>git rm</strong>命令删除文件</a></h3>
<p>删除动作直接加入了暂存区</p>
<pre><code class="language-shell">$ git rm detached-commit.txt hack-1.txt new-commit.txt welcome.txt
</code></pre>
<h3 id="命令git-add--u"><a class="header" href="#命令git-add--u">命令git add -u</a></h3>
<p>含义是将本地有改动（包括添加和删除）的文件写入到暂存区</p>
<h2 id="恢复删除的文件"><a class="header" href="#恢复删除的文件">恢复删除的文件</a></h2>
<p>执行下面的命令可以从历史（前一次提交）中恢复<code>welcome.txt</code>文件。</p>
<pre><code class="language-shell">$ git cat-file -p HEAD~1:welcome.txt &gt; welcome.txt
</code></pre>
<p>通过再次添加的方式恢复被删除的文件是最自然的恢复的方法。其他版本控制系统如CVS也采用同样的方法恢复删除的文件，但是有的版本控制系统如Subversion如果这样操作会有严重的副作用——<strong>文件变更历史被人为的割裂而且还会造成服务器存储空间的浪费</strong>。Git通过添加方式反删除文件没有副作用，这是因为在Git的版本库中<strong>相同内容的文件保存在一个blob对象中</strong>，而且即便是内容不同的blob对象在对象库打包整理过程中也会通过差异比较优化存储。</p>
<h2 id="移动文件"><a class="header" href="#移动文件">移动文件</a></h2>
<p>通过将<code>welcome.txt</code>改名为<code>README</code>文件来测试一下在Git中如何移动文件。Git提供了<strong>git mv</strong>命令完成改名操作。</p>
<pre><code>$ git mv welcome.txt README
</code></pre>
<p>从提交日志中出现的文件相似度可以看出Git的改名实际上源自于Git对文件追踪的强大支持（文件内容作为blob对象保存在对象库中）</p>
<p>改名操作实际上相当于对旧文件执行删除，对新文件执行添加，即完全可以不使用<strong>git mv</strong>操作，而是代之以<strong>git rm</strong>和一个<strong>git add</strong>操作。</p>
<pre><code>$ mv welcome.txt README
$ git status -s
 D welcome.txt
?? README
</code></pre>
<h2 id="一个显示版本号的hello-world"><a class="header" href="#一个显示版本号的hello-world">一个显示版本号的<code>Hello World</code></a></h2>
<p>在本章的一开始为纪念前面的实践留了一个影，叫做<code>old_practice</code>。现在再次执行<strong>git describe</strong>看一下现在的版本号。</p>
<pre><code>$ git describe
old_practice-3-gc024f34
</code></pre>
<p>就是说：当前工作区的版本是“留影”后的第三个版本，提交ID是<code>c024f34</code>。</p>
<p>下面的命令可以在提交日志中显示提交对应的里程碑（Tag）。其中参数<code>--decorate</code>可以在提交ID的旁边显示该提交关联的引用（里程碑或分支）。</p>
<pre><code>$ git log --oneline --decorate -4
c024f34 (HEAD, master) README is from welcome.txt.
63992f0 restore file: welcome.txt
7161977 delete trash files. (using: git add -u)
2b31c19 (tag: old_practice) Merge commit 'acc2f69'
</code></pre>
<p>命令<strong>git describe</strong>的输出可以作为软件版本号，这个功能非常有用。因为这样可以很容易的实现将发布的软件包版本和版本库中的代码对应在一起，当发现软件包包含Bug时，可以最快、最准确的对应到代码上。</p>
<p>下面的<code>Hello World</code>程序就实现了这个功能。创建目录<code>src</code>，并在<code>src</code>目录下创建下面的三个文件：</p>
<ul>
<li>
<p>文件：<code>src/main.c</code></p>
<p>没错，下面的几行就是这个程序的主代码，和输出相关代码的就两行，一行显示“Hello, world.”，另外一行显示软件版本。在显示软件版本时用到了宏<code>_VERSION</code>，这个宏的来源参考下一个文件。</p>
<p>源代码：</p>
<blockquote>
<pre><code>#include &quot;version.h&quot;
#include &lt;stdio.h&gt;

int
main()
{
    printf( &quot;Hello, world.\n&quot; );
    printf( &quot;version: %s.\n&quot;, _VERSION );
    return 0;
}
</code></pre>
</blockquote>
</li>
<li>
<p>文件：<code>src/version.h.in</code></p>
<p>没错，这个文件名的后缀是<code>.h.in</code>。这个文件其实是用于生成文件<code>version.h</code>的模板文件。在由此模板文件生成的<code>version.h</code>的过程中，宏<code>_VERSION</code>的值 “<version>” 会动态替换。</p>
<p>源代码：</p>
<blockquote>
<pre><code>#ifndef HELLO_WORLD_VERSION_H
#define HELLO_WORLD_VERSION_H

#define _VERSION &quot;&lt;version&gt;&quot;

#endif
</code></pre>
</blockquote>
</li>
<li>
<p>文件：<code>src/Makefile</code></p>
<p>这个文件看起来很复杂，而且要注意所有缩进都是使用一个<code>&lt;Tab&gt;</code>键完成的缩进，千万不要错误的写成空格，因为这是<code>Makefile</code>。这个文件除了定义如何由代码生成可执行文件<code>hello</code>之外，还定义了如何将模板文件<code>version.h.in</code>转换为<code>version.h</code>。在转换过程中用<strong>git describe</strong>命令的输出替换模板文件中的<code>&lt;version&gt;</code>字符串。</p>
<p>源代码：</p>
<blockquote>
<pre><code>OBJECTS = main.o
TARGET = hello

all: $(TARGET)

$(TARGET): $(OBJECTS)
        $(CC) -o $@ $^

main.o: | new_header
main.o: version.h

new_header:
        @sed -e &quot;s/&lt;version&gt;/$$(git describe)/g&quot; \
                &lt; version.h.in &gt; version.h.tmp
        @if diff -q version.h.tmp version.h &gt;/dev/null 2&gt;&amp;1; \
        then \
                rm version.h.tmp; \
        else \
                echo &quot;version.h.in =&gt; version.h&quot; ; \
                mv version.h.tmp version.h; \
        fi

clean:
        rm -f $(TARGET) $(OBJECTS) version.h

.PHONY: all clean
</code></pre>
</blockquote>
</li>
</ul>
<p>上述三个文件创建完毕之后，进入到<code>src</code>目录，试着运行一下。先执行<strong>make</strong>编译，再运行编译后的程序<strong>hello</strong>。</p>
<pre><code>$ cd src
$ make
version.h.in =&gt; version.h
cc    -c -o main.o main.c
cc -o hello main.o
$ ./hello
Hello, world.
version: old_practice-3-gc024f34.
</code></pre>
<h2 id="使用git-add--i选择性添加"><a class="header" href="#使用git-add--i选择性添加">使用<strong>git add -i</strong>选择性添加</a></h2>
<p>执行<strong>git add -i</strong>命令，进入一个交互式界面，首先显示的是工作区状态。显然因为版本库进行了清理，所以显得很“干净”。</p>
<h2 id="文件忽略"><a class="header" href="#文件忽略">文件忽略</a></h2>
<p>执行下面的命令可以在这个目下创建一个名为<code>.gitignore</code>的文件（注意文件的前面有个点），把这些要忽略的文件写在其中，文件名可以使用通配符。注意：第2行到第5行开头的右尖括号是<strong>cat</strong>命令的提示符，不是输入。</p>
<pre><code>$ cat &gt; .gitignore &lt;&lt; EOF
&gt; hello
&gt; *.o
&gt; *.h
&gt; EOF
</code></pre>
<p>文件<code>.gitignore</code>的作用范围是其所处的目录及其子目录，因此如果把刚刚创建的<code>.gitignore</code>移动到上一层目录（仍位于工作区内）也应该有效。</p>
<p>只有使用了<code>--ignored</code>参数，才会在状态显示中看到被忽略的文件。</p>
<pre><code>$ git status --ignored -s
!! hello
!! hello.h
!! main.o
!! version.h
</code></pre>
<h3 id="忽略只对未跟踪文件有效对于已加入版本库的文件无效"><a class="header" href="#忽略只对未跟踪文件有效对于已加入版本库的文件无效"><strong>忽略只对未跟踪文件有效，对于已加入版本库的文件无效</strong></a></h3>
<p>文件<code>hello.h</code>添加到版本库后，就不再受到<code>.gitignore</code>设置的文件忽略影响了，对<code>hello.h</code>的修改都会立刻被跟踪到。这是因为Git的文件忽略只是对未入库的文件起作用。</p>
<p>偷懒式提交。（使用了<code>-a</code>参数提交，不用预先执行<strong>git add</strong>命令。）</p>
<h3 id="本地独享式忽略文件"><a class="header" href="#本地独享式忽略文件"><strong>本地独享式忽略文件</strong></a></h3>
<ul>
<li>一种是针对具体版本库的“独享式”忽略。即在版本库<code>.git</code>目录下的一个文件<code>.git/info/exclude</code>来设置文件忽略。</li>
<li>另外一种是全局的“独享式”忽略。即通过Git的配置变量<code>core.excludesfile</code>指定的一个忽略文件，其设置的忽略对所有文件均有效。</li>
</ul>
<p>例如本地设置一个全局的独享的文件忽略列表（这个文件名可以随意设置）：</p>
<pre><code>$ git config --global core.excludesfile /home/jiangxin/_gitignore
$ git config core.excludesfile
/home/jiangxin/_gitignore
$ cat /home/jiangxin/_gitignore
*~        # vim 临时文件
*.pyc     # python 的编译文件
.*.mmx    # 不是正则表达式哦，因为 FreeMind-MMX 的辅助文件以点开头
</code></pre>
<h3 id="git忽略语法"><a class="header" href="#git忽略语法"><strong>Git忽略语法</strong></a></h3>
<ul>
<li>忽略文件中的空行或者以井号（#）开始的行被忽略。</li>
<li>可以使用通配符，参见Linux手册：glob(7)。例如：星号（*）代表任意多字符，问号（?）代表一个字符，方括号（[abc]）代表可选字符范围等。</li>
<li>如果名称的最前面是一个路径分隔符（/），表明要忽略的文件在此目录下，而非子目录的文件。</li>
<li>如果名称的最后面是一个路径分隔符（/），表明要忽略的是整个目录，同名文件不忽略，否则同名的文件和目录都忽略。</li>
<li>通过在名称的最前面添加一个感叹号（!），代表不忽略。</li>
</ul>
<pre><code># 这是注释行 —— 被忽略
*.a       # 忽略所有以 .a 为扩展名的文件。
!lib.a    # 但是 lib.a 文件或者目录不要忽略，即使前面设置了对 *.a 的忽略。
/TODO     # 只忽略根目录下的 TODO 文件，子目录的 TODO 文件不忽略。
build/    # 忽略所有 build/ 目录下的文件。
doc/*.txt # 忽略文件如 doc/notes.txt，但是文件如 doc/server/arch.txt 不被忽略。
</code></pre>
<h2 id="文件归档"><a class="header" href="#文件归档">文件归档</a></h2>
<p>如果使用压缩工具（tar、7zip、winzip、rar等）将工作区文件归档，一不小心会把版本库（<code>.git</code>目录）包含其中，甚至将工作区中的忽略文件、临时文件也包含其中</p>
<p>Git提供了一个归档命令：<strong>git archive</strong>，可以对任意提交对应的目录树建立归档。</p>
<ul>
<li>
<p>基于最新提交建立归档文件<code>latest.zip</code>。</p>
<pre><code>$ git archive -o latest.zip HEAD
</code></pre>
</li>
<li>
<p>只将目录<code>src</code>和<code>doc</code>建立到归档<code>partial.tar</code>中。</p>
<pre><code>$ git archive -o partial.tar  HEAD src doc
</code></pre>
</li>
<li>
<p>基于里程碑v1.0建立归档，并且为归档中文件添加目录前缀1.0。</p>
<pre><code>$ git archive --format=tar --prefix=1.0/ v1.0 | gzip &gt; foo-1.0.tar.gz
</code></pre>
</li>
</ul>
<p>在建立归档时，如果使用树对象ID进行归档，则使用当前时间作为归档中文件的修改时间，</p>
<p>而如果使用提交ID或里程碑等，则使用提交建立的时间作为归档中文件的修改时间。</p>
<p>如果使用tar格式建立归档，并且使用提交ID或里程碑ID，还会把提交ID记录在归档文件的文件头中。记录在文件头中的提交ID可以通过<strong>git tar-commit-id</strong>命令获取。</p>
<p>如果希望在建立归档时忽略某些文件或目录，可以通过为相应文件或目录建立<code>export-ignore</code>属性加以实现</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="工作区暂存区版本库"><a class="header" href="#工作区暂存区版本库">工作区、暂存区、版本库</a></h2>
<h3 id="暂存区"><a class="header" href="#暂存区">暂存区</a></h3>
<p>Git暂存区（stage，或称为index）的设计是Git最成功的设计之一，也是最难理解的一个设计。</p>
<p>在版本库<code>.git</code>目录下，有一个<code>index</code>文件</p>
<h3 id="记录时间戳"><a class="header" href="#记录时间戳"><strong>记录时间戳</strong></a></h3>
<p>当执行<strong>git status</strong>命令（或者<strong>git diff</strong>命令）扫描工作区改动的时候，先依据<code>.git/index</code>文件中记录的（工作区跟踪文件的）时间戳、长度等信息判断工作区文件是否改变</p>
<p>如果工作区的文件时间戳改变，说明文件的内容<strong>可能</strong>被改变了，需要要打开文件，读取文件内容，和更改前的原始文件相比较，判断文件内容是否被更改</p>
<p>如果文件内容没有改变，则将该文件新的时间戳记录到<code>.git/index</code>文件中</p>
<p>因为判断文件是否更改，使用时间戳、文件长度等信息进行比较要比通过文件内容比较要快的多，所以Git这样的实现方式可以让工作区状态扫描更快速的执行，这也是Git高效的因素之一。</p>
<h3 id="虚拟工作区"><a class="header" href="#虚拟工作区">虚拟工作区</a></h3>
<p>文件<code>.git/index</code>实际上就是一个包含文件索引的目录树，像是一个虚拟的工作区</p>
<p>这个虚拟工作区的目录树中，记录了文件名、文件的状态信息（时间戳、文件长度等）</p>
<p>文件的内容并不存储其中，而是保存在Git对象库<code>.git/objects</code>目录中，文件索引建立了文件和对象库中对象实体之间的对应</p>
<p>下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系。</p>
<p><img src="9.%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86_GIT/../images/git-stage.png" alt="" /></p>
<ul>
<li>图中左侧为工作区，右侧为版本库。在版本库中标记为<code>index</code>的区域是暂存区（stage，亦称index），标记为<code>master</code>的是master分支所代表的目录树。</li>
<li>图中可以看出此时HEAD实际是指向master分支的一个“游标”。所以图示的命令中出现HEAD的地方可以用master来替换。</li>
</ul>
<ul>
<li>
<p>图中的objects标识的区域为Git的对象库，实际位于<code>.git/objects</code>目录下</p>
</li>
<li>
<p>当对工作区修改（或新增）的文件执行<strong>git add</strong>命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</p>
</li>
<li>
<p>当执行提交操作（<strong>git commit</strong>）时，暂存区的目录树写到版本库（对象库）中，master分支会做相应的更新。即master最新指向的目录树就是提交时原暂存区的目录树。</p>
</li>
<li>
<p>当执行<strong>git reset HEAD</strong>命令时，暂存区的目录树会被重写，被master分支指向的目录树所替换，但是工作区不受影响。</p>
</li>
<li>
<p>当执行**git rm –cached &lt;file&gt;**命令时，会直接从暂存区删除文件，工作区则不做出改变。</p>
</li>
<li>
<p>当执行**git checkout .<strong>或者</strong>git checkout – &lt;file&gt;**命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</p>
</li>
<li>
<p>当执行**git checkout HEAD .<strong>或者</strong>git checkout HEAD &lt;file&gt;**命令时，会用HEAD指向的master分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</p>
</li>
</ul>
<p>使用暂存区或者版本库的文件 替换工作区的文件</p>
<pre><code class="language-shell">#全部替换
git checkout .
#替换某个文件
git checkout – &lt;file&gt;
#用HEAD指向的master分支中的全部或者部分文件替换暂存区和以及工作区中的文件。
# v-&gt;w、s
git checkout HEAD .
# 指定文件替换 v-&gt;w、s
git checkout HEAD &lt;file&gt;
</code></pre>
<pre><code class="language-shell">#清除当前工作区中没有加入版本库的文件和目录 f表示强制执行、d表示递归清理目录
git clean -fd
</code></pre>
<pre><code class="language-sh"># --pretty=raw参数以便显示每个提交对象的parent、tree属性
git log -2 --pretty=raw
</code></pre>
<pre><code class="language-sh"># -s 精简输出 -b输出分支名
git status -s -b
</code></pre>
<h3 id="暂存区目录树的浏览"><a class="header" href="#暂存区目录树的浏览"><strong>暂存区目录树的浏览</strong></a></h3>
<p>有什么办法能够像查看工作区一样的，直观的查看暂存区以及HEAD当中的目录树么？</p>
<p>对于HEAD（版本库中当前提交）指向的目录树，可以使用Git底层命令<strong>git ls-tree</strong>来查看。</p>
<pre><code># 使用-l参数，可以显示文件的大小。上面welcome.txt大小为25字节。
$ git ls-tree -l HEAD
100644 blob fd3c069c1de4f4bc9b15940f490aeb48852f3c42      25    welcome.txt
</code></pre>
<p>要<strong>显示暂存区的目录树</strong>，可以使用<strong>git ls-files</strong>命令。</p>
<pre><code>$ git ls-files -s
100644 18832d35117ef2f013c4009f5b2128dfaeff354f 0       a/b/c/hello.txt
100644 51dbfd25a804c30e9d8dc441740452534de8264b 0       welcome.txt
</code></pre>
<p>注意这个输出和之前使用<strong>git ls-tree</strong>命令输出不一样，如果想要使用<strong>git ls-tree</strong>命令</p>
<p>需要先将暂存区的目录树写入Git对象库（用<strong>git write-tree</strong>命令），然后在针对<strong>git write-tree</strong>命令写入的 tree 执行<strong>git ls-tree</strong>命令。</p>
<pre><code>$ git write-tree
9431f4a3f3e1504e03659406faa9529f83cd56f8
$ git ls-tree -l 9431f4a
040000 tree 53583ee687fbb2e913d18d508aefd512465b2092       -    a
100644 blob 51dbfd25a804c30e9d8dc441740452534de8264b      34    welcome.txt
</code></pre>
<h2 id="git-diff-1"><a class="header" href="#git-diff-1"><strong>Git diff</strong></a></h2>
<p>比较图</p>
<p><img src="9.%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86_GIT/../images/git-diff.png" alt="" /></p>
<h2 id="git对象"><a class="header" href="#git对象">GIT对象</a></h2>
<h3 id="查看git对象结构"><a class="header" href="#查看git对象结构"><strong>查看GIT对象结构</strong></a></h3>
<p><strong>查看git对象类型</strong></p>
<pre><code class="language-sh">$ git cat-file -t e695606
commit
$ git cat-file -t f58d
tree
$ git cat-file -t a0c6
commit
</code></pre>
<p><strong>查看git对象结构</strong></p>
<pre><code class="language-sh">$ git cat-file -p e695606
tree f58da9a820e3fd9d84ab2ca2f1b467ac265038f9
parent a0c641e92b10d8bcca1ed1bf84ca80340fdefee6
author Jiang Xin &lt;jiangxin@ossxp.com&gt; 1291022581 +0800
committer Jiang Xin &lt;jiangxin@ossxp.com&gt; 1291022581 +0800

#查看tree对象的结构 
weisanju@B-3BVVQ05P-2126 demo01 % git cat-file -p  df36838bf559b620ec5abdb30e6a593bb9af4ec7
100644 blob c86a7936f2a61955b463708abdf29b7567124f27	a.txt
100644 blob 3da1ec26e9c8512eae062868a9ff9bae47e5625b	b.txt
100644 blob fa64294350b06d9617cbfa34e0a60aca01b6c8be	test.ini
# tree对象中存在 blob对象、查看blob对象对应ID的 类别：就是blob类型
weisanju@B-3BVVQ05P-2126 demo01 % git cat-file -t c86a7936f2a61955b463708abdf29b7567124f27
blob

#查询blob对象ID对应的 结构：就是文件内容
weisanju@B-3BVVQ05P-2126 demo01 % git cat-file -p c86a7936f2a61955b463708abdf29b7567124f27
HelloWorld2
#这些对象保存在 Git库中的objects目录下（ID的前两位作为目录名，后38位作为文件名）


# 用下面的命令可以看到所有这些对象（tree、blob、commit）在对象库中的实际位置。
weisanju@B-3BVVQ05P-2126 demo01 % ls -l  .git/objects/c8/6a7936f2a61955b463708abdf29b7567124f27
-r--r--r--  1 weisanju  staff  28 11 20 20:18 .git/objects/c8/6a7936f2a61955b463708abdf29b7567124f27
</code></pre>
<p><strong>对象之间的关系</strong></p>
<p><img src="9.%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86_GIT/../images/git-objects.png" alt="" /></p>
<h3 id="命名空间"><a class="header" href="#命名空间">命名空间</a></h3>
<p><strong>head与master的关系</strong></p>
<pre><code class="language-sh"># 以下三个命令有同样的输出,在当前版本库中，HEAD、master和refs/heads/master具有相同的指向。
git log -1 HEAD
git log -1 master
git log -1 refs/heads/master
</code></pre>
<pre><code># 找到了四个文件，其中在.git/logs目录下的文件稍后再予以关注，现在把目光锁定在.git/HEAD和.git/refs/heads/master上。
$ find .git -name HEAD -o -name master
.git/HEAD
.git/logs/HEAD
.git/logs/refs/heads/master
.git/refs/heads/master
# 输出文件内容
weisanju@B-3BVVQ05P-2126 demo01 % cat .git/HEAD
ref: refs/heads/master
# 输出文件内容：指向最新的提交。这是一个 commit对象
weisanju@B-3BVVQ05P-2126 demo01 % cat .git/refs/heads/master
0e1ac87c48749584745bbbcfa72798135a45c553
</code></pre>
<ul>
<li>
<p>原来分支master指向的是一个提交ID（最新提交）。这样的分支实现是多么的巧妙啊：</p>
</li>
<li>
<p>可以从任何提交开始建立一条历史跟踪链，那么用一个文件指向这个链条的最新提交，那么这个文件就可以用于追踪整个提交历史了</p>
</li>
<li>
<p>这个文件就是.git/refs/heads/master文件。</p>
</li>
<li>
<p>目录<code>.git/refs</code>是保存引用的命名空间，其中<code>.git/refs/heads</code>目录下的引用又称为分支</p>
</li>
<li>
<p>对于分支既可以使用正规的长格式的表示法，如<code>refs/heads/master</code>，也可以去掉前面的两级目录用<code>master</code>来表示</p>
</li>
<li>
<p>Git 有一个底层命令<strong>git rev-parse</strong>可以用于显示引用对应的提交ID。</p>
</li>
</ul>
<pre><code class="language-sh">#可以看出它们都指向同一个对象
$ git rev-parse master
e695606fc5e31b2ff9038a48a3d363f4c21a3d86
$ git rev-parse refs/heads/master
e695606fc5e31b2ff9038a48a3d363f4c21a3d86
$ git rev-parse HEAD
e695606fc5e31b2ff9038a48a3d363f4c21a3d86
</code></pre>
<p><img src="9.%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86_GIT/../images/git-repos-detail.png" alt="" /></p>
<h3 id="sha1哈希值到底是什么如何生成的"><a class="header" href="#sha1哈希值到底是什么如何生成的">SHA1哈希值到底是什么，如何生成的？</a></h3>
<p>哈希(hash)是一种数据摘要算法（或称散列算法），是信息安全领域当中重要的理论基石。</p>
<p>该算法将任意长度的输入经过散列运算转换为固定长度的输出</p>
<p>固定长度的输出可以称为对应的输入的数字摘要或哈希值</p>
<p>比较著名的摘要算法有：MD5和SHA1。Linux下<strong>sha1sum</strong>命令可以用于生成摘要。</p>
<p><strong>提交hash</strong></p>
<pre><code class="language-sh"># 看看HEAD对应的提交的内容。使用**git cat-file**命令。
git cat-file commit HEAD
git cat-file commit HEAD | wc -c

# 在提交信息的前面加上commit内容、commit 234&lt;null&gt;（&lt;null&gt;为空字符），然后执行SHA1哈希算法。
$ ( printf &quot;commit 234\000&quot;; git cat-file commit HEAD ) | sha1sum
e695606fc5e31b2ff9038a48a3d363f4c21a3d86

#查看提交的hash
$ git rev-parse HEAD
e695606fc5e31b2ff9038a48a3d363f4c21a3d86
</code></pre>
<p><strong>文件内容hash</strong></p>
<pre><code class="language-sh"># 查看文件的内容
git cat-file blob HEAD:welcome.txt
 
#在文件内容的前面加上blob 25&lt;null&gt;的内容，然后执行SHA1哈希算法。
$ ( printf &quot;blob 25\000&quot;; git cat-file blob HEAD:welcome.txt ) | sha1sum
fd3c069c1de4f4bc9b15940f490aeb48852f3c42  -

# 查看文件内容的hash
$ git rev-parse HEAD:welcome.txt
fd3c069c1de4f4bc9b15940f490aeb48852f3c42
</code></pre>
<p><strong>tree对象hash</strong></p>
<pre><code class="language-shell"># HEAD对应的树的内容共包含39个字节。
git cat-file tree HEAD^{tree} | wc -c
# 在树的内容的前面加上tree 39&lt;null&gt;的内容，然后执行SHA1哈希算法
( printf &quot;tree 39\000&quot;; git cat-file tree HEAD^{tree} ) | sha1sum
f58da9a820e3fd9d84ab2ca2f1b467ac265038f9  -
# 查看 head所执行的提交的 tree对象的hash
git rev-parse HEAD^{tree}
</code></pre>
<p>在后面学习里程碑（Tag）的时候，会看到Tag对象（轻量级Tag除外）也是采用类似方法在对象库中存储的。</p>
<h3 id="访问git库中的对象"><a class="header" href="#访问git库中的对象">访问GIT库中的对象</a></h3>
<h3 id="规则"><a class="header" href="#规则">规则</a></h3>
<ul>
<li>
<p>采用部分的SHA1哈希值。不必写全40位的哈希值，只采用开头的部分，不和现有其他的冲突即可。</p>
</li>
<li>
<p>使用<code>master</code>代表分支<code>master</code>中最新的提交，使用全称<code>refs/heads/master</code>亦可</p>
</li>
<li>
<p>使用<code>HEAD</code>代表版本库中最近的一次提交。</p>
</li>
<li>
<p>符号<code> </code>^`可以用于指代父提交。例如：</p>
<ul>
<li><code>HEAD^</code>代表版本库中上一次提交，即最近一次提交的父提交。</li>
<li><code>HEAD^^</code>则代表<code>HEAD^</code>的父提交。</li>
</ul>
</li>
<li>
<p>对于一个提交有多个父提交，可以在符号<code>^</code>后面用数字表示是第几个父提交。例如：</p>
<ul>
<li><code>a573106^2</code>含义是提交<code>a573106</code>的多个父提交中的第二个父提交。</li>
<li><code>HEAD^1</code>相当于<code>HEAD^</code>含义是HEAD多个父提交中的第一个。</li>
<li><code>HEAD^^2</code>含义是<code>HEAD^</code>（HEAD父提交）的多个父提交中的第二个。</li>
</ul>
</li>
<li>
<p>符号<code>~&lt;n&gt;</code>也可以用于指代祖先提交。下面两个表达式效果等同：</p>
<pre><code>a573106~5
a573106^^^^^
</code></pre>
</li>
<li>
<p>提交所对应的树对象，可以用类似如下的语法访问。</p>
<pre><code>a573106^{tree}
</code></pre>
</li>
<li>
<p>某一此提交对应的文件对象，可以用如下的语法访问。</p>
<pre><code>a573106:path/to/file
</code></pre>
</li>
<li>
<p>访问暂存区中的文件对象，可以用如下的语法访问。</p>
<pre><code>:path/to/file
</code></pre>
</li>
</ul>
<h2 id="重置"><a class="header" href="#重置">重置</a></h2>
<h3 id="重置原理"><a class="header" href="#重置原理">重置原理</a></h3>
<blockquote>
<p>移动 refs/heads/&lt;branch-name&gt; 中的提交</p>
</blockquote>
<pre><code>$ cat .git/refs/heads/master
4902dc375672fbf52a226e0354100b75d4fe31e3
$ git log --graph --oneline
* 4902dc3 does master follow this new commit?
* e695606 which version checked in?
* a0c641e who does commit?
* 9e8a761 initialized.
</code></pre>
<p>引用<code>refs/heads/master</code>就好像是一个游标，在有新的提交发生的时候指向了新的提交。</p>
<p>Git提供了<strong>git reset</strong>命令，可以将“游标”指向任意一个存在的提交ID。下面的示例就尝试人为的更改游标。（注意下面的命令中使用了<code>--hard</code>参数，会破坏工作区未提交的改动，慎用。</p>
<h3 id="用reflog挽救错误的重置"><a class="header" href="#用reflog挽救错误的重置">用reflog挽救错误的重置</a></h3>
<p>如果没有记下重置前master分支指向的提交ID，想要重置回原来的提交真的是一件麻烦的事情（去对象库中一个一个地找）</p>
<p>幸好Git提供了一个挽救机制，通过<code>.git/logs</code>目录下日志文件记录了分支的变更。</p>
<p>默认非裸版本库（带有工作区）都提供分支日志功能，这是因为带有工作区的版本库都有如下设置：</p>
<pre><code>$ git config core.logallrefupdates
true
</code></pre>
<p><strong>查看一下master分支的日志文件</strong></p>
<p><code>.git/logs/refs/heads/master</code>中的内容。下面命令显示了该文件的最后几行。</p>
<p>为了排版的需要，还将输出中的40位的SHA1提交ID缩短。</p>
<pre><code class="language-shell">tail -5 .git/logs/refs/heads/master
</code></pre>
<p><strong>显示日志</strong></p>
<pre><code>git reflog show master | head -5
</code></pre>
<p>使用<strong>git reflog</strong>的输出和直接查看日志文件最大的不同在于显示顺序的不同</p>
<p>即最新改变放在了最前面显示，而且只显示每次改变的最终的SHA1哈希值。</p>
<p>还有个重要的区别在于使用<strong>git reflog</strong>的输出中还提供一个方便易记的表达式</p>
<pre><code>&lt;refname&gt;@{&lt;n&gt;}
这个表达式的含义是引用&lt;refname&gt;之前第&lt;n&gt;次改变时的SHA1哈希值。
</code></pre>
<p>那么将引用master切换到两次变更之前的值，可以使用下面的命令。</p>
<ul>
<li>
<p>重置master为两次改变之前的值。</p>
<pre><code>$ git reset --hard master@{2}
HEAD is now at 4902dc3 does master follow this new commit?
</code></pre>
</li>
</ul>
<p>此时如果再用<strong>git reflog</strong>查看，会看到恢复master的操作也记录在日志中了。</p>
<h3 id="命令详细"><a class="header" href="#命令详细"><strong>命令详细</strong></a></h3>
<pre><code>用法一： git reset [-q] [&lt;commit&gt;] [--] &lt;paths&gt;...
用法二： git reset [--soft | --mixed | --hard | --merge | --keep] [-q] [&lt;commit&gt;]
</code></pre>
<p>其中 &lt;commit&gt; 都是可选项，可以使用引用或者提交ID，如果省略 &lt;commit&gt; 则相当于使用了HEAD的指向作为提交ID。</p>
<p>上面列出的两种用法的区别在于，第一种用法在命令中包含路径<code>&lt;paths&gt;</code>,为了避免路径和引用（或者提交ID）同名而冲突，可以在<code>&lt;paths&gt;</code>前用两个连续的短线（减号）作为分隔。</p>
<p><strong>替换暂存区</strong></p>
<p>第一种用法（包含了路径<code>&lt;paths&gt;</code>的用法）<strong>不会</strong>重置引用，更不会改变工作区，而是用指定提交状态（&lt;commit&gt;）下的文件（&lt;paths&gt;）替换掉暂存区中的文件</p>
<p>例如命令**git reset HEAD &lt;paths&gt;<strong>相当于取消之前执行的</strong>git add &lt;paths&gt;**命令时改变的暂存区。</p>
<p>第二种用法（不使用路径<code>&lt;paths&gt;</code>的用法）则会<strong>重置引用</strong>。根据不同的选项，可以对暂存区或者工作区进行重置。参照下面的版本库模型图，来看一看不同的参数对第二种重置语法的影响。</p>
<p><strong>重置选项</strong></p>
<p><img src="9.%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86_GIT/../images/git-reset.png" alt="" /></p>
<p>命令格式: git reset [–soft | –mixed | –hard ] [<commit>]</p>
<ul>
<li>
<p>使用参数<code>--hard</code>，如：<strong>git reset –hard <commit></strong>。</p>
<p>会执行上图中的1、2、3全部的三个动作。即：</p>
<ol>
<li>替换引用的指向。引用指向新的提交ID。</li>
<li>替换暂存区。替换后，暂存区的内容和引用指向的目录树一致。</li>
<li>替换工作区。替换后，工作区的内容变得和暂存区一致，也和HEAD所指向的目录树内容相同。</li>
</ol>
</li>
<li>
<p>使用参数<code>--soft</code>，如:<strong>git reset –soft <commit></strong>。</p>
<p>会执行上图中的操作1。即只更改引用的指向，不改变暂存区和工作区。</p>
</li>
<li>
<p>使用参数<code>--mixed</code>或者不使用参数（缺省即为<code>--mixed</code>），如:<strong>git reset <commit></strong>。</p>
<p>会执行上图中的操作1和操作2。即更改引用的指向以及重置暂存区，但是不改变工作区。</p>
</li>
</ul>
<p><strong>重置命令的不同用法</strong></p>
<ul>
<li>
<p><strong>git reset</strong>：重置暂存区</p>
</li>
<li>
<p><strong>git reset HEAD</strong>：同上</p>
</li>
<li>
<p><strong>git reset – filename</strong> ：重置暂存区</p>
</li>
<li>
<p><strong>git reset HEAD filename</strong> 同上</p>
</li>
<li>
<p><strong>git reset –soft HEAD^</strong></p>
<ul>
<li>版本库回退一个版本、暂存区没有、所以暂存区在与版本库比对时就会多出来一个 提交</li>
<li>现象：将上一次提交拉回到暂存区</li>
</ul>
<p>在之前曾经介绍过一个修补提交命令<strong>git commit –amend</strong>，用于对最新的提交进行重新提交以修补错误的提交说明或者错误的提交文件。修补提交命令实际上相当于执行了下面两条命令。（注：文件<code>.git/COMMIT_EDITMSG</code>保存了上次的提交日志）</p>
<pre><code class="language-shell">$ git reset --soft HEAD^
$ git commit -e -F .git/COMMIT_EDITMSG
</code></pre>
</li>
<li>
<p><strong>git reset HEAD^</strong> </p>
</li>
<li>
<p><strong>git reset –mixed HEAD^</strong></p>
<ul>
<li>版本库回退一个版本、暂存库回退一个版本、工作区不回退，则工作区多出</li>
</ul>
</li>
<li>
<p><strong>git reset –hard HEAD^</strong></p>
<ul>
<li>三个库全部回退</li>
</ul>
</li>
</ul>
<h2 id="恢复进度"><a class="header" href="#恢复进度">恢复进度</a></h2>
<h3 id="使用git-stash"><a class="header" href="#使用git-stash">使用<strong>git stash</strong></a></h3>
<p>命令<strong>git stash</strong>可以用于保存和恢复工作进度</p>
<ul>
<li>
<p>命令：<strong>git stash</strong></p>
<p>保存当前工作进度。会分别对暂存区和工作区的状态进行保存。</p>
</li>
</ul>
<ul>
<li>
<p>命令：<strong>git stash list</strong></p>
<p>显示进度列表。此命令显然暗示了<strong>git stash</strong>可以多次保存工作进度，并且在恢复的时候进行选择。</p>
</li>
<li>
<p>命令： <strong>git stash show</strong></p>
<p>显示变更</p>
</li>
<li>
<p>命令：<strong>git stash pop [–index] [&lt;stash&gt;]</strong></p>
<p>会恢复最新保存的工作进度，并将恢复的工作进度从存储的工作进度列表中清除。</p>
</li>
<li>
<p>命令：<strong>git stash apply [–index] [&lt;stash&gt;]</strong></p>
<p>除了不删除恢复的进度之外，其余和<strong>git stash pop</strong>命令一样。</p>
</li>
<li>
<p>命令：<strong>git stash drop [<stash>]</strong></p>
<p>删除一个存储的进度。缺省删除最新的进度。</p>
</li>
<li>
<p>命令：<strong>git stash clear</strong></p>
<p>删除所有存储的进度。</p>
</li>
</ul>
<ul>
<li>
<p>命令：<strong>git stash branch <branchname> <stash></strong></p>
<p>基于进度创建分支。对了，还没有讲到分支呢。;)</p>
</li>
</ul>
<h3 id="探秘git-stash"><a class="header" href="#探秘git-stash">探秘<strong>git stash</strong></a></h3>
<p>在执行<strong>git stash</strong>命令时，Git实际调用了一个脚本文件实现相关的功能，这个脚本的文件名就是<code>git-stash</code>。看看<code>git-stash</code>安装在哪里了。</p>
<p>实际上在1.5.4之前的版本，Git会安装这些一百多个以<strong>git-<cmd><strong>格式命名的程序到可执行路径中。这样做的唯一好处就是不用借助任何扩展机制就可以实现命令行补齐：即键入<code>git-</code>后，连续两次键入<code>&lt;Tab&gt;</code>键，就可以把这一百多个命令显示出来。这种方式随着Git子命令的增加越来越显得混乱，因此在1.5.4版本开始，不再提供</strong>git-&lt;cmd&gt;<strong>格式的命令，而是用唯一的</strong>git</strong>命令。而之前的名为**git-&lt;cmd&gt;**的子命令则保存在非可执行目录下，由Git负责加载。</p>
<p>最早很多Git命令都是用Shell或者Perl脚本语言开发的，在Git的发展中一些对运行效率要求高的命令用C语言改写。而<code>git-stash</code>（至少在Git 1.7.3.2版本）还是使用Shell脚本开发的，研究它会比研究用C写的命令要简单的多。</p>
<p><strong>显示 stash 引用空间的提交</strong></p>
<pre><code class="language-shell"># 可以看到在提交关系图可以看到进度保存的最新提交是一个合并提交。最新的提交说明中有WIP字样（是Work In Progess的简称），说明代表了工作区进度。而最新提交的第二个父提交（上图中显示为第二个提交）有index on master字样，说明这个提交代表着暂存区的进度。
git log --graph --pretty=raw  refs/stash -2
</code></pre>
<p><strong>通过 logs/refs/stash 记录 stash的改变记录</strong></p>
<pre><code class="language-sh"> ls -l .git/refs/stash .git/logs/refs/stash
 # 记录了 stash引用的变更日志
 git reflog show refs/stash
</code></pre>
<p>果然上面显示的三个提交对应的三棵树各不相同。查看一下差异。用“原基线”代表进度保存时版本库的状态；用“原暂存区”代表进度保存时暂存区的状态，；用“原工作区”代表进度保存时工作区的状态。</p>
<ul>
<li>
<p>原基线和原暂存区的差异比较。</p>
<pre><code>$ git diff stash@{1}^2^ stash@{1}^2

</code></pre>
</li>
<li>
<p>原暂存区和原工作区的差异比较。</p>
<pre><code>$ git diff stash@{1}^2 stash@{1}
</code></pre>
</li>
<li>
<p>原基线和原工作区的差异比较。</p>
<pre><code>$ git diff stash@{1}^1 stash@{1}
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="git支持的协议-1"><a class="header" href="#git支持的协议-1">Git支持的协议</a></h2>
<table><thead><tr><th style="text-align: left">协议名称</th><th style="text-align: left">语法格式</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">SSH协议（1）</td><td style="text-align: left"><code>ssh://[user@]example.com[:port]/path/to/repo.git/</code></td><td style="text-align: left">可在URL中设置用户名和端口。 默认端口22。</td></tr>
<tr><td style="text-align: left">SSH协议（2）</td><td style="text-align: left"><code>[user@]example.com:path/to/repo.git/</code></td><td style="text-align: left">更为精简的SCP格式表示法，更简洁。 但是非默认端口需要通过其他方式（如地址别名方式）设定。</td></tr>
<tr><td style="text-align: left">GIT协议</td><td style="text-align: left"><code>git://example.com[:port]/path/to/repo.git/</code></td><td style="text-align: left">最常用的只读协议。</td></tr>
<tr><td style="text-align: left">HTTP[S]协议</td><td style="text-align: left"><code>http[s]://example.com[:port]/path/to/repo.git/</code></td><td style="text-align: left">兼有智能协议和哑协议。</td></tr>
<tr><td style="text-align: left">FTP[S]协议</td><td style="text-align: left"><code>ftp[s]://example.com[:port]/path/to/repo.git/</code></td><td style="text-align: left">哑协议。</td></tr>
<tr><td style="text-align: left">RSYNC协议</td><td style="text-align: left"><code>rsync://example.com/path/to/repo.git/</code></td><td style="text-align: left">哑协议。</td></tr>
<tr><td style="text-align: left">本地协议（1）</td><td style="text-align: left"><code>file:///path/to/repo.git</code></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">本地协议（2）</td><td style="text-align: left"><code>/path/to/repo.git</code></td><td style="text-align: left">和<code>file://</code>格式的本地协议类似。但有细微差别。 例如克隆时不支持浅克隆，且采用直接的硬连接实现克隆。</td></tr>
</tbody></table>
<h2 id="智能协议"><a class="header" href="#智能协议"><strong>智能协议</strong></a></h2>
<p>在通讯时使用智能协议，会在两个通讯的版本库的各自一端分别打开两个程序进行数据交换。</p>
<p>使用智能协议最直观的印象就是在数据传输过程中会有清晰的进度显示，而且因为是按需传输所以传输量更小，速度更快</p>
<p>上述协议中SSH、GIT及本地协议（<a href="file:///">file://</a>）属于智能协议。HTTP协议需要特殊的配置（用<code>git-http-backend</code>配置CGI），并且客户端需要使用Git 1.6.6或更高的版本才能够使用智能协议。</p>
<h2 id="哑协议"><a class="header" href="#哑协议"><strong>哑协议</strong></a></h2>
<p>和智能协议相对的是哑协议。使用哑协议在访问远程版本库的时候，远程版本库不会运行辅助程序，而是完全依靠客户端去主动“发现”</p>
<p>客户端需要访问文件<code>.git/info/refs</code>获取当前版本库的引用列表，并根据引用对应的提交ID直接访问对象库目录下的文件。</p>
<p>如果对象文件被打包而不以松散对象形式存在，则Git客户端还要去访问文件<code>.git/objects/info/packs</code>以获得打包文件列表，并据此读取完整的打包文件，从打包文件中获取对象</p>
<p>由此可见哑协议的效率非常之低，甚至会因为要获取一个对象而去访问整个pack包。</p>
<p>使用哑协议最直观的感受是：传输速度非常慢，而且传输进度不可见，不知道什么时候才能够完成数据传输。</p>
<h2 id="冲突解决"><a class="header" href="#冲突解决">冲突解决</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="冲突解决-1"><a class="header" href="#冲突解决-1">冲突解决</a></h1>
<h2 id="拉回操作中的合并"><a class="header" href="#拉回操作中的合并">拉回操作中的合并</a></h2>
<p>真实的运行环境中，用户间协同并不总是会一帆风顺，只要有合并就可能会有冲突。本章就重点介绍冲突解决机制。</p>
<p><strong>git pull操作解决非快进式推送问题的步骤</strong></p>
<ul>
<li>用户user1向共享版本库推送时，因为user2强制推送已经改变了共享版本库中的提交状态，导致user1推送失败，</li>
<li>用户user1执行PULL操作的第一阶段，将共享版本库master分支的最新提交拉回到本地，并更新到本地版本库特定的引用<code>refs/remotes/origin/master</code>（简称为<code>origin/master</code>）</li>
<li>用户user1执行PULL操作的第二阶段，将本地分支master和共享版本库本地跟踪分支<code>origin/master</code>进行合并操作，</li>
<li>用户user1执行PUSH操作，将本地提交推送到共享版本库中</li>
</ul>
<p>实际上拉回（PULL）操作是由两个步骤组成的，一个是获取（FETCH）操作，一个是合并（MERGE）操作，即：</p>
<pre><code class="language-shell">git pull = git fetch + git merge
</code></pre>
<p>将获取操作理解为将远程的共享版本库的对象（提交、里程碑、分支等）复制到本地即可。</p>
<p>合并操作的命令行格式如下：</p>
<pre><code>git merge [选项...] &lt;commit&gt;...
</code></pre>
<p>合并操作的大多数情况，只须提供一个<code>&lt;commit&gt;</code>（提交ID或对应的引用：分支、里程碑等）作为参数</p>
<p>合并操作将<code>&lt;commit&gt;</code>对应的目录树和当前工作分支的目录树的内容进行合并，合并后的提交以当前分支的提交作为第一个父提交，以<code>\&lt;commit&gt;</code>为第二个父提交</p>
<p>合并操作还支持将多个<code>&lt;commit&gt;</code>代表的分支和当前分支进行合并，过程类似</p>
<p>默认情况下，合并后的结果会自动提交，但是如果提供<code>--no-commit</code>选项，则合并后的结果会放入暂存区，用户可以对合并结果进行检查、更改，然后手动提交</p>
<p>合并操作并非总会成功，因为合并的不同提交可能同时修改了同一文件相同区域的内容，导致冲突。冲突会造成合并操作的中断，冲突的文件被标识</p>
<p>用户可以对标识为冲突的文件进行冲突解决操作，然后更新暂存区，再提交，最终完成合并操作</p>
<p>根据合并操作是否遇到冲突，以及不同的冲突类型，可以分为以下几种情况：</p>
<ul>
<li>成功的自动合并</li>
<li>逻辑冲突</li>
<li>真正的冲突</li>
<li>树冲突</li>
</ul>
<h2 id="自动合并"><a class="header" href="#自动合并">自动合并</a></h2>
<p>Git的合并操作非常智能，大多数情况下会自动完成合并。不管是修改不同的文件，还是修改相同的文件（文件的不同位置），或者文件名变更。</p>
<h3 id="修改不同的文件"><a class="header" href="#修改不同的文件">修改不同的文件</a></h3>
<pre><code>$ git fetch
$ git merge origin/master
$ git push
# 追溯文件的每一行
$ git blame README
07e9d082 (user1 2010-12-25 23:12:17 +0800 1) User1 hacked.
^5174bf3 (user1 2010-12-19 15:52:29 +0800 2) Hello.
bb0c74fa (user2 2010-12-25 23:14:27 +0800 3) User2 hacked.
</code></pre>
<h3 id="修改相同文件不同地方"><a class="header" href="#修改相同文件不同地方">修改相同文件不同地方</a></h3>
<h3 id="重命名与修改"><a class="header" href="#重命名与修改">重命名与修改</a></h3>
<h3 id="修改相同文件相同地方"><a class="header" href="#修改相同文件相同地方">修改相同文件相同地方</a></h3>
<p><strong>记录冲突</strong></p>
<p>那么Git是如何记录合并过程及冲突的呢？实际上合并过程是通过<code>.git</code>目录下的几个文件进行记录的：</p>
<ul>
<li>文件<code>.git/MERGE_HEAD</code>记录所合并的提交ID。</li>
<li>文件<code>.git/MERGE_MSG</code>记录合并失败的信息。</li>
<li>文件<code>.git/MERGE_MODE</code>标识合并状态。</li>
</ul>
<p>版本库暂存区中则会记录冲突文件的多个不同版本。可以使用<strong>git ls-files</strong>命令查看。</p>
<pre><code>$ git ls-files -s
100644 ea501534d70a13b47b3b4b85c39ab487fa6471c2 1       doc/README.txt
100644 5611db505157d312e4f6fb1db2e2c5bac2a55432 2       doc/README.txt
100644 036dbc5c11b0a0cefc8247cf0e9a3e678f8de060 3       doc/README.txt
100644 430bd4314705257a53241bc1d2cb2cc30f06f5ea 0       team/user1.txt
100644 a72ca0b4f2b9661d12d2a0c1456649fc074a38e3 0       team/user2.txt
</code></pre>
<ul>
<li>
<p>编号为1的暂存区用于保存冲突文件修改之前的副本，即冲突双方共同的祖先版本。可以用<code>:1:&lt;filename&gt;</code>访问。</p>
<pre><code>$ git show :1:doc/README.txt
User1 hacked.
Hello.
User2 hacked.
User2 hacked again.
</code></pre>
</li>
</ul>
<ul>
<li>编号为2的暂存区用于保存当前冲突文件在当前分支中修改的副本。可以用<code>:2:&lt;filename&gt;</code>访问。</li>
</ul>
<pre><code>$ git show :2:doc/README.txt
User1 hacked.
Hello, user2.
User2 hacked.
User2 hacked again.
</code></pre>
<ul>
<li>
<p>编号为3的暂存区用于保存当前冲突文件在合并版本（分支）中修改的副本。可以用<code>:3:&lt;filename&gt;</code>访问。</p>
<pre><code>$ git show :3:doc/README.txt
User1 hacked.
Hello, user1.
User2 hacked.
User2 hacked again.
</code></pre>
</li>
</ul>
<h3 id="树冲突"><a class="header" href="#树冲突">树冲突</a></h3>
<p>如果一个用户将某个文件改名，另外一个用户将同样的文件改为另外的名字，当这两个用户的提交进行合并操作时，Git显然无法替用户做出裁决，于是就产生了冲突。这种因为文件名修改造成的冲突，称为树冲突。</p>
<p>此时查看一下用户user2本地版本库的暂存区，可以看到因为冲突在编号为1、2、3的暂存区出现了相同SHA1哈希值的对象，但是文件名各不相同。</p>
<pre><code>$ git ls-files -s
100644 463dd451d94832f196096bbc0c9cf9f2d0f82527 2       README
100644 463dd451d94832f196096bbc0c9cf9f2d0f82527 1       doc/README.txt
100644 463dd451d94832f196096bbc0c9cf9f2d0f82527 3       readme.txt
100644 430bd4314705257a53241bc1d2cb2cc30f06f5ea 0       team/user1.txt
100644 a72ca0b4f2b9661d12d2a0c1456649fc074a38e3 0       team/user2.txt
</code></pre>
<p>手工操作解决树冲突</p>
<ul>
<li>
<p>删除文件<code>readme.txt</code>。</p>
<p>在执行<strong>git rm</strong>操作过程会弹出三条警告，说共有三个文件待合并。</p>
<pre><code>$ git rm readme.txt
README: needs merge
doc/README.txt: needs merge
readme.txt: needs merge
rm 'readme.txt'
</code></pre>
</li>
</ul>
<ul>
<li>删除文件<code>doc/README.txt</code>。</li>
</ul>
<p>​	执行删除过程，弹出的警告少了一条，因为前面的删除操作已经将一个冲突文件撤出暂存区了。</p>
<ul>
<li>添加文件<code>README</code></li>
</ul>
<pre><code>$ git add README
</code></pre>
<ul>
<li>
<p>提交完成冲突解决。</p>
<pre><code>$ git commit -m &quot;fixed tree conflict.&quot;
[master e82187e] fixed tree conflict.
</code></pre>
</li>
</ul>
<h2 id="合并策略"><a class="header" href="#合并策略">合并策略</a></h2>
<p>Git合并操作支持很多合并策略，默认会选择最适合的合并策略。例如，和一个分支进行合并时会选择<code>recursive</code>合并策略，当和两个或两个以上的其他分支进行合并时采用<code>octopus</code>合并策略。可以通过传递参数使用指定的合并策略，命令行如下：</p>
<pre><code>git merge [-s &lt;strategy&gt;] [-X &lt;strategy-option&gt;] &lt;commit&gt;...
</code></pre>
<p>其中参数<code>-s</code>用于设定合并策略，参数<code>-X</code>用于为所选的合并策略提供附加的参数。</p>
<p>下面分别介绍不同的合并策略：</p>
<ul>
<li>
<p>resolve</p>
<p>该合并策略只能用于合并两个头（即当前分支和另外的一个分支），使用三向合并策略。这个合并策略被认为是最安全、最快的合并策略。</p>
</li>
<li>
<p>recursive</p>
<p>该合并策略只能用于合并两个头（即当前分支和另外的一个分支），使用三向合并策略。这个合并策略是合并两个头指针时的默认合并策略。</p>
<p>当合并的头指针拥有一个以上的祖先的时候，会针对多个公共祖先创建一个合并的树，并以此作为三向合并的参照。这个合并策略被认为可以实现冲突的最小化，而且可以发现和处理由于重命名导致的合并冲突。</p>
<p>这个合并策略可以使用下列选项。</p>
<ul>
<li>
<p>ours</p>
<p>在遇到冲突的时候，选择我们的版本（当前分支的版本），而忽略他人的版本。如果他人的改动和本地改动不冲突，会将他人改动合并进来。</p>
<p>不要将此模式和后面介绍的单纯的<code>ours</code>合并策略相混淆。后面介绍的<code>ours</code>合并策略直接丢弃其他分支的变更，无论冲突与否。</p>
</li>
<li>
<p>theirs</p>
<p>和<code>ours</code>选项相反，遇到冲突时选择他人的版本，丢弃我们的版本。</p>
</li>
<li>
<p>subtree[=path]</p>
<p>这个选项使用子树合并策略，比下面介绍的<code>subtree</code>（子树合并）策略的定制能力更强。下面的<code>subtree</code>合并策略要对两个树的目录移动进行猜测，而<code>recursive</code>合并策略可以通过此参数直接对子树目录进行设置。</p>
</li>
</ul>
</li>
<li>
<p>octopus</p>
<p>可以合并两个以上的头指针，但是拒绝执行需要手动解决的复杂合并。主要的用途是将多个主题分支合并到一起。这个合并策略是对三个及三个以上头指针进行合并时的默认合并策略。</p>
</li>
<li>
<p>ours</p>
<p>可以合并任意数量的头指针，但是合并的结果总是使用当前分支的内容，丢弃其他分支的内容。</p>
</li>
<li>
<p>subtree</p>
<p>这是一个经过调整的recursive策略。当合并树A和B时，如果B和A的一个子树相同，B首先进行调整以匹配A的树的结构，以免两棵树在同一级别进行合并。同时也针对两棵树的共同祖先进行调整。</p>
</li>
</ul>
<h2 id="合并相关的设置"><a class="header" href="#合并相关的设置">合并相关的设置</a></h2>
<p>可以通过<strong>git config</strong>命令设置与合并相关的环境变量，对合并进行配置。下面是一些常用的设置。</p>
<ul>
<li>
<p>merge.conflictstyle</p>
<p>该变量定义冲突文件的显示风格，有两个可用的风格，默认的“merge”或“diff3”。</p>
<p>默认的“merge”风格使用标准的冲突分界符（<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>、<code>=======</code>、<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>）对冲突内容进行标识，其中的两个文字块分别是本地的修改和他人的修改。</p>
<p>如果使用“diff3”风格，则会在冲突中出现三个文字块，分别是：<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>和<code>|||||||</code>之间的本地更改版本、<code>|||||||</code>和<code>=======</code>之间的原始（共同祖先）版本和<code>=======</code>和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>之间的他人更改的版本。例如：</p>
<pre><code>User1 hacked.
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
Hello, user2.
||||||| merged common ancestors
Hello.
=======
Hello, user1.
&gt;&gt;&gt;&gt;&gt;&gt;&gt; a123390b8936882bd53033a582ab540850b6b5fb
User2 hacked.
User2 hacked again.
</code></pre>
</li>
<li>
<p>merge.tool</p>
<p>执行<strong>git mergetool</strong>进行冲突解决时调用的图形化工具。变量<code>merge.tool</code>可以设置为如下内置支持的工具：“kdiff3”、“tkdiff”、“meld”、“xxdiff”、“emerge”、“vimdiff”、“gvimdiff”、“diffuse”、“ecmerge”、“tortoisemerge”、“p4merge”、“araxis”和“opendiff”。</p>
<pre><code>$ git config --global merge.tool kdiff3
</code></pre>
<p>如果将<code>merge.tool</code>设置为其他值，则使用自定义工具进行冲突解决。自定义工具需要通过<code>mergetool.&lt;tool&gt;.cmd</code>对自定义工具的命令行进行设置。</p>
</li>
<li>
<p>mergetool.<tool>.path</p>
<p>如果<strong>git mergetool</strong>支持的冲突解决工具安装在特殊位置，可以使用<code>mergetool.&lt;tool&gt;.path</code>对工具<code>&lt;tool&gt;</code>的安装位置进行设置。例如：</p>
<pre><code>$ git config --global mergetool.kdiff3.path /path/to/kdiff3
</code></pre>
</li>
<li>
<p>mergetool.<tool>.cmd</p>
<p>如果所用的冲突解决工具不在内置的工具列表中，还可以使用<code>mergetool.&lt;tool&gt;.cmd</code>对自定义工具的命令行进行设置，同时要将<code>merge.tool</code>设置为<code>&lt;tool&gt;</code>。</p>
<p>自定义工具的命令行可以使用Shell变量。例如：</p>
<pre><code>$ git config --global merge.tool mykdiff3
$ git config --global mergetool.mykdiff3.cmd '/usr/bin/kdiff3
             -L1 &quot;$MERGED (Base)&quot; -L2 &quot;$MERGED (Local)&quot; -L3 &quot;$MERGED (Remote)&quot;
             --auto -o &quot;$MERGED&quot; &quot;$BASE&quot; &quot;$LOCAL&quot; &quot;$REMOTE&quot;'
</code></pre>
</li>
<li>
<p>merge.log</p>
<p>是否在合并提交的提交说明中包含合并提交的概要信息。默认为<code>false</code>。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="补丁文件交互"><a class="header" href="#补丁文件交互">补丁文件交互</a></h1>
<p>之前各个章节版本库间的交互都是通过<strong>git push</strong>和/或<strong>git pull</strong>命令实现的，这是Git最主要的交互模式，但并不是全部。使用补丁文件是另外一种交互方式</p>
<p>使用补丁文件是另外一种交互方式，适用于参与者众多的大型项目进行分布式开发</p>
<p>例如Git项目本身的代码提交就主要由贡献者通过邮件传递补丁文件实现的。</p>
<p>这种使用补丁文件进行提交的方式可以提高项目的参与度。因为任何人都可以参与项目的开发，只要会将提交转化为补丁，会发邮件即可。</p>
<h2 id="创建补丁"><a class="header" href="#创建补丁">创建补丁</a></h2>
<p>Git提供了将提交批量转换为补丁文件的命令：<strong>git format-patch</strong>。该命令后面的参数是一个版本范围列表，会将包含在此列表中的提交一一转换为补丁文件，每个补丁文件包含一个序号并从提交说明中提取字符串作为文件名。</p>
<p>下面演示一下在user1工作区中，如何将<code>master</code>分支的最近3个提交转换为补丁文件。</p>
<ul>
<li>
<p>进入user1工作区，切换到<code>master</code>分支。</p>
<pre><code>$ cd /path/to/user1/workspace/hello-world/
$ git checkout master
$ git pull
</code></pre>
</li>
<li>
<p>执行下面的命令将最近三个提交转换为补丁文件。</p>
<pre><code>$ git format-patch -s HEAD~3..HEAD
0001-Fix-typo-help-to-help.patch
0002-Add-I18N-support.patch
0003-Translate-for-Chinese.patch
</code></pre>
</li>
</ul>
<p>在上面的<strong>git format-patch</strong>命令中使用了<code>-s</code>参数，会在导出的补丁文件中添加当前用户的签名。</p>
<p>这个签名并非GnuPG式的数字签名，不过是将作者姓名添加到提交说明中而已，和在本书第2篇开头介绍的<strong>git commit -s</strong>命令的效果相同</p>
<p>虽然签名很不起眼，但是对于以补丁方式提交数据却非常重要，因为以补丁方式提交可能因为合并冲突或其他原因使得最终提交的作者显示为管理员（提交者）的ID，在提交说明中加入原始作者的署名信息大概是作者唯一露脸的机会</p>
<p>如果在提交时忘了使用<code>-s</code>参数添加签名，可以在用<strong>git format-path</strong>命令创建补丁文件的时候补救。</p>
<p>看一下补丁文件的文件头，在下面代码中的第7行可以看到新增的签名。</p>
<pre><code> 1 From d81896e60673771ef1873b27a33f52df75f70515 Mon Sep 17 00:00:00 2001
 2 From: user1 &lt;user1@sun.ossxp.com&gt;
 3 Date: Mon, 3 Jan 2011 23:48:56 +0800
 4 Subject: [PATCH 1/3] Fix typo: -help to --help.
 5
 6
 7 Signed-off-by: user1 &lt;user1@sun.ossxp.com&gt;
 8 ---
 9  src/main.c |    2 +-
10  1 files changed, 1 insertions(+), 1 deletions(-)
</code></pre>
<p>补丁文件有一个类似邮件一样的文件头（第1-4行），提交日志的第一行作为邮件标题（Subject），其余提交说明作为邮件内容（如果有的话），文件补丁用三个横线和提交说明分开。</p>
<p>实际上这些补丁文件可以直接拿来作为邮件发送给项目的负责人</p>
<p>Git提供了一个辅助邮件发送的命令<strong>git send-email</strong>。下</p>
<p>下面用该命令将这三个补丁文件以邮件形式发送出去。</p>
<pre><code>$ git send-email *.patch
0001-Fix-typo-help-to-help.patch
0002-Add-I18N-support.patch
0003-Translate-for-Chinese.patch
The following files are 8bit, but do not declare a Content-Transfer-Encoding.
    0002-Add-I18N-support.patch
    0003-Translate-for-Chinese.patch
Which 8bit encoding should I declare [UTF-8]?
Who should the emails appear to be from? [user1 &lt;user1@sun.ossxp.com&gt;]

Emails will be sent from: user1 &lt;user1@sun.ossxp.com&gt;
Who should the emails be sent to? jiangxin
Message-ID to be used as In-Reply-To for the first email?
...
Send this email? ([y]es|[n]o|[q]uit|[a]ll): a
...
</code></pre>
<p>命令<strong>git send-email</strong>提供交互式字符界面，输入正确的收件人地址，邮件就批量地发送出去了。</p>
<h2 id="应用补丁"><a class="header" href="#应用补丁">应用补丁</a></h2>
<p>在前面通过<strong>git send-email</strong>命令发送邮件给<code>jiangxin</code>用户。现在使用 Linux 上的<strong>mail</strong>命令检查一下邮件。</p>
<pre><code>$ mail
Mail version 8.1.2 01/15/2001.  Type ? for help.
&quot;/var/mail/jiangxin&quot;: 3 messages 3 unread
&gt;N  1 user1@sun.ossxp.c  Thu Jan 13 18:02   38/1120  [PATCH 1/3] Fix typo: -help to --help.
 N  2 user1@sun.ossxp.c  Thu Jan 13 18:02  227/6207  =?UTF-8?q?=5BPATCH=202/3=5D=20Add=20I18N=20support=2E?=
 N  3 user1@sun.ossxp.c  Thu Jan 13 18:02   95/2893  =?UTF-8?q?=5BPATCH=203/3=5D=20Translate=20for=20Chinese=2E?=
&amp;
</code></pre>
<p>如果邮件不止这三封，需要将三个包含补丁的邮件挑选出来保存到另外的文件中。 在 mail 命令的提示符(&amp;)下输入命令。</p>
<pre><code>&amp; s 1-3 user1-mail-archive
&quot;user1-mail-archive&quot; [New file]
&amp; q
</code></pre>
<p>上面的操作在本地创建了一个由开发者user1的补丁邮件组成的归档文件<code>user1-mail-archive</code>，这个文件是mbox格式的，可以用<strong>mail</strong>命令打开。</p>
<pre><code>$ mail -f user1-mail-archive
Mail version 8.1.2 01/15/2001.  Type ? for help.
&quot;user1-mail-archive&quot;: 3 messages
&gt;   1 user1@sun.ossxp.c  Thu Jan 13 18:02   38/1121  [PATCH 1/3] Fix typo: -help to --help.
    2 user1@sun.ossxp.c  Thu Jan 13 18:02  227/6208  =?UTF-8?q?=5BPATCH=202/3=5D=20Add=20I18N=20support=2E?=
    3 user1@sun.ossxp.c  Thu Jan 13 18:02   95/2894  =?UTF-8?q?=5BPATCH=203/3=5D=20Translate=20for=20Chinese=2E?=
&amp; q
</code></pre>
<p>保存在mbox中的邮件可以批量的应用在版本库中，使用<strong>git am</strong>命令。<code>am</code>是<code>apply email</code>的缩写。下面就演示一下如何应用补丁。</p>
<ul>
<li>
<p>基于<code>HEAD~3</code>版本创建一个本地分支，以便在该分支下应用补丁。</p>
<pre><code>$ git checkout -b user1 HEAD~3
Switched to a new branch 'user1'
</code></pre>
</li>
<li>
<p>将mbox文件<code>user1-mail-archive</code>中的补丁全部应用在当前分支上。</p>
<pre><code>$ git am user1-mail-archive
Applying: Fix typo: -help to --help.
Applying: Add I18N support.
Applying: Translate for Chinese.
</code></pre>
</li>
</ul>
<pre><code>$ ls *.patch
0001-Fix-typo-help-to-help.patch  0002-Add-I18N-support.patch  0003-Translate-for-Chinese.patch
$ cat *.patch | git am
Applying: Fix typo: -help to --help.
Applying: Add I18N support.
Applying: Translate for Chinese.
</code></pre>
<h2 id="stgit和quilt"><a class="header" href="#stgit和quilt">StGit和Quilt</a></h2>
<p>一个复杂功能的开发一定是由多个提交来完成的，对于在以接收和应用补丁文件为开发模式的项目中，复杂的功能需要通过多个补丁文件来完成。补丁文件因为要经过审核才能被接受，因此针对一个功能的多个补丁文件一定要保证各个都是精品：补丁1用来完成一个功能点，补丁2用来完成第二个功能点，等等。一定不能出现这样的情况：补丁3用于修正补丁1的错误，补丁10改正了补丁7中的文字错误，等等。这样就带来补丁管理的难题。</p>
<p>实际上基于特性分支的开发又何尝不是如此？在将特性分支归并到开发主线前，要接受团队的评审，特性分支的开发者一定想将特性分支上的提交进行重整，把一些提交合并或者拆分。使用变基命令可以实现提交的重整，但是操作起来会比较困难，有什么好办法呢？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="远程版本库"><a class="header" href="#远程版本库">远程版本库</a></h1>
<p>Git作为分布式版本库控制系统，每个人都是本地版本库的主人，可以在本地的版本库中随心所欲地创建分支和里程碑。当需要多人协作时，问题就出现了</p>
<ul>
<li>如何避免因为用户把所有的本地分支都推送到共享版本库，从而造成共享版本库上分支的混乱？</li>
<li>如何避免不同用户针对不同特性开发创建了相同名字的分支而造成分支名称的冲突？</li>
<li>如何避免用户随意在共享版本库中创建里程碑而导致里程碑名称上的混乱和冲突？</li>
<li>当用户向共享版本库及其他版本库推送时，每次都需要输入长长的版本库URL，太不方便了。</li>
<li>当用户需要经常从多个不同的他人版本库中获取提交时，有没有办法不要总是输入长长的版本库URL？</li>
<li>如果不带任何其他参数执行<strong>git fetch</strong>、<strong>git pull</strong>和<strong>git push</strong>到底是和哪个远程版本库及哪个分支进行交互？</li>
</ul>
<h2 id="远程分支-1"><a class="header" href="#远程分支-1">远程分支</a></h2>
<p>Git允许一个版本库和任意多的版本库进行交</p>
<p>先执行下面的命令，基于<code>hello-world.git</code>版本库再创建几个新的版本库。</p>
<pre><code>$ cd /path/to/repos/
$ git clone --bare hello-world.git hello-user1.git
Cloning into bare repository hello-user1.git...
done.
$ git clone --bare hello-world.git hello-user2.git
Cloning into bare repository hello-user2.git...
done.
</code></pre>
<p>现在有了三个共享版本库：<code>hello-world.git</code>、<code>hello-user1.git</code>和<code>hello-user2.git</code>。现在有一个疑问，如果一个本地版本库需要和上面三个版本库进行互操作，三个共享版本库都存在一个<code>master</code>分支，会不会互相干扰、冲突或覆盖呢？</p>
<p>先来看看<code>hello-world</code>远程共享版本库中包含的分支有哪些：</p>
<pre><code>$ git ls-remote --heads file:///path/to/repos/hello-world.git
8cffe5f135821e716117ee59bdd53139473bd1d8        refs/heads/hello-1.x
bb4fef88fee435bfac04b8389cf193d9c04105a6        refs/heads/helper/master
cf71ae3515e36a59c7f98b9db825fd0f2a318350        refs/heads/helper/v1.x
c4acab26ff1c1125f5e585ffa8284d27f8ceea55        refs/heads/master
</code></pre>
<p>原来远程共享版本库中有四个分支，其中<code>hello-1.x</code>分支是开发者user1创建的。现在重新克隆该版本库，如下：</p>
<pre><code>$ cd /path/to/my/workspace/
$ git clone file:///path/to/repos/hello-world.git
...
$ cd /path/to/my/workspace/hello-world
</code></pre>
<p>执行<strong>git branch</strong>命令检查分支，会吃惊地看到只有一个分支<code>master</code>。</p>
<pre><code>$ git branch
* master
</code></pre>
<p>那么远程版本库中的其他分支哪里去了？为什么本地只有一个分支呢？执行<strong>git show-ref</strong>命令可以看到全部的本地引用。</p>
<pre><code>$ git show-ref
</code></pre>
<p>从<strong>git show-ref</strong>的输出中发现了几个不寻常的引用，这些引用以<code>refs/remotes/origin/</code>为前缀，并且名称和远程版本库的分支名一一对应。</p>
<p>这些引用实际上就是从远程版本库的分支拷贝过来的，称为远程分支。</p>
<p>Git 的<strong>git branch</strong>命令也能够查看这些远程分支，不过要加上<code>-r</code>参数：</p>
<pre><code>$ git branch -r
  origin/HEAD -&gt; origin/master
  origin/hello-1.x
  origin/helper/master
  origin/helper/v1.x
  origin/master
</code></pre>
<p>Git这样的设计是非常巧妙的，在向远程版本库执行获取操作时，不是把远程版本库的分支原封不动地复制到本地版本库的分支中，而是复制到另外的命名空间。如在克隆一个版本库时，会将远程分支都复制到目录<code>.git/refs/remotes/origin/</code>下。这样向不同的远程版本库执行获取操作，因为远程分支相互隔离，所以就避免了相互的覆盖。</p>
<p>那么克隆操作产生的远程分支为什么都有一个名为“origin/”的前缀呢？奥秘就在配置文件<code>.git/config</code>中。下面的几行内容出自该配置文件，为了说明方便显示了行号。</p>
<pre><code>6 [remote &quot;origin&quot;]
7   fetch = +refs/heads/*:refs/remotes/origin/*
8   url = file:///path/to/repos/hello-world.git
</code></pre>
<p>这个小节可以称为<code>[remote]</code>小节，该小节以origin为名注册了一个远程版本库。该版本库的URL地址由第8行给出，会发现这个URL地址就是执行<strong>git clone</strong>命令时所用的地址。最具魔法的配置是第7行，这一行设置了执行<strong>git fetch origin</strong>操作时使用的默认引用表达式。</p>
<ul>
<li>该引用表达式以加号（+）开头，含义是强制进行引用的替换，即使即将进行的替换是非快进式的。</li>
<li>引用表达式中使用了通配符，冒号前面的含有通配符的引用指的是远程版本库的所有分支，冒号后面的引用含义是复制到本地的远程分支目录中。</li>
</ul>
<p>正因为有了上面的<code>[remote]</code>配置小节，当执行<strong>git fetch origin</strong>操作时,就相当于执行了下面的命令，将远程版本库的所有分支复制为本地的远程分支。</p>
<pre><code>git fetch origin +refs/heads/*:refs/remotes/origin/*
</code></pre>
<p>远程分支不是真正意义上的分支，是类似于里程碑一样的引用。，如果检出就会使得头指针<code>HEAD</code>处于分离头指针状态</p>
<h2 id="分支追踪"><a class="header" href="#分支追踪">分支追踪</a></h2>
<p>为了能够在远程分支<code>refs/remotes/origin/hello-1.x</code>上进行工作，需要基于该远程分支创建本地分支</p>
<p>远程分支可以使用简写<code>origin/hello-1.x</code>。如果Git的版本是1.6.6或者更新的版本，可以使用下面的命令同时完成分支的创建和切换。</p>
<pre><code>$ git checkout hello-1.x
Branch hello-1.x set up to track remote branch hello-1.x from origin.
Switched to a new branch 'hello-1.x'
</code></pre>
<p>如果Git的版本比较老，或注册了多个远程版本库，因此存在多个名为<code>hello-1.x</code>的远程分支，就不能使用上面简洁的分支创建和切换命令，而需要使用在上一章中学习到的分支创建命令，显式地从远程分支中创建本地分支。</p>
<pre><code>$ git checkout -b hello-1.x origin/hello-1.x
Branch hello-1.x set up to track remote branch hello-1.x from origin.
Switched to a new branch 'hello-1.x'
</code></pre>
<p>在上面基于远程分支创建本地分支的过程中，命令输出的第一行说的是<strong>建立了本地分支和远程分支的跟踪</strong>。和远程分支建立跟踪后，本地分支就具有下列特征：</p>
<ul>
<li>检查工作区状态时，会显示本地分支和被跟踪远程分支提交之间的关系。</li>
<li>当执行<strong>git pull</strong>命令时，会和被跟踪的远程分支进行合并（或者变基），如果两者出现版本偏离的话。</li>
<li>当执行<strong>git push</strong>命令时，会推送到远程版本库的同名分支中。</li>
</ul>
<p>下面就在基于远程分支创建的本地跟踪分支中进行操作，看看本地分支是如何与远程分支建立关联的。</p>
<ul>
<li>先将本地<code>hello-1.x</code>分支向后重置两个版本。</li>
</ul>
<pre><code>$ git reset --hard HEAD^^
HEAD is now at ebcf6d6 blank commit for GnuPG-signed tag test.
</code></pre>
<ul>
<li>然后查看状态，显示当前分支相比跟踪分支落后了3个版本</li>
</ul>
<p>之所以落后三个版本而非两个版本是因为<code>hello-1.x</code>的最新提交是一个合并提交，包含两个父提交，因此上面的重置命令丢弃掉三个提交。</p>
<ul>
<li>执行<strong>git pull</strong>命令，会自动与跟踪的远程分支进行合并，相当于找回最新的3个提交。</li>
<li>但是如果基于本地分支创建另外一个本地分支则没有分支跟踪的功能</li>
</ul>
<p>从远程分支创建本地分支，自动建立了分支间的跟踪，而从一个本地分支创建另外一个本地分支则没有</p>
<pre><code> 9 [branch &quot;master&quot;]
10   remote = origin
11   merge = refs/heads/master
12 [branch &quot;hello-1.x&quot;]
13   remote = origin
14   merge = refs/heads/hello-1.x
</code></pre>
<p>如果希望在基于一个本地分支创建另外一个本地分支时也能够使用分支间的跟踪功能，就要在创建分支时提供<code>--track</code>参数。</p>
<pre><code>$ git checkout --track -b hello-jx hello-1.x
Branch hello-jx set up to track local branch hello-1.x.
Switched to a new branch 'hello-jx'
</code></pre>
<p>从Git库的配置文件中会看到为<code>hello-jx</code>分支设置的跟踪。</p>
<p>因为跟踪的是本版本库的本地分支，所以第16行设置的远程版本库的名字为一个点。</p>
<pre><code>15 [branch &quot;hello-jx&quot;]
16   remote = .
17   merge = refs/heads/hello-1.x
</code></pre>
<h2 id="远程版本库-1"><a class="header" href="#远程版本库-1">远程版本库</a></h2>
<p>名为<code>origin</code>的远程版本库是在版本库克隆时注册的，那么如何注册新的远程版本库呢？</p>
<p>下面将版本库<code>file:///path/to/repos/hello-user1.git</code>以<code>new-remote</code>为名进行注册。</p>
<pre><code>$ git remote add new-remote file:///path/to/repos/hello-user1.git
</code></pre>
<p>如果再打开版本库的配置文件<code>.git/config</code>会看到新的配置。</p>
<pre><code>12 [remote &quot;new-remote&quot;]
13   url = file:///path/to/repos/hello-user1.git
14   fetch = +refs/heads/*:refs/remotes/new-remote/*
</code></pre>
<p>执行<strong>git remote</strong>命令，可以更为方便地显示已经注册的远程版本库。</p>
<pre><code>$ git remote -v
new-remote      file:///path/to/repos/hello-user1.git (fetch)
new-remote      file:///path/to/repos/hello-user1.git (push)
origin  file:///path/to/repos/hello-world.git (fetch)
origin  file:///path/to/repos/hello-world.git (push)
</code></pre>
<p>现在执行<strong>git fetch</strong>并不会从新注册的 new-remote 远程版本库获取，因为当前分支设置的默认远程版本库为 origin</p>
<p>要想从 new-remote 远程版本库中获取，需要为<strong>git fetch</strong>命令增加一个参数<code>new-remote</code>。</p>
<pre><code>$ git fetch new-remote
From file:///path/to/repos/hello-user1
 * [new branch]      hello-1.x  -&gt; new-remote/hello-1.x
 * [new branch]      helper/master -&gt; new-remote/helper/master
 * [new branch]      helper/v1.x -&gt; new-remote/helper/v1.x
 * [new branch]      master     -&gt; new-remote/master
</code></pre>
<p>从上面的命令输出中可以看出，远程版本库的分支复制到本地版本库前缀为<code>new-remote</code>的远程分支中去了。用<strong>git branch -r</strong>命令可以看到新增了几个远程分支。</p>
<pre><code>$ git branch -r
  new-remote/hello-1.x
  new-remote/helper/master
  new-remote/helper/v1.x
  new-remote/master
  origin/HEAD -&gt; origin/master
  origin/hello-1.x
  origin/helper/master
  origin/helper/v1.x
  origin/master
</code></pre>
<p><strong>更改远程版本库的地址</strong></p>
<p>如果远程版本库的URL地址改变，需要更换，该如何处理呢？</p>
<p>手工修改<code>.git/config</code>文件是一种方法，</p>
<p>用<strong>git config</strong>命令进行更改是第二种方法，</p>
<p>还有一种方法是用<strong>git remote</strong>命令，如下：</p>
<pre><code>$ git remote set-url new-remote file:///path/to/repos/hello-user2.git
</code></pre>
<p>可以看到注册的远程版本库的URL地址已经更改。</p>
<pre><code>$ git remote -v
new-remote      file:///path/to/repos/hello-user2.git (fetch)
new-remote      file:///path/to/repos/hello-user2.git (push)
origin  file:///path/to/repos/hello-world.git (fetch)
origin  file:///path/to/repos/hello-world.git (push)
</code></pre>
<p>从上面的输出中可以发现每一个远程版本库都有两个URL地址，分别是执行<strong>git fetch</strong>和<strong>git push</strong>命令时用到的URL地址。既然有两个地址，就意味着这两个地址可以不同，用下面的命令可以为推送操作设置单独的URL地址。</p>
<pre><code>$ git remote set-url --push new-remote /path/to/repos/hello-user2.git
$ git remote -v
new-remote      file:///path/to/repos/hello-user2.git (fetch)
new-remote      /path/to/repos/hello-user2.git (push)
origin  file:///path/to/repos/hello-world.git (fetch)
origin  file:///path/to/repos/hello-world.git (push)
</code></pre>
<p>当单独为推送设置了URL后，配置文件<code>.git/config</code>的对应<code>[remote]</code>小节也会增加一条新的名为<code>pushurl</code>的配置。如下：</p>
<p><strong>远程版本库更新</strong></p>
<p>当注册了多个远程版本库并希望获取所有远程版本库的更新时，Git提供了一个简单的命令。</p>
<pre><code>$ git remote update
Fetching origin
Fetching user2
</code></pre>
<p>如果某个远程版本库不想在执行<strong>git remote update</strong>时获得更新，可以通过参数关闭自动更新。例如下面的命令关闭远程版本库user2的自动更新。</p>
<pre><code>$ git config remote.user2.skipDefaultUpdate true
$ git remote update
Fetching origin
</code></pre>
<p><strong>删除远程版本库</strong></p>
<p>如果想要删除注册的远程版本库，用<strong>git remote</strong>的<strong>rm</strong>子命令可以实现。例如删除注册的user2版本库。</p>
<pre><code>$ git remote rm user2
</code></pre>
<h2 id="push和pull操作与远程版本库"><a class="header" href="#push和pull操作与远程版本库">PUSH和PULL操作与远程版本库</a></h2>
<p>在Git分支一章，已经介绍过对于新建立的本地分支（没有建立和远程分支的追踪），执行<strong>git push</strong>命令是不会被推送到远程版本库中，</p>
<p>这样的设置是非常安全的，避免了因为误操作将本地分支创建到远程版本库中。当不带任何参数执行<strong>git push</strong>命令，实际的执行过程是：</p>
<ul>
<li>
<p>如果为当前分支设置了<code>\&lt;remote&gt;</code>，即由配置<code>branch.\&lt;branchname&gt;.remote</code>给出了远程版本库代号，则不带参数执行<strong>git push</strong>相当于执行了<strong>git push &lt;remote&gt;</strong></p>
</li>
<li>
<p>如果没有为当前分支设置<code>\&lt;remote&gt;</code>，则不带参数执行<strong>git push</strong>相当于执行了<strong>git push origin</strong>。</p>
</li>
<li>
<p>要推送的远程版本库的URL地址由<code>remote.&lt;remote&gt;.pushurl</code>给出。如果没有配置，则使用<code>remote.&lt;remote&gt;.url</code>配置的URL地址。</p>
</li>
<li>
<p>如果为注册的远程版本库设置了<code>push</code>参数，即通过<code>remote.&lt;remote&gt;.push</code>配置了一个引用表达式，则使用该引用表达式执行推送。</p>
</li>
<li>
<p>否则使用“:”作为引用表达式。该表达式的含义是同名分支推送，即对所有在远程版本库有同名分支的本地分支执行推送。</p>
<p>这也就是为什么在一个本地新建分支中执行<strong>git push</strong>推送操作不会推送也不会报错的原因，因为远程不存在同名分支，所以根本就没有对该分支执行推送，而推送的是其他分支（如果远程版本库有同名分支的话）。</p>
</li>
</ul>
<p>在Git分支一章中就已经知道，如果需要在远程版本库中创建分支，则执行命令：<strong>git push <remote> &lt;new_branch&gt;</strong>。即通过将本地分支推送到远程版本库的方式在远程版本库中创建分支。</p>
<p>但是在接下来的使用中会遇到麻烦：不能执行<strong>git pull</strong>操作（不带参数）将远程版本库中其他人推送的提交获取到本地。</p>
<p>这是因为没有建立本地分支和远程分支的追踪，即没有设置<code>branch.&lt;branchname&gt;.remote</code>的值和<code>branch.&lt;branchname&gt;.merge</code>的值。</p>
<p>关于不带参数执行<strong>git pull</strong>命令解释如下：</p>
<ul>
<li>如果为当前分支设置了<code>&lt;remote&gt;</code>，即由配置<code>branch.&lt;branchname&gt;.remote</code>给出了远程版本库代号，则不带参数执行<strong>git pull</strong>相当于执行了<strong>git pull <remote></strong>。</li>
<li>如果没有为当前分支设置<code>&lt;remote&gt;</code>，则不带参数执行<strong>git pull</strong>相当于执行了<strong>git pull origin</strong>。</li>
<li>要获取的远程版本库的URL地址由<code>remote.&lt;remote&gt;.url</code>给出。</li>
<li>如果为注册的远程版本库设置了<code>fetch</code>参数，即通过<code>remote.&lt;remote&gt;.fetch</code>配置了一个引用表达式，则使用该引用表达式执行获取操作。</li>
<li>接下来要确定合并的分支。如果设定了<code>branch.&lt;branchname&gt;.merge</code>，则对其设定的分支执行合并，否则报错退出。</li>
</ul>
<p>在执行<strong>git pull</strong>操作的时候可以通过参数<code>--rebase</code>设置使用变基而非合并操作，将本地分支的改动变基到跟踪分支上。为了避免因为忘记使用<code>--rebase</code>参数导致分支的合并，可以执行如下命令进行设置。注意将<code>&lt;branchname&gt;</code>替换为对应的分支名称。</p>
<pre><code>$ git config branch.&lt;branchname&gt;.rebase true
</code></pre>
<p>有了这个设置之后，如果是在<code>&lt;branchname&gt;</code>工作分支中执行<strong>git pull</strong>命令，在遇到冲突（本地和远程分支出现偏离）的情况下，会采用变基操作，而不是默认的合并操作。</p>
<p>如果为本地版本库设置参数<code>branch.autosetuprebase</code>，值为<code>true</code>，则在基于远程分支建立本地追踪分支时，会自动配置<code>branch.&lt;branchname&gt;.rebase</code>参数，在执行<strong>git pull</strong>命令时使用变基操作取代默认的合并操作。</p>
<h2 id="里程碑和远程版本库"><a class="header" href="#里程碑和远程版本库">里程碑和远程版本库</a></h2>
<p>远程版本库中的里程碑同步到本地版本库，会使用同样的名称，而不会像分支那样移动到另外的命名空间（远程分支）中，这可能会给本地版本库中的里程碑带来混乱</p>
<p>前面的Git里程碑一章已经介绍了当执行<strong>git push</strong>命令推送时，默认不会将本地创建的里程碑带入远程版本库</p>
<p>这样可以避免远程版本库上里程碑的泛滥。</p>
<p>但是执行<strong>git fetch</strong>命令从远程版本库获取分支的最新提交时，如果获取的提交上建有里程碑，这些里程碑会被获取到本地版本库</p>
<p>当删除注册的远程版本库时，远程分支会被删除，但是该远程版本库引入的里程碑不会被删除，日积月累本地版本库中的里程碑可能会变得愈加混乱。</p>
<p>可以在执行<strong>git fetch</strong>命令的时候，设置不获取里程碑只获取分支及提交。通过提供<code>-n</code>或<code>--no-tags</code>参数可以实现。示例如下：</p>
<pre><code>$ git fetch --no-tags file:///path/to/repos/hello-world.git \
      refs/heads/*:refs/remotes/hello-world/*
</code></pre>
<p>在注册远程版本库的时候，也可以使用<code>--no-tags</code>参数，避免将远程版本库的里程碑引入本地版本库。例如：</p>
<pre><code>$ git remote add --no-tags hell-world \
      file:///path/to/repos/hello-world.git
</code></pre>
<h2 id="分支和里程碑的安全性"><a class="header" href="#分支和里程碑的安全性">分支和里程碑的安全性</a></h2>
<p>实际上Git版本库本身也提供了一些安全机制避免对版本库的破坏。</p>
<ul>
<li>
<p>用reflog记录对分支的操作历史。</p>
<p>默认创建的带工作区的版本库都会包含<code>core.logallrefupdates</code>为<code>true</code>的配置，这样在版本库中建立的每个分支都会创建对应的 reflog。但是创建的裸版本库默认不包含这个设置，也就不会为每个分支设置 reflog。如果团队的规模较小，可能因为分支误操作导致数据丢失，可以考虑为裸版本库添加<code>core.logallrefupdates</code>的相关配置。</p>
</li>
</ul>
<ul>
<li>关闭非快进式提交。
<ul>
<li>如果将配置<code>receive.denyNonFastForwards</code>设置为<code>true</code>，则禁止一切非快进式推送。但这个配置有些矫枉过正，更好的方法是搭建基于SSH协议的Git服务器，通过钩子脚本更灵活的进行配置。例如：允许来自某些用户的强制提交，而其他用户不能执行非快进式推送。</li>
</ul>
</li>
</ul>
<ul>
<li>关闭分支删除功能。</li>
</ul>
<p>如果将配置<code>receive.denyDeletes</code>设置为<code>true</code>，则禁止删除分支。同样更好的方法是通过架设基于SSH协议的Git服务器，配置分支删除的用户权限。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
